
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Personnes
 * 
 */
export type Personnes = $Result.DefaultSelection<Prisma.$PersonnesPayload>
/**
 * Model Signature
 * 
 */
export type Signature = $Result.DefaultSelection<Prisma.$SignaturePayload>
/**
 * Model Files
 * 
 */
export type Files = $Result.DefaultSelection<Prisma.$FilesPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model Accompaniment
 * 
 */
export type Accompaniment = $Result.DefaultSelection<Prisma.$AccompanimentPayload>
/**
 * Model Classe
 * 
 */
export type Classe = $Result.DefaultSelection<Prisma.$ClassePayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatParticipant
 * 
 */
export type ChatParticipant = $Result.DefaultSelection<Prisma.$ChatParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageView
 * 
 */
export type MessageView = $Result.DefaultSelection<Prisma.$MessageViewPayload>
/**
 * Model Visits
 * 
 */
export type Visits = $Result.DefaultSelection<Prisma.$VisitsPayload>
/**
 * Model Planning
 * 
 */
export type Planning = $Result.DefaultSelection<Prisma.$PlanningPayload>
/**
 * Model Maps
 * 
 */
export type Maps = $Result.DefaultSelection<Prisma.$MapsPayload>
/**
 * Model PurchaseItems
 * 
 */
export type PurchaseItems = $Result.DefaultSelection<Prisma.$PurchaseItemsPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model Emargement
 * 
 */
export type Emargement = $Result.DefaultSelection<Prisma.$EmargementPayload>
/**
 * Model VisiteTerrain
 * 
 */
export type VisiteTerrain = $Result.DefaultSelection<Prisma.$VisiteTerrainPayload>
/**
 * Model Conflit
 * 
 */
export type Conflit = $Result.DefaultSelection<Prisma.$ConflitPayload>
/**
 * Model Rencontre
 * 
 */
export type Rencontre = $Result.DefaultSelection<Prisma.$RencontrePayload>
/**
 * Model Upload
 * 
 */
export type Upload = $Result.DefaultSelection<Prisma.$UploadPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  enabled: 'enabled',
  disabled: 'disabled'
};

export type Status = (typeof Status)[keyof typeof Status]


export const Type: {
  admin: 'admin',
  employe: 'employe',
  accompanist: 'accompanist',
  trainer: 'trainer'
};

export type Type = (typeof Type)[keyof typeof Type]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type Type = $Enums.Type

export const Type: typeof $Enums.Type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Personnes
 * const personnes = await prisma.personnes.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Personnes
   * const personnes = await prisma.personnes.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.personnes`: Exposes CRUD operations for the **Personnes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personnes
    * const personnes = await prisma.personnes.findMany()
    * ```
    */
  get personnes(): Prisma.PersonnesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signature`: Exposes CRUD operations for the **Signature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signatures
    * const signatures = await prisma.signature.findMany()
    * ```
    */
  get signature(): Prisma.SignatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **Files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.FilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accompaniment`: Exposes CRUD operations for the **Accompaniment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accompaniments
    * const accompaniments = await prisma.accompaniment.findMany()
    * ```
    */
  get accompaniment(): Prisma.AccompanimentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classe`: Exposes CRUD operations for the **Classe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classe.findMany()
    * ```
    */
  get classe(): Prisma.ClasseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatParticipant`: Exposes CRUD operations for the **ChatParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatParticipants
    * const chatParticipants = await prisma.chatParticipant.findMany()
    * ```
    */
  get chatParticipant(): Prisma.ChatParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageView`: Exposes CRUD operations for the **MessageView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageViews
    * const messageViews = await prisma.messageView.findMany()
    * ```
    */
  get messageView(): Prisma.MessageViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visits`: Exposes CRUD operations for the **Visits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visits
    * const visits = await prisma.visits.findMany()
    * ```
    */
  get visits(): Prisma.VisitsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planning`: Exposes CRUD operations for the **Planning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plannings
    * const plannings = await prisma.planning.findMany()
    * ```
    */
  get planning(): Prisma.PlanningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maps`: Exposes CRUD operations for the **Maps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maps
    * const maps = await prisma.maps.findMany()
    * ```
    */
  get maps(): Prisma.MapsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseItems`: Exposes CRUD operations for the **PurchaseItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItems.findMany()
    * ```
    */
  get purchaseItems(): Prisma.PurchaseItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emargement`: Exposes CRUD operations for the **Emargement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emargements
    * const emargements = await prisma.emargement.findMany()
    * ```
    */
  get emargement(): Prisma.EmargementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visiteTerrain`: Exposes CRUD operations for the **VisiteTerrain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisiteTerrains
    * const visiteTerrains = await prisma.visiteTerrain.findMany()
    * ```
    */
  get visiteTerrain(): Prisma.VisiteTerrainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conflit`: Exposes CRUD operations for the **Conflit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conflits
    * const conflits = await prisma.conflit.findMany()
    * ```
    */
  get conflit(): Prisma.ConflitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rencontre`: Exposes CRUD operations for the **Rencontre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rencontres
    * const rencontres = await prisma.rencontre.findMany()
    * ```
    */
  get rencontre(): Prisma.RencontreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.upload`: Exposes CRUD operations for the **Upload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uploads
    * const uploads = await prisma.upload.findMany()
    * ```
    */
  get upload(): Prisma.UploadDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Personnes: 'Personnes',
    Signature: 'Signature',
    Files: 'Files',
    Users: 'Users',
    Project: 'Project',
    Leave: 'Leave',
    Accompaniment: 'Accompaniment',
    Classe: 'Classe',
    Member: 'Member',
    Chat: 'Chat',
    ChatParticipant: 'ChatParticipant',
    Message: 'Message',
    MessageView: 'MessageView',
    Visits: 'Visits',
    Planning: 'Planning',
    Maps: 'Maps',
    PurchaseItems: 'PurchaseItems',
    Purchase: 'Purchase',
    Emargement: 'Emargement',
    VisiteTerrain: 'VisiteTerrain',
    Conflit: 'Conflit',
    Rencontre: 'Rencontre',
    Upload: 'Upload'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "personnes" | "signature" | "files" | "users" | "project" | "leave" | "accompaniment" | "classe" | "member" | "chat" | "chatParticipant" | "message" | "messageView" | "visits" | "planning" | "maps" | "purchaseItems" | "purchase" | "emargement" | "visiteTerrain" | "conflit" | "rencontre" | "upload"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Personnes: {
        payload: Prisma.$PersonnesPayload<ExtArgs>
        fields: Prisma.PersonnesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>
          }
          findFirst: {
            args: Prisma.PersonnesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>
          }
          findMany: {
            args: Prisma.PersonnesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>[]
          }
          create: {
            args: Prisma.PersonnesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>
          }
          createMany: {
            args: Prisma.PersonnesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>[]
          }
          delete: {
            args: Prisma.PersonnesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>
          }
          update: {
            args: Prisma.PersonnesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>
          }
          deleteMany: {
            args: Prisma.PersonnesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonnesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>[]
          }
          upsert: {
            args: Prisma.PersonnesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnesPayload>
          }
          aggregate: {
            args: Prisma.PersonnesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnes>
          }
          groupBy: {
            args: Prisma.PersonnesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnesCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnesCountAggregateOutputType> | number
          }
        }
      }
      Signature: {
        payload: Prisma.$SignaturePayload<ExtArgs>
        fields: Prisma.SignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findFirst: {
            args: Prisma.SignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findMany: {
            args: Prisma.SignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          create: {
            args: Prisma.SignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          createMany: {
            args: Prisma.SignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          delete: {
            args: Prisma.SignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          update: {
            args: Prisma.SignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          deleteMany: {
            args: Prisma.SignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SignatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          upsert: {
            args: Prisma.SignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          aggregate: {
            args: Prisma.SignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignature>
          }
          groupBy: {
            args: Prisma.SignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignatureCountArgs<ExtArgs>
            result: $Utils.Optional<SignatureCountAggregateOutputType> | number
          }
        }
      }
      Files: {
        payload: Prisma.$FilesPayload<ExtArgs>
        fields: Prisma.FilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          findFirst: {
            args: Prisma.FilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          findMany: {
            args: Prisma.FilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>[]
          }
          create: {
            args: Prisma.FilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          createMany: {
            args: Prisma.FilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>[]
          }
          delete: {
            args: Prisma.FilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          update: {
            args: Prisma.FilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          deleteMany: {
            args: Prisma.FilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FilesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>[]
          }
          upsert: {
            args: Prisma.FilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          aggregate: {
            args: Prisma.FilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiles>
          }
          groupBy: {
            args: Prisma.FilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilesCountArgs<ExtArgs>
            result: $Utils.Optional<FilesCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      Accompaniment: {
        payload: Prisma.$AccompanimentPayload<ExtArgs>
        fields: Prisma.AccompanimentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccompanimentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccompanimentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          findFirst: {
            args: Prisma.AccompanimentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccompanimentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          findMany: {
            args: Prisma.AccompanimentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>[]
          }
          create: {
            args: Prisma.AccompanimentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          createMany: {
            args: Prisma.AccompanimentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccompanimentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>[]
          }
          delete: {
            args: Prisma.AccompanimentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          update: {
            args: Prisma.AccompanimentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          deleteMany: {
            args: Prisma.AccompanimentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccompanimentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccompanimentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>[]
          }
          upsert: {
            args: Prisma.AccompanimentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccompanimentPayload>
          }
          aggregate: {
            args: Prisma.AccompanimentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccompaniment>
          }
          groupBy: {
            args: Prisma.AccompanimentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccompanimentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccompanimentCountArgs<ExtArgs>
            result: $Utils.Optional<AccompanimentCountAggregateOutputType> | number
          }
        }
      }
      Classe: {
        payload: Prisma.$ClassePayload<ExtArgs>
        fields: Prisma.ClasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClasseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClasseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          findFirst: {
            args: Prisma.ClasseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClasseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          findMany: {
            args: Prisma.ClasseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>[]
          }
          create: {
            args: Prisma.ClasseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          createMany: {
            args: Prisma.ClasseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClasseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>[]
          }
          delete: {
            args: Prisma.ClasseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          update: {
            args: Prisma.ClasseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          deleteMany: {
            args: Prisma.ClasseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClasseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClasseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>[]
          }
          upsert: {
            args: Prisma.ClasseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          aggregate: {
            args: Prisma.ClasseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasse>
          }
          groupBy: {
            args: Prisma.ClasseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClasseCountArgs<ExtArgs>
            result: $Utils.Optional<ClasseCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatParticipant: {
        payload: Prisma.$ChatParticipantPayload<ExtArgs>
        fields: Prisma.ChatParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>
          }
          findFirst: {
            args: Prisma.ChatParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>
          }
          findMany: {
            args: Prisma.ChatParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>[]
          }
          create: {
            args: Prisma.ChatParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>
          }
          createMany: {
            args: Prisma.ChatParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>[]
          }
          delete: {
            args: Prisma.ChatParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>
          }
          update: {
            args: Prisma.ChatParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ChatParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ChatParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatParticipantPayload>
          }
          aggregate: {
            args: Prisma.ChatParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatParticipant>
          }
          groupBy: {
            args: Prisma.ChatParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ChatParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageView: {
        payload: Prisma.$MessageViewPayload<ExtArgs>
        fields: Prisma.MessageViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          findFirst: {
            args: Prisma.MessageViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          findMany: {
            args: Prisma.MessageViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>[]
          }
          create: {
            args: Prisma.MessageViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          createMany: {
            args: Prisma.MessageViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>[]
          }
          delete: {
            args: Prisma.MessageViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          update: {
            args: Prisma.MessageViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          deleteMany: {
            args: Prisma.MessageViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>[]
          }
          upsert: {
            args: Prisma.MessageViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageViewPayload>
          }
          aggregate: {
            args: Prisma.MessageViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageView>
          }
          groupBy: {
            args: Prisma.MessageViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageViewCountArgs<ExtArgs>
            result: $Utils.Optional<MessageViewCountAggregateOutputType> | number
          }
        }
      }
      Visits: {
        payload: Prisma.$VisitsPayload<ExtArgs>
        fields: Prisma.VisitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>
          }
          findFirst: {
            args: Prisma.VisitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>
          }
          findMany: {
            args: Prisma.VisitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>[]
          }
          create: {
            args: Prisma.VisitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>
          }
          createMany: {
            args: Prisma.VisitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>[]
          }
          delete: {
            args: Prisma.VisitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>
          }
          update: {
            args: Prisma.VisitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>
          }
          deleteMany: {
            args: Prisma.VisitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisitsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>[]
          }
          upsert: {
            args: Prisma.VisitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitsPayload>
          }
          aggregate: {
            args: Prisma.VisitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisits>
          }
          groupBy: {
            args: Prisma.VisitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitsCountArgs<ExtArgs>
            result: $Utils.Optional<VisitsCountAggregateOutputType> | number
          }
        }
      }
      Planning: {
        payload: Prisma.$PlanningPayload<ExtArgs>
        fields: Prisma.PlanningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          findFirst: {
            args: Prisma.PlanningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          findMany: {
            args: Prisma.PlanningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          create: {
            args: Prisma.PlanningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          createMany: {
            args: Prisma.PlanningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          delete: {
            args: Prisma.PlanningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          update: {
            args: Prisma.PlanningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          deleteMany: {
            args: Prisma.PlanningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          upsert: {
            args: Prisma.PlanningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          aggregate: {
            args: Prisma.PlanningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanning>
          }
          groupBy: {
            args: Prisma.PlanningGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanningGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanningCountArgs<ExtArgs>
            result: $Utils.Optional<PlanningCountAggregateOutputType> | number
          }
        }
      }
      Maps: {
        payload: Prisma.$MapsPayload<ExtArgs>
        fields: Prisma.MapsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>
          }
          findFirst: {
            args: Prisma.MapsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>
          }
          findMany: {
            args: Prisma.MapsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>[]
          }
          create: {
            args: Prisma.MapsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>
          }
          createMany: {
            args: Prisma.MapsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>[]
          }
          delete: {
            args: Prisma.MapsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>
          }
          update: {
            args: Prisma.MapsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>
          }
          deleteMany: {
            args: Prisma.MapsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>[]
          }
          upsert: {
            args: Prisma.MapsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapsPayload>
          }
          aggregate: {
            args: Prisma.MapsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaps>
          }
          groupBy: {
            args: Prisma.MapsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapsCountArgs<ExtArgs>
            result: $Utils.Optional<MapsCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItems: {
        payload: Prisma.$PurchaseItemsPayload<ExtArgs>
        fields: Prisma.PurchaseItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>[]
          }
          delete: {
            args: Prisma.PurchaseItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>
          }
          update: {
            args: Prisma.PurchaseItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemsPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItems>
          }
          groupBy: {
            args: Prisma.PurchaseItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemsCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemsCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      Emargement: {
        payload: Prisma.$EmargementPayload<ExtArgs>
        fields: Prisma.EmargementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmargementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmargementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>
          }
          findFirst: {
            args: Prisma.EmargementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmargementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>
          }
          findMany: {
            args: Prisma.EmargementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>[]
          }
          create: {
            args: Prisma.EmargementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>
          }
          createMany: {
            args: Prisma.EmargementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmargementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>[]
          }
          delete: {
            args: Prisma.EmargementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>
          }
          update: {
            args: Prisma.EmargementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>
          }
          deleteMany: {
            args: Prisma.EmargementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmargementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmargementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>[]
          }
          upsert: {
            args: Prisma.EmargementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmargementPayload>
          }
          aggregate: {
            args: Prisma.EmargementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmargement>
          }
          groupBy: {
            args: Prisma.EmargementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmargementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmargementCountArgs<ExtArgs>
            result: $Utils.Optional<EmargementCountAggregateOutputType> | number
          }
        }
      }
      VisiteTerrain: {
        payload: Prisma.$VisiteTerrainPayload<ExtArgs>
        fields: Prisma.VisiteTerrainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisiteTerrainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisiteTerrainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>
          }
          findFirst: {
            args: Prisma.VisiteTerrainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisiteTerrainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>
          }
          findMany: {
            args: Prisma.VisiteTerrainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>[]
          }
          create: {
            args: Prisma.VisiteTerrainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>
          }
          createMany: {
            args: Prisma.VisiteTerrainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisiteTerrainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>[]
          }
          delete: {
            args: Prisma.VisiteTerrainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>
          }
          update: {
            args: Prisma.VisiteTerrainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>
          }
          deleteMany: {
            args: Prisma.VisiteTerrainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisiteTerrainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisiteTerrainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>[]
          }
          upsert: {
            args: Prisma.VisiteTerrainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisiteTerrainPayload>
          }
          aggregate: {
            args: Prisma.VisiteTerrainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisiteTerrain>
          }
          groupBy: {
            args: Prisma.VisiteTerrainGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisiteTerrainGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisiteTerrainCountArgs<ExtArgs>
            result: $Utils.Optional<VisiteTerrainCountAggregateOutputType> | number
          }
        }
      }
      Conflit: {
        payload: Prisma.$ConflitPayload<ExtArgs>
        fields: Prisma.ConflitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConflitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConflitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          findFirst: {
            args: Prisma.ConflitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConflitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          findMany: {
            args: Prisma.ConflitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>[]
          }
          create: {
            args: Prisma.ConflitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          createMany: {
            args: Prisma.ConflitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConflitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>[]
          }
          delete: {
            args: Prisma.ConflitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          update: {
            args: Prisma.ConflitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          deleteMany: {
            args: Prisma.ConflitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConflitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConflitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>[]
          }
          upsert: {
            args: Prisma.ConflitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          aggregate: {
            args: Prisma.ConflitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConflit>
          }
          groupBy: {
            args: Prisma.ConflitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConflitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConflitCountArgs<ExtArgs>
            result: $Utils.Optional<ConflitCountAggregateOutputType> | number
          }
        }
      }
      Rencontre: {
        payload: Prisma.$RencontrePayload<ExtArgs>
        fields: Prisma.RencontreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RencontreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RencontreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>
          }
          findFirst: {
            args: Prisma.RencontreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RencontreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>
          }
          findMany: {
            args: Prisma.RencontreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>[]
          }
          create: {
            args: Prisma.RencontreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>
          }
          createMany: {
            args: Prisma.RencontreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RencontreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>[]
          }
          delete: {
            args: Prisma.RencontreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>
          }
          update: {
            args: Prisma.RencontreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>
          }
          deleteMany: {
            args: Prisma.RencontreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RencontreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RencontreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>[]
          }
          upsert: {
            args: Prisma.RencontreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RencontrePayload>
          }
          aggregate: {
            args: Prisma.RencontreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRencontre>
          }
          groupBy: {
            args: Prisma.RencontreGroupByArgs<ExtArgs>
            result: $Utils.Optional<RencontreGroupByOutputType>[]
          }
          count: {
            args: Prisma.RencontreCountArgs<ExtArgs>
            result: $Utils.Optional<RencontreCountAggregateOutputType> | number
          }
        }
      }
      Upload: {
        payload: Prisma.$UploadPayload<ExtArgs>
        fields: Prisma.UploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          findFirst: {
            args: Prisma.UploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          findMany: {
            args: Prisma.UploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          create: {
            args: Prisma.UploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          createMany: {
            args: Prisma.UploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          delete: {
            args: Prisma.UploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          update: {
            args: Prisma.UploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          deleteMany: {
            args: Prisma.UploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UploadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          upsert: {
            args: Prisma.UploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          aggregate: {
            args: Prisma.UploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpload>
          }
          groupBy: {
            args: Prisma.UploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadCountArgs<ExtArgs>
            result: $Utils.Optional<UploadCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    personnes?: PersonnesOmit
    signature?: SignatureOmit
    files?: FilesOmit
    users?: UsersOmit
    project?: ProjectOmit
    leave?: LeaveOmit
    accompaniment?: AccompanimentOmit
    classe?: ClasseOmit
    member?: MemberOmit
    chat?: ChatOmit
    chatParticipant?: ChatParticipantOmit
    message?: MessageOmit
    messageView?: MessageViewOmit
    visits?: VisitsOmit
    planning?: PlanningOmit
    maps?: MapsOmit
    purchaseItems?: PurchaseItemsOmit
    purchase?: PurchaseOmit
    emargement?: EmargementOmit
    visiteTerrain?: VisiteTerrainOmit
    conflit?: ConflitOmit
    rencontre?: RencontreOmit
    upload?: UploadOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FilesCountOutputType
   */

  export type FilesCountOutputType = {
    Upload: number
    Users: number
    accompaniments: number
    media: number
  }

  export type FilesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Upload?: boolean | FilesCountOutputTypeCountUploadArgs
    Users?: boolean | FilesCountOutputTypeCountUsersArgs
    accompaniments?: boolean | FilesCountOutputTypeCountAccompanimentsArgs
    media?: boolean | FilesCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesCountOutputType
     */
    select?: FilesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeCountUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
  }

  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeCountAccompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
  }

  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    accompaniments: number
    plannings: number
    emargements: number
    visiteTerrains: number
    rencontres: number
    conflit: number
    chatParticipant: number
    message: number
    uploads: number
    messageView: number
    Classe: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniments?: boolean | UsersCountOutputTypeCountAccompanimentsArgs
    plannings?: boolean | UsersCountOutputTypeCountPlanningsArgs
    emargements?: boolean | UsersCountOutputTypeCountEmargementsArgs
    visiteTerrains?: boolean | UsersCountOutputTypeCountVisiteTerrainsArgs
    rencontres?: boolean | UsersCountOutputTypeCountRencontresArgs
    conflit?: boolean | UsersCountOutputTypeCountConflitArgs
    chatParticipant?: boolean | UsersCountOutputTypeCountChatParticipantArgs
    message?: boolean | UsersCountOutputTypeCountMessageArgs
    uploads?: boolean | UsersCountOutputTypeCountUploadsArgs
    messageView?: boolean | UsersCountOutputTypeCountMessageViewArgs
    Classe?: boolean | UsersCountOutputTypeCountClasseArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAccompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEmargementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmargementWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVisiteTerrainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisiteTerrainWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRencontresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RencontreWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConflitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflitWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChatParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatParticipantWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessageViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageViewWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    accompaniments: number
    leave: number
    members: number
    classes: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniments?: boolean | ProjectCountOutputTypeCountAccompanimentsArgs
    leave?: boolean | ProjectCountOutputTypeCountLeaveArgs
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    classes?: boolean | ProjectCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAccompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLeaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
  }


  /**
   * Count Type AccompanimentCountOutputType
   */

  export type AccompanimentCountOutputType = {
    members: number
    media: number
    purchases: number
    conflits: number
    rencontre: number
  }

  export type AccompanimentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | AccompanimentCountOutputTypeCountMembersArgs
    media?: boolean | AccompanimentCountOutputTypeCountMediaArgs
    purchases?: boolean | AccompanimentCountOutputTypeCountPurchasesArgs
    conflits?: boolean | AccompanimentCountOutputTypeCountConflitsArgs
    rencontre?: boolean | AccompanimentCountOutputTypeCountRencontreArgs
  }

  // Custom InputTypes
  /**
   * AccompanimentCountOutputType without action
   */
  export type AccompanimentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccompanimentCountOutputType
     */
    select?: AccompanimentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccompanimentCountOutputType without action
   */
  export type AccompanimentCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * AccompanimentCountOutputType without action
   */
  export type AccompanimentCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
  }

  /**
   * AccompanimentCountOutputType without action
   */
  export type AccompanimentCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * AccompanimentCountOutputType without action
   */
  export type AccompanimentCountOutputTypeCountConflitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflitWhereInput
  }

  /**
   * AccompanimentCountOutputType without action
   */
  export type AccompanimentCountOutputTypeCountRencontreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RencontreWhereInput
  }


  /**
   * Count Type ClasseCountOutputType
   */

  export type ClasseCountOutputType = {
    members: number
  }

  export type ClasseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ClasseCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClasseCountOutputType
     */
    select?: ClasseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    signatures: number
    emargements: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signatures?: boolean | MemberCountOutputTypeCountSignaturesArgs
    emargements?: boolean | MemberCountOutputTypeCountEmargementsArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountEmargementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmargementWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    participants: number
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ChatCountOutputTypeCountParticipantsArgs
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatParticipantWhereInput
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    messageView: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messageView?: boolean | MessageCountOutputTypeCountMessageViewArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountMessageViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageViewWhereInput
  }


  /**
   * Count Type PlanningCountOutputType
   */

  export type PlanningCountOutputType = {
    accompaniments: number
    visit: number
  }

  export type PlanningCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniments?: boolean | PlanningCountOutputTypeCountAccompanimentsArgs
    visit?: boolean | PlanningCountOutputTypeCountVisitArgs
  }

  // Custom InputTypes
  /**
   * PlanningCountOutputType without action
   */
  export type PlanningCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningCountOutputType
     */
    select?: PlanningCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanningCountOutputType without action
   */
  export type PlanningCountOutputTypeCountAccompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
  }

  /**
   * PlanningCountOutputType without action
   */
  export type PlanningCountOutputTypeCountVisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitsWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    purchaseItems: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | PurchaseCountOutputTypeCountPurchaseItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemsWhereInput
  }


  /**
   * Count Type VisiteTerrainCountOutputType
   */

  export type VisiteTerrainCountOutputType = {
    personnes: number
    files: number
  }

  export type VisiteTerrainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnes?: boolean | VisiteTerrainCountOutputTypeCountPersonnesArgs
    files?: boolean | VisiteTerrainCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * VisiteTerrainCountOutputType without action
   */
  export type VisiteTerrainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrainCountOutputType
     */
    select?: VisiteTerrainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisiteTerrainCountOutputType without action
   */
  export type VisiteTerrainCountOutputTypeCountPersonnesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnesWhereInput
  }

  /**
   * VisiteTerrainCountOutputType without action
   */
  export type VisiteTerrainCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
  }


  /**
   * Count Type ConflitCountOutputType
   */

  export type ConflitCountOutputType = {
    partieImpliques: number
    files: number
  }

  export type ConflitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partieImpliques?: boolean | ConflitCountOutputTypeCountPartieImpliquesArgs
    files?: boolean | ConflitCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * ConflitCountOutputType without action
   */
  export type ConflitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflitCountOutputType
     */
    select?: ConflitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConflitCountOutputType without action
   */
  export type ConflitCountOutputTypeCountPartieImpliquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnesWhereInput
  }

  /**
   * ConflitCountOutputType without action
   */
  export type ConflitCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
  }


  /**
   * Count Type RencontreCountOutputType
   */

  export type RencontreCountOutputType = {
    signatures: number
    files: number
  }

  export type RencontreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signatures?: boolean | RencontreCountOutputTypeCountSignaturesArgs
    files?: boolean | RencontreCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * RencontreCountOutputType without action
   */
  export type RencontreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RencontreCountOutputType
     */
    select?: RencontreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RencontreCountOutputType without action
   */
  export type RencontreCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
  }

  /**
   * RencontreCountOutputType without action
   */
  export type RencontreCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Personnes
   */

  export type AggregatePersonnes = {
    _count: PersonnesCountAggregateOutputType | null
    _min: PersonnesMinAggregateOutputType | null
    _max: PersonnesMaxAggregateOutputType | null
  }

  export type PersonnesMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    signature: boolean | null
    conflitId: string | null
    visiteTerrainId: string | null
  }

  export type PersonnesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    signature: boolean | null
    conflitId: string | null
    visiteTerrainId: string | null
  }

  export type PersonnesCountAggregateOutputType = {
    id: number
    name: number
    role: number
    signature: number
    conflitId: number
    visiteTerrainId: number
    _all: number
  }


  export type PersonnesMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    signature?: true
    conflitId?: true
    visiteTerrainId?: true
  }

  export type PersonnesMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    signature?: true
    conflitId?: true
    visiteTerrainId?: true
  }

  export type PersonnesCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    signature?: true
    conflitId?: true
    visiteTerrainId?: true
    _all?: true
  }

  export type PersonnesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnes to aggregate.
     */
    where?: PersonnesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnes to fetch.
     */
    orderBy?: PersonnesOrderByWithRelationInput | PersonnesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personnes
    **/
    _count?: true | PersonnesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnesMaxAggregateInputType
  }

  export type GetPersonnesAggregateType<T extends PersonnesAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnes[P]>
      : GetScalarType<T[P], AggregatePersonnes[P]>
  }




  export type PersonnesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnesWhereInput
    orderBy?: PersonnesOrderByWithAggregationInput | PersonnesOrderByWithAggregationInput[]
    by: PersonnesScalarFieldEnum[] | PersonnesScalarFieldEnum
    having?: PersonnesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnesCountAggregateInputType | true
    _min?: PersonnesMinAggregateInputType
    _max?: PersonnesMaxAggregateInputType
  }

  export type PersonnesGroupByOutputType = {
    id: string
    name: string
    role: string
    signature: boolean
    conflitId: string | null
    visiteTerrainId: string | null
    _count: PersonnesCountAggregateOutputType | null
    _min: PersonnesMinAggregateOutputType | null
    _max: PersonnesMaxAggregateOutputType | null
  }

  type GetPersonnesGroupByPayload<T extends PersonnesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnesGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnesGroupByOutputType[P]>
        }
      >
    >


  export type PersonnesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    signature?: boolean
    conflitId?: boolean
    visiteTerrainId?: boolean
    Conflit?: boolean | Personnes$ConflitArgs<ExtArgs>
    VisiteTerrain?: boolean | Personnes$VisiteTerrainArgs<ExtArgs>
  }, ExtArgs["result"]["personnes"]>

  export type PersonnesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    signature?: boolean
    conflitId?: boolean
    visiteTerrainId?: boolean
    Conflit?: boolean | Personnes$ConflitArgs<ExtArgs>
    VisiteTerrain?: boolean | Personnes$VisiteTerrainArgs<ExtArgs>
  }, ExtArgs["result"]["personnes"]>

  export type PersonnesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    signature?: boolean
    conflitId?: boolean
    visiteTerrainId?: boolean
    Conflit?: boolean | Personnes$ConflitArgs<ExtArgs>
    VisiteTerrain?: boolean | Personnes$VisiteTerrainArgs<ExtArgs>
  }, ExtArgs["result"]["personnes"]>

  export type PersonnesSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    signature?: boolean
    conflitId?: boolean
    visiteTerrainId?: boolean
  }

  export type PersonnesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "signature" | "conflitId" | "visiteTerrainId", ExtArgs["result"]["personnes"]>
  export type PersonnesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conflit?: boolean | Personnes$ConflitArgs<ExtArgs>
    VisiteTerrain?: boolean | Personnes$VisiteTerrainArgs<ExtArgs>
  }
  export type PersonnesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conflit?: boolean | Personnes$ConflitArgs<ExtArgs>
    VisiteTerrain?: boolean | Personnes$VisiteTerrainArgs<ExtArgs>
  }
  export type PersonnesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Conflit?: boolean | Personnes$ConflitArgs<ExtArgs>
    VisiteTerrain?: boolean | Personnes$VisiteTerrainArgs<ExtArgs>
  }

  export type $PersonnesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Personnes"
    objects: {
      Conflit: Prisma.$ConflitPayload<ExtArgs> | null
      VisiteTerrain: Prisma.$VisiteTerrainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      signature: boolean
      conflitId: string | null
      visiteTerrainId: string | null
    }, ExtArgs["result"]["personnes"]>
    composites: {}
  }

  type PersonnesGetPayload<S extends boolean | null | undefined | PersonnesDefaultArgs> = $Result.GetResult<Prisma.$PersonnesPayload, S>

  type PersonnesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonnesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonnesCountAggregateInputType | true
    }

  export interface PersonnesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Personnes'], meta: { name: 'Personnes' } }
    /**
     * Find zero or one Personnes that matches the filter.
     * @param {PersonnesFindUniqueArgs} args - Arguments to find a Personnes
     * @example
     * // Get one Personnes
     * const personnes = await prisma.personnes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnesFindUniqueArgs>(args: SelectSubset<T, PersonnesFindUniqueArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Personnes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonnesFindUniqueOrThrowArgs} args - Arguments to find a Personnes
     * @example
     * // Get one Personnes
     * const personnes = await prisma.personnes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnesFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Personnes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesFindFirstArgs} args - Arguments to find a Personnes
     * @example
     * // Get one Personnes
     * const personnes = await prisma.personnes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnesFindFirstArgs>(args?: SelectSubset<T, PersonnesFindFirstArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Personnes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesFindFirstOrThrowArgs} args - Arguments to find a Personnes
     * @example
     * // Get one Personnes
     * const personnes = await prisma.personnes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnesFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Personnes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personnes
     * const personnes = await prisma.personnes.findMany()
     * 
     * // Get first 10 Personnes
     * const personnes = await prisma.personnes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personnesWithIdOnly = await prisma.personnes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonnesFindManyArgs>(args?: SelectSubset<T, PersonnesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Personnes.
     * @param {PersonnesCreateArgs} args - Arguments to create a Personnes.
     * @example
     * // Create one Personnes
     * const Personnes = await prisma.personnes.create({
     *   data: {
     *     // ... data to create a Personnes
     *   }
     * })
     * 
     */
    create<T extends PersonnesCreateArgs>(args: SelectSubset<T, PersonnesCreateArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Personnes.
     * @param {PersonnesCreateManyArgs} args - Arguments to create many Personnes.
     * @example
     * // Create many Personnes
     * const personnes = await prisma.personnes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnesCreateManyArgs>(args?: SelectSubset<T, PersonnesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personnes and returns the data saved in the database.
     * @param {PersonnesCreateManyAndReturnArgs} args - Arguments to create many Personnes.
     * @example
     * // Create many Personnes
     * const personnes = await prisma.personnes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personnes and only return the `id`
     * const personnesWithIdOnly = await prisma.personnes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnesCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Personnes.
     * @param {PersonnesDeleteArgs} args - Arguments to delete one Personnes.
     * @example
     * // Delete one Personnes
     * const Personnes = await prisma.personnes.delete({
     *   where: {
     *     // ... filter to delete one Personnes
     *   }
     * })
     * 
     */
    delete<T extends PersonnesDeleteArgs>(args: SelectSubset<T, PersonnesDeleteArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Personnes.
     * @param {PersonnesUpdateArgs} args - Arguments to update one Personnes.
     * @example
     * // Update one Personnes
     * const personnes = await prisma.personnes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnesUpdateArgs>(args: SelectSubset<T, PersonnesUpdateArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Personnes.
     * @param {PersonnesDeleteManyArgs} args - Arguments to filter Personnes to delete.
     * @example
     * // Delete a few Personnes
     * const { count } = await prisma.personnes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnesDeleteManyArgs>(args?: SelectSubset<T, PersonnesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personnes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personnes
     * const personnes = await prisma.personnes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnesUpdateManyArgs>(args: SelectSubset<T, PersonnesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personnes and returns the data updated in the database.
     * @param {PersonnesUpdateManyAndReturnArgs} args - Arguments to update many Personnes.
     * @example
     * // Update many Personnes
     * const personnes = await prisma.personnes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Personnes and only return the `id`
     * const personnesWithIdOnly = await prisma.personnes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonnesUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonnesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Personnes.
     * @param {PersonnesUpsertArgs} args - Arguments to update or create a Personnes.
     * @example
     * // Update or create a Personnes
     * const personnes = await prisma.personnes.upsert({
     *   create: {
     *     // ... data to create a Personnes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personnes we want to update
     *   }
     * })
     */
    upsert<T extends PersonnesUpsertArgs>(args: SelectSubset<T, PersonnesUpsertArgs<ExtArgs>>): Prisma__PersonnesClient<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Personnes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesCountArgs} args - Arguments to filter Personnes to count.
     * @example
     * // Count the number of Personnes
     * const count = await prisma.personnes.count({
     *   where: {
     *     // ... the filter for the Personnes we want to count
     *   }
     * })
    **/
    count<T extends PersonnesCountArgs>(
      args?: Subset<T, PersonnesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personnes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnesAggregateArgs>(args: Subset<T, PersonnesAggregateArgs>): Prisma.PrismaPromise<GetPersonnesAggregateType<T>>

    /**
     * Group by Personnes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnesGroupByArgs['orderBy'] }
        : { orderBy?: PersonnesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Personnes model
   */
  readonly fields: PersonnesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Personnes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Conflit<T extends Personnes$ConflitArgs<ExtArgs> = {}>(args?: Subset<T, Personnes$ConflitArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    VisiteTerrain<T extends Personnes$VisiteTerrainArgs<ExtArgs> = {}>(args?: Subset<T, Personnes$VisiteTerrainArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Personnes model
   */
  interface PersonnesFieldRefs {
    readonly id: FieldRef<"Personnes", 'String'>
    readonly name: FieldRef<"Personnes", 'String'>
    readonly role: FieldRef<"Personnes", 'String'>
    readonly signature: FieldRef<"Personnes", 'Boolean'>
    readonly conflitId: FieldRef<"Personnes", 'String'>
    readonly visiteTerrainId: FieldRef<"Personnes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Personnes findUnique
   */
  export type PersonnesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * Filter, which Personnes to fetch.
     */
    where: PersonnesWhereUniqueInput
  }

  /**
   * Personnes findUniqueOrThrow
   */
  export type PersonnesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * Filter, which Personnes to fetch.
     */
    where: PersonnesWhereUniqueInput
  }

  /**
   * Personnes findFirst
   */
  export type PersonnesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * Filter, which Personnes to fetch.
     */
    where?: PersonnesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnes to fetch.
     */
    orderBy?: PersonnesOrderByWithRelationInput | PersonnesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnes.
     */
    cursor?: PersonnesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnes.
     */
    distinct?: PersonnesScalarFieldEnum | PersonnesScalarFieldEnum[]
  }

  /**
   * Personnes findFirstOrThrow
   */
  export type PersonnesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * Filter, which Personnes to fetch.
     */
    where?: PersonnesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnes to fetch.
     */
    orderBy?: PersonnesOrderByWithRelationInput | PersonnesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnes.
     */
    cursor?: PersonnesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnes.
     */
    distinct?: PersonnesScalarFieldEnum | PersonnesScalarFieldEnum[]
  }

  /**
   * Personnes findMany
   */
  export type PersonnesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * Filter, which Personnes to fetch.
     */
    where?: PersonnesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnes to fetch.
     */
    orderBy?: PersonnesOrderByWithRelationInput | PersonnesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personnes.
     */
    cursor?: PersonnesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnes.
     */
    skip?: number
    distinct?: PersonnesScalarFieldEnum | PersonnesScalarFieldEnum[]
  }

  /**
   * Personnes create
   */
  export type PersonnesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * The data needed to create a Personnes.
     */
    data: XOR<PersonnesCreateInput, PersonnesUncheckedCreateInput>
  }

  /**
   * Personnes createMany
   */
  export type PersonnesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personnes.
     */
    data: PersonnesCreateManyInput | PersonnesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Personnes createManyAndReturn
   */
  export type PersonnesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * The data used to create many Personnes.
     */
    data: PersonnesCreateManyInput | PersonnesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Personnes update
   */
  export type PersonnesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * The data needed to update a Personnes.
     */
    data: XOR<PersonnesUpdateInput, PersonnesUncheckedUpdateInput>
    /**
     * Choose, which Personnes to update.
     */
    where: PersonnesWhereUniqueInput
  }

  /**
   * Personnes updateMany
   */
  export type PersonnesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personnes.
     */
    data: XOR<PersonnesUpdateManyMutationInput, PersonnesUncheckedUpdateManyInput>
    /**
     * Filter which Personnes to update
     */
    where?: PersonnesWhereInput
    /**
     * Limit how many Personnes to update.
     */
    limit?: number
  }

  /**
   * Personnes updateManyAndReturn
   */
  export type PersonnesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * The data used to update Personnes.
     */
    data: XOR<PersonnesUpdateManyMutationInput, PersonnesUncheckedUpdateManyInput>
    /**
     * Filter which Personnes to update
     */
    where?: PersonnesWhereInput
    /**
     * Limit how many Personnes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Personnes upsert
   */
  export type PersonnesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * The filter to search for the Personnes to update in case it exists.
     */
    where: PersonnesWhereUniqueInput
    /**
     * In case the Personnes found by the `where` argument doesn't exist, create a new Personnes with this data.
     */
    create: XOR<PersonnesCreateInput, PersonnesUncheckedCreateInput>
    /**
     * In case the Personnes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnesUpdateInput, PersonnesUncheckedUpdateInput>
  }

  /**
   * Personnes delete
   */
  export type PersonnesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    /**
     * Filter which Personnes to delete.
     */
    where: PersonnesWhereUniqueInput
  }

  /**
   * Personnes deleteMany
   */
  export type PersonnesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnes to delete
     */
    where?: PersonnesWhereInput
    /**
     * Limit how many Personnes to delete.
     */
    limit?: number
  }

  /**
   * Personnes.Conflit
   */
  export type Personnes$ConflitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    where?: ConflitWhereInput
  }

  /**
   * Personnes.VisiteTerrain
   */
  export type Personnes$VisiteTerrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    where?: VisiteTerrainWhereInput
  }

  /**
   * Personnes without action
   */
  export type PersonnesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
  }


  /**
   * Model Signature
   */

  export type AggregateSignature = {
    _count: SignatureCountAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  export type SignatureMinAggregateOutputType = {
    id: string | null
    date: Date | null
    present: boolean | null
    memberId: string | null
    rencontreId: string | null
  }

  export type SignatureMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    present: boolean | null
    memberId: string | null
    rencontreId: string | null
  }

  export type SignatureCountAggregateOutputType = {
    id: number
    date: number
    present: number
    memberId: number
    rencontreId: number
    _all: number
  }


  export type SignatureMinAggregateInputType = {
    id?: true
    date?: true
    present?: true
    memberId?: true
    rencontreId?: true
  }

  export type SignatureMaxAggregateInputType = {
    id?: true
    date?: true
    present?: true
    memberId?: true
    rencontreId?: true
  }

  export type SignatureCountAggregateInputType = {
    id?: true
    date?: true
    present?: true
    memberId?: true
    rencontreId?: true
    _all?: true
  }

  export type SignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signature to aggregate.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signatures
    **/
    _count?: true | SignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignatureMaxAggregateInputType
  }

  export type GetSignatureAggregateType<T extends SignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignature[P]>
      : GetScalarType<T[P], AggregateSignature[P]>
  }




  export type SignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithAggregationInput | SignatureOrderByWithAggregationInput[]
    by: SignatureScalarFieldEnum[] | SignatureScalarFieldEnum
    having?: SignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignatureCountAggregateInputType | true
    _min?: SignatureMinAggregateInputType
    _max?: SignatureMaxAggregateInputType
  }

  export type SignatureGroupByOutputType = {
    id: string
    date: Date
    present: boolean
    memberId: string
    rencontreId: string | null
    _count: SignatureCountAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  type GetSignatureGroupByPayload<T extends SignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignatureGroupByOutputType[P]>
            : GetScalarType<T[P], SignatureGroupByOutputType[P]>
        }
      >
    >


  export type SignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    present?: boolean
    memberId?: boolean
    rencontreId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    Rencontre?: boolean | Signature$RencontreArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>

  export type SignatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    present?: boolean
    memberId?: boolean
    rencontreId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    Rencontre?: boolean | Signature$RencontreArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>

  export type SignatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    present?: boolean
    memberId?: boolean
    rencontreId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    Rencontre?: boolean | Signature$RencontreArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>

  export type SignatureSelectScalar = {
    id?: boolean
    date?: boolean
    present?: boolean
    memberId?: boolean
    rencontreId?: boolean
  }

  export type SignatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "present" | "memberId" | "rencontreId", ExtArgs["result"]["signature"]>
  export type SignatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    Rencontre?: boolean | Signature$RencontreArgs<ExtArgs>
  }
  export type SignatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    Rencontre?: boolean | Signature$RencontreArgs<ExtArgs>
  }
  export type SignatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    Rencontre?: boolean | Signature$RencontreArgs<ExtArgs>
  }

  export type $SignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signature"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      Rencontre: Prisma.$RencontrePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      present: boolean
      memberId: string
      rencontreId: string | null
    }, ExtArgs["result"]["signature"]>
    composites: {}
  }

  type SignatureGetPayload<S extends boolean | null | undefined | SignatureDefaultArgs> = $Result.GetResult<Prisma.$SignaturePayload, S>

  type SignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignatureCountAggregateInputType | true
    }

  export interface SignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signature'], meta: { name: 'Signature' } }
    /**
     * Find zero or one Signature that matches the filter.
     * @param {SignatureFindUniqueArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignatureFindUniqueArgs>(args: SelectSubset<T, SignatureFindUniqueArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignatureFindUniqueOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignatureFindFirstArgs>(args?: SelectSubset<T, SignatureFindFirstArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signatures
     * const signatures = await prisma.signature.findMany()
     * 
     * // Get first 10 Signatures
     * const signatures = await prisma.signature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signatureWithIdOnly = await prisma.signature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignatureFindManyArgs>(args?: SelectSubset<T, SignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signature.
     * @param {SignatureCreateArgs} args - Arguments to create a Signature.
     * @example
     * // Create one Signature
     * const Signature = await prisma.signature.create({
     *   data: {
     *     // ... data to create a Signature
     *   }
     * })
     * 
     */
    create<T extends SignatureCreateArgs>(args: SelectSubset<T, SignatureCreateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signatures.
     * @param {SignatureCreateManyArgs} args - Arguments to create many Signatures.
     * @example
     * // Create many Signatures
     * const signature = await prisma.signature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignatureCreateManyArgs>(args?: SelectSubset<T, SignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signatures and returns the data saved in the database.
     * @param {SignatureCreateManyAndReturnArgs} args - Arguments to create many Signatures.
     * @example
     * // Create many Signatures
     * const signature = await prisma.signature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signatures and only return the `id`
     * const signatureWithIdOnly = await prisma.signature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignatureCreateManyAndReturnArgs>(args?: SelectSubset<T, SignatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signature.
     * @param {SignatureDeleteArgs} args - Arguments to delete one Signature.
     * @example
     * // Delete one Signature
     * const Signature = await prisma.signature.delete({
     *   where: {
     *     // ... filter to delete one Signature
     *   }
     * })
     * 
     */
    delete<T extends SignatureDeleteArgs>(args: SelectSubset<T, SignatureDeleteArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signature.
     * @param {SignatureUpdateArgs} args - Arguments to update one Signature.
     * @example
     * // Update one Signature
     * const signature = await prisma.signature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignatureUpdateArgs>(args: SelectSubset<T, SignatureUpdateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signatures.
     * @param {SignatureDeleteManyArgs} args - Arguments to filter Signatures to delete.
     * @example
     * // Delete a few Signatures
     * const { count } = await prisma.signature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignatureDeleteManyArgs>(args?: SelectSubset<T, SignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signatures
     * const signature = await prisma.signature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignatureUpdateManyArgs>(args: SelectSubset<T, SignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signatures and returns the data updated in the database.
     * @param {SignatureUpdateManyAndReturnArgs} args - Arguments to update many Signatures.
     * @example
     * // Update many Signatures
     * const signature = await prisma.signature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signatures and only return the `id`
     * const signatureWithIdOnly = await prisma.signature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SignatureUpdateManyAndReturnArgs>(args: SelectSubset<T, SignatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signature.
     * @param {SignatureUpsertArgs} args - Arguments to update or create a Signature.
     * @example
     * // Update or create a Signature
     * const signature = await prisma.signature.upsert({
     *   create: {
     *     // ... data to create a Signature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signature we want to update
     *   }
     * })
     */
    upsert<T extends SignatureUpsertArgs>(args: SelectSubset<T, SignatureUpsertArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureCountArgs} args - Arguments to filter Signatures to count.
     * @example
     * // Count the number of Signatures
     * const count = await prisma.signature.count({
     *   where: {
     *     // ... the filter for the Signatures we want to count
     *   }
     * })
    **/
    count<T extends SignatureCountArgs>(
      args?: Subset<T, SignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignatureAggregateArgs>(args: Subset<T, SignatureAggregateArgs>): Prisma.PrismaPromise<GetSignatureAggregateType<T>>

    /**
     * Group by Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignatureGroupByArgs['orderBy'] }
        : { orderBy?: SignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signature model
   */
  readonly fields: SignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Rencontre<T extends Signature$RencontreArgs<ExtArgs> = {}>(args?: Subset<T, Signature$RencontreArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signature model
   */
  interface SignatureFieldRefs {
    readonly id: FieldRef<"Signature", 'String'>
    readonly date: FieldRef<"Signature", 'DateTime'>
    readonly present: FieldRef<"Signature", 'Boolean'>
    readonly memberId: FieldRef<"Signature", 'String'>
    readonly rencontreId: FieldRef<"Signature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Signature findUnique
   */
  export type SignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findUniqueOrThrow
   */
  export type SignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findFirst
   */
  export type SignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findFirstOrThrow
   */
  export type SignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findMany
   */
  export type SignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signatures to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature create
   */
  export type SignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Signature.
     */
    data: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
  }

  /**
   * Signature createMany
   */
  export type SignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signatures.
     */
    data: SignatureCreateManyInput | SignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signature createManyAndReturn
   */
  export type SignatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The data used to create many Signatures.
     */
    data: SignatureCreateManyInput | SignatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signature update
   */
  export type SignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Signature.
     */
    data: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
    /**
     * Choose, which Signature to update.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature updateMany
   */
  export type SignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signatures.
     */
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyInput>
    /**
     * Filter which Signatures to update
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to update.
     */
    limit?: number
  }

  /**
   * Signature updateManyAndReturn
   */
  export type SignatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The data used to update Signatures.
     */
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyInput>
    /**
     * Filter which Signatures to update
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signature upsert
   */
  export type SignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Signature to update in case it exists.
     */
    where: SignatureWhereUniqueInput
    /**
     * In case the Signature found by the `where` argument doesn't exist, create a new Signature with this data.
     */
    create: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
    /**
     * In case the Signature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
  }

  /**
   * Signature delete
   */
  export type SignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter which Signature to delete.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature deleteMany
   */
  export type SignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signatures to delete
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to delete.
     */
    limit?: number
  }

  /**
   * Signature.Rencontre
   */
  export type Signature$RencontreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    where?: RencontreWhereInput
  }

  /**
   * Signature without action
   */
  export type SignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
  }


  /**
   * Model Files
   */

  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    size: number | null
  }

  export type FilesSumAggregateOutputType = {
    size: number | null
  }

  export type FilesMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    url: string | null
    size: number | null
    visiteTerrainId: string | null
    conflitId: string | null
    rencontreId: string | null
  }

  export type FilesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    url: string | null
    size: number | null
    visiteTerrainId: string | null
    conflitId: string | null
    rencontreId: string | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    name: number
    type: number
    url: number
    size: number
    visiteTerrainId: number
    conflitId: number
    rencontreId: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    size?: true
  }

  export type FilesSumAggregateInputType = {
    size?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    size?: true
    visiteTerrainId?: true
    conflitId?: true
    rencontreId?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    size?: true
    visiteTerrainId?: true
    conflitId?: true
    rencontreId?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    size?: true
    visiteTerrainId?: true
    conflitId?: true
    rencontreId?: true
    _all?: true
  }

  export type FilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to aggregate.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type FilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithAggregationInput | FilesOrderByWithAggregationInput[]
    by: FilesScalarFieldEnum[] | FilesScalarFieldEnum
    having?: FilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }

  export type FilesGroupByOutputType = {
    id: string
    name: string
    type: string
    url: string
    size: number
    visiteTerrainId: string | null
    conflitId: string | null
    rencontreId: string | null
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends FilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type FilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    visiteTerrainId?: boolean
    conflitId?: boolean
    rencontreId?: boolean
    visiteTerrain?: boolean | Files$visiteTerrainArgs<ExtArgs>
    conflit?: boolean | Files$conflitArgs<ExtArgs>
    rencontre?: boolean | Files$rencontreArgs<ExtArgs>
    Upload?: boolean | Files$UploadArgs<ExtArgs>
    Users?: boolean | Files$UsersArgs<ExtArgs>
    accompaniments?: boolean | Files$accompanimentsArgs<ExtArgs>
    media?: boolean | Files$mediaArgs<ExtArgs>
    _count?: boolean | FilesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["files"]>

  export type FilesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    visiteTerrainId?: boolean
    conflitId?: boolean
    rencontreId?: boolean
    visiteTerrain?: boolean | Files$visiteTerrainArgs<ExtArgs>
    conflit?: boolean | Files$conflitArgs<ExtArgs>
    rencontre?: boolean | Files$rencontreArgs<ExtArgs>
  }, ExtArgs["result"]["files"]>

  export type FilesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    visiteTerrainId?: boolean
    conflitId?: boolean
    rencontreId?: boolean
    visiteTerrain?: boolean | Files$visiteTerrainArgs<ExtArgs>
    conflit?: boolean | Files$conflitArgs<ExtArgs>
    rencontre?: boolean | Files$rencontreArgs<ExtArgs>
  }, ExtArgs["result"]["files"]>

  export type FilesSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    visiteTerrainId?: boolean
    conflitId?: boolean
    rencontreId?: boolean
  }

  export type FilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "url" | "size" | "visiteTerrainId" | "conflitId" | "rencontreId", ExtArgs["result"]["files"]>
  export type FilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visiteTerrain?: boolean | Files$visiteTerrainArgs<ExtArgs>
    conflit?: boolean | Files$conflitArgs<ExtArgs>
    rencontre?: boolean | Files$rencontreArgs<ExtArgs>
    Upload?: boolean | Files$UploadArgs<ExtArgs>
    Users?: boolean | Files$UsersArgs<ExtArgs>
    accompaniments?: boolean | Files$accompanimentsArgs<ExtArgs>
    media?: boolean | Files$mediaArgs<ExtArgs>
    _count?: boolean | FilesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FilesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visiteTerrain?: boolean | Files$visiteTerrainArgs<ExtArgs>
    conflit?: boolean | Files$conflitArgs<ExtArgs>
    rencontre?: boolean | Files$rencontreArgs<ExtArgs>
  }
  export type FilesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visiteTerrain?: boolean | Files$visiteTerrainArgs<ExtArgs>
    conflit?: boolean | Files$conflitArgs<ExtArgs>
    rencontre?: boolean | Files$rencontreArgs<ExtArgs>
  }

  export type $FilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Files"
    objects: {
      visiteTerrain: Prisma.$VisiteTerrainPayload<ExtArgs> | null
      conflit: Prisma.$ConflitPayload<ExtArgs> | null
      rencontre: Prisma.$RencontrePayload<ExtArgs> | null
      Upload: Prisma.$UploadPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>[]
      accompaniments: Prisma.$AccompanimentPayload<ExtArgs>[]
      media: Prisma.$AccompanimentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      url: string
      size: number
      visiteTerrainId: string | null
      conflitId: string | null
      rencontreId: string | null
    }, ExtArgs["result"]["files"]>
    composites: {}
  }

  type FilesGetPayload<S extends boolean | null | undefined | FilesDefaultArgs> = $Result.GetResult<Prisma.$FilesPayload, S>

  type FilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilesCountAggregateInputType | true
    }

  export interface FilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Files'], meta: { name: 'Files' } }
    /**
     * Find zero or one Files that matches the filter.
     * @param {FilesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilesFindUniqueArgs>(args: SelectSubset<T, FilesFindUniqueArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Files that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilesFindUniqueOrThrowArgs>(args: SelectSubset<T, FilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilesFindFirstArgs>(args?: SelectSubset<T, FilesFindFirstArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Files that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilesFindFirstOrThrowArgs>(args?: SelectSubset<T, FilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilesFindManyArgs>(args?: SelectSubset<T, FilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Files.
     * @param {FilesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
     */
    create<T extends FilesCreateArgs>(args: SelectSubset<T, FilesCreateArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FilesCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const files = await prisma.files.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilesCreateManyArgs>(args?: SelectSubset<T, FilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FilesCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const files = await prisma.files.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const filesWithIdOnly = await prisma.files.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilesCreateManyAndReturnArgs>(args?: SelectSubset<T, FilesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Files.
     * @param {FilesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
     */
    delete<T extends FilesDeleteArgs>(args: SelectSubset<T, FilesDeleteArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Files.
     * @param {FilesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilesUpdateArgs>(args: SelectSubset<T, FilesUpdateArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FilesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilesDeleteManyArgs>(args?: SelectSubset<T, FilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilesUpdateManyArgs>(args: SelectSubset<T, FilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FilesUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const filesWithIdOnly = await prisma.files.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FilesUpdateManyAndReturnArgs>(args: SelectSubset<T, FilesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Files.
     * @param {FilesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
     */
    upsert<T extends FilesUpsertArgs>(args: SelectSubset<T, FilesUpsertArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FilesCountArgs>(
      args?: Subset<T, FilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): Prisma.PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilesGroupByArgs['orderBy'] }
        : { orderBy?: FilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Files model
   */
  readonly fields: FilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visiteTerrain<T extends Files$visiteTerrainArgs<ExtArgs> = {}>(args?: Subset<T, Files$visiteTerrainArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conflit<T extends Files$conflitArgs<ExtArgs> = {}>(args?: Subset<T, Files$conflitArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rencontre<T extends Files$rencontreArgs<ExtArgs> = {}>(args?: Subset<T, Files$rencontreArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Upload<T extends Files$UploadArgs<ExtArgs> = {}>(args?: Subset<T, Files$UploadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends Files$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Files$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accompaniments<T extends Files$accompanimentsArgs<ExtArgs> = {}>(args?: Subset<T, Files$accompanimentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends Files$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Files$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Files model
   */
  interface FilesFieldRefs {
    readonly id: FieldRef<"Files", 'String'>
    readonly name: FieldRef<"Files", 'String'>
    readonly type: FieldRef<"Files", 'String'>
    readonly url: FieldRef<"Files", 'String'>
    readonly size: FieldRef<"Files", 'Int'>
    readonly visiteTerrainId: FieldRef<"Files", 'String'>
    readonly conflitId: FieldRef<"Files", 'String'>
    readonly rencontreId: FieldRef<"Files", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Files findUnique
   */
  export type FilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where: FilesWhereUniqueInput
  }

  /**
   * Files findUniqueOrThrow
   */
  export type FilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where: FilesWhereUniqueInput
  }

  /**
   * Files findFirst
   */
  export type FilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Files findFirstOrThrow
   */
  export type FilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Files findMany
   */
  export type FilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Files create
   */
  export type FilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * The data needed to create a Files.
     */
    data: XOR<FilesCreateInput, FilesUncheckedCreateInput>
  }

  /**
   * Files createMany
   */
  export type FilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FilesCreateManyInput | FilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Files createManyAndReturn
   */
  export type FilesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FilesCreateManyInput | FilesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Files update
   */
  export type FilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * The data needed to update a Files.
     */
    data: XOR<FilesUpdateInput, FilesUncheckedUpdateInput>
    /**
     * Choose, which Files to update.
     */
    where: FilesWhereUniqueInput
  }

  /**
   * Files updateMany
   */
  export type FilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FilesWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * Files updateManyAndReturn
   */
  export type FilesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FilesWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Files upsert
   */
  export type FilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * The filter to search for the Files to update in case it exists.
     */
    where: FilesWhereUniqueInput
    /**
     * In case the Files found by the `where` argument doesn't exist, create a new Files with this data.
     */
    create: XOR<FilesCreateInput, FilesUncheckedCreateInput>
    /**
     * In case the Files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilesUpdateInput, FilesUncheckedUpdateInput>
  }

  /**
   * Files delete
   */
  export type FilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter which Files to delete.
     */
    where: FilesWhereUniqueInput
  }

  /**
   * Files deleteMany
   */
  export type FilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FilesWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * Files.visiteTerrain
   */
  export type Files$visiteTerrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    where?: VisiteTerrainWhereInput
  }

  /**
   * Files.conflit
   */
  export type Files$conflitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    where?: ConflitWhereInput
  }

  /**
   * Files.rencontre
   */
  export type Files$rencontreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    where?: RencontreWhereInput
  }

  /**
   * Files.Upload
   */
  export type Files$UploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    cursor?: UploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Files.Users
   */
  export type Files$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Files.accompaniments
   */
  export type Files$accompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    cursor?: AccompanimentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Files.media
   */
  export type Files$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    cursor?: AccompanimentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Files without action
   */
  export type FilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    authId: string | null
    profile: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    gender: string | null
    dob: Date | null
    filesId: string | null
    status: $Enums.Status | null
    type: $Enums.Type | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    profile: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    gender: string | null
    dob: Date | null
    filesId: string | null
    status: $Enums.Status | null
    type: $Enums.Type | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    authId: number
    profile: number
    name: number
    email: number
    phone: number
    address: number
    gender: number
    dob: number
    filesId: number
    status: number
    type: number
    routes: number
    access: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    authId?: true
    profile?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    gender?: true
    dob?: true
    filesId?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    authId?: true
    profile?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    gender?: true
    dob?: true
    filesId?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    authId?: true
    profile?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    gender?: true
    dob?: true
    filesId?: true
    status?: true
    type?: true
    routes?: true
    access?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date
    filesId: string | null
    status: $Enums.Status
    type: $Enums.Type
    routes: string[]
    access: string[]
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    profile?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gender?: boolean
    dob?: boolean
    filesId?: boolean
    status?: boolean
    type?: boolean
    routes?: boolean
    access?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cv?: boolean | Users$cvArgs<ExtArgs>
    accompaniments?: boolean | Users$accompanimentsArgs<ExtArgs>
    plannings?: boolean | Users$planningsArgs<ExtArgs>
    emargements?: boolean | Users$emargementsArgs<ExtArgs>
    visiteTerrains?: boolean | Users$visiteTerrainsArgs<ExtArgs>
    rencontres?: boolean | Users$rencontresArgs<ExtArgs>
    conflit?: boolean | Users$conflitArgs<ExtArgs>
    chatParticipant?: boolean | Users$chatParticipantArgs<ExtArgs>
    message?: boolean | Users$messageArgs<ExtArgs>
    uploads?: boolean | Users$uploadsArgs<ExtArgs>
    messageView?: boolean | Users$messageViewArgs<ExtArgs>
    Classe?: boolean | Users$ClasseArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    profile?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gender?: boolean
    dob?: boolean
    filesId?: boolean
    status?: boolean
    type?: boolean
    routes?: boolean
    access?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cv?: boolean | Users$cvArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    profile?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gender?: boolean
    dob?: boolean
    filesId?: boolean
    status?: boolean
    type?: boolean
    routes?: boolean
    access?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cv?: boolean | Users$cvArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    authId?: boolean
    profile?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    gender?: boolean
    dob?: boolean
    filesId?: boolean
    status?: boolean
    type?: boolean
    routes?: boolean
    access?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "profile" | "name" | "email" | "phone" | "address" | "gender" | "dob" | "filesId" | "status" | "type" | "routes" | "access" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cv?: boolean | Users$cvArgs<ExtArgs>
    accompaniments?: boolean | Users$accompanimentsArgs<ExtArgs>
    plannings?: boolean | Users$planningsArgs<ExtArgs>
    emargements?: boolean | Users$emargementsArgs<ExtArgs>
    visiteTerrains?: boolean | Users$visiteTerrainsArgs<ExtArgs>
    rencontres?: boolean | Users$rencontresArgs<ExtArgs>
    conflit?: boolean | Users$conflitArgs<ExtArgs>
    chatParticipant?: boolean | Users$chatParticipantArgs<ExtArgs>
    message?: boolean | Users$messageArgs<ExtArgs>
    uploads?: boolean | Users$uploadsArgs<ExtArgs>
    messageView?: boolean | Users$messageViewArgs<ExtArgs>
    Classe?: boolean | Users$ClasseArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cv?: boolean | Users$cvArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cv?: boolean | Users$cvArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      cv: Prisma.$FilesPayload<ExtArgs> | null
      accompaniments: Prisma.$AccompanimentPayload<ExtArgs>[]
      plannings: Prisma.$PlanningPayload<ExtArgs>[]
      emargements: Prisma.$EmargementPayload<ExtArgs>[]
      visiteTerrains: Prisma.$VisiteTerrainPayload<ExtArgs>[]
      rencontres: Prisma.$RencontrePayload<ExtArgs>[]
      conflit: Prisma.$ConflitPayload<ExtArgs>[]
      chatParticipant: Prisma.$ChatParticipantPayload<ExtArgs>[]
      message: Prisma.$MessagePayload<ExtArgs>[]
      uploads: Prisma.$UploadPayload<ExtArgs>[]
      messageView: Prisma.$MessageViewPayload<ExtArgs>[]
      Classe: Prisma.$ClassePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      profile: string
      name: string
      email: string
      phone: string
      address: string
      gender: string
      dob: Date
      filesId: string | null
      status: $Enums.Status
      type: $Enums.Type
      routes: string[]
      access: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cv<T extends Users$cvArgs<ExtArgs> = {}>(args?: Subset<T, Users$cvArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accompaniments<T extends Users$accompanimentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$accompanimentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plannings<T extends Users$planningsArgs<ExtArgs> = {}>(args?: Subset<T, Users$planningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emargements<T extends Users$emargementsArgs<ExtArgs> = {}>(args?: Subset<T, Users$emargementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visiteTerrains<T extends Users$visiteTerrainsArgs<ExtArgs> = {}>(args?: Subset<T, Users$visiteTerrainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rencontres<T extends Users$rencontresArgs<ExtArgs> = {}>(args?: Subset<T, Users$rencontresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conflit<T extends Users$conflitArgs<ExtArgs> = {}>(args?: Subset<T, Users$conflitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatParticipant<T extends Users$chatParticipantArgs<ExtArgs> = {}>(args?: Subset<T, Users$chatParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message<T extends Users$messageArgs<ExtArgs> = {}>(args?: Subset<T, Users$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploads<T extends Users$uploadsArgs<ExtArgs> = {}>(args?: Subset<T, Users$uploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messageView<T extends Users$messageViewArgs<ExtArgs> = {}>(args?: Subset<T, Users$messageViewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Classe<T extends Users$ClasseArgs<ExtArgs> = {}>(args?: Subset<T, Users$ClasseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly authId: FieldRef<"Users", 'String'>
    readonly profile: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly phone: FieldRef<"Users", 'String'>
    readonly address: FieldRef<"Users", 'String'>
    readonly gender: FieldRef<"Users", 'String'>
    readonly dob: FieldRef<"Users", 'DateTime'>
    readonly filesId: FieldRef<"Users", 'String'>
    readonly status: FieldRef<"Users", 'Status'>
    readonly type: FieldRef<"Users", 'Type'>
    readonly routes: FieldRef<"Users", 'String[]'>
    readonly access: FieldRef<"Users", 'String[]'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.cv
   */
  export type Users$cvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    where?: FilesWhereInput
  }

  /**
   * Users.accompaniments
   */
  export type Users$accompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    cursor?: AccompanimentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Users.plannings
   */
  export type Users$planningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    cursor?: PlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Users.emargements
   */
  export type Users$emargementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    where?: EmargementWhereInput
    orderBy?: EmargementOrderByWithRelationInput | EmargementOrderByWithRelationInput[]
    cursor?: EmargementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmargementScalarFieldEnum | EmargementScalarFieldEnum[]
  }

  /**
   * Users.visiteTerrains
   */
  export type Users$visiteTerrainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    where?: VisiteTerrainWhereInput
    orderBy?: VisiteTerrainOrderByWithRelationInput | VisiteTerrainOrderByWithRelationInput[]
    cursor?: VisiteTerrainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisiteTerrainScalarFieldEnum | VisiteTerrainScalarFieldEnum[]
  }

  /**
   * Users.rencontres
   */
  export type Users$rencontresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    where?: RencontreWhereInput
    orderBy?: RencontreOrderByWithRelationInput | RencontreOrderByWithRelationInput[]
    cursor?: RencontreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RencontreScalarFieldEnum | RencontreScalarFieldEnum[]
  }

  /**
   * Users.conflit
   */
  export type Users$conflitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    where?: ConflitWhereInput
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    cursor?: ConflitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Users.chatParticipant
   */
  export type Users$chatParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    where?: ChatParticipantWhereInput
    orderBy?: ChatParticipantOrderByWithRelationInput | ChatParticipantOrderByWithRelationInput[]
    cursor?: ChatParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatParticipantScalarFieldEnum | ChatParticipantScalarFieldEnum[]
  }

  /**
   * Users.message
   */
  export type Users$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Users.uploads
   */
  export type Users$uploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    cursor?: UploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Users.messageView
   */
  export type Users$messageViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    where?: MessageViewWhereInput
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    cursor?: MessageViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * Users.Classe
   */
  export type Users$ClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    cursor?: ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    local: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: boolean | null
    local: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    status: number
    local: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    local?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    local?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    local?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    status: boolean
    local: string
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    local?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompaniments?: boolean | Project$accompanimentsArgs<ExtArgs>
    leave?: boolean | Project$leaveArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    classes?: boolean | Project$classesArgs<ExtArgs>
    chat?: boolean | Project$chatArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    local?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    local?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    local?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "local" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniments?: boolean | Project$accompanimentsArgs<ExtArgs>
    leave?: boolean | Project$leaveArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    classes?: boolean | Project$classesArgs<ExtArgs>
    chat?: boolean | Project$chatArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      accompaniments: Prisma.$AccompanimentPayload<ExtArgs>[]
      leave: Prisma.$LeavePayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      classes: Prisma.$ClassePayload<ExtArgs>[]
      chat: Prisma.$ChatPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: boolean
      local: string
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accompaniments<T extends Project$accompanimentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$accompanimentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leave<T extends Project$leaveArgs<ExtArgs> = {}>(args?: Subset<T, Project$leaveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Project$classesArgs<ExtArgs> = {}>(args?: Subset<T, Project$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat<T extends Project$chatArgs<ExtArgs> = {}>(args?: Subset<T, Project$chatArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'Boolean'>
    readonly local: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.accompaniments
   */
  export type Project$accompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    cursor?: AccompanimentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Project.leave
   */
  export type Project$leaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Project.classes
   */
  export type Project$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    cursor?: ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Project.chat
   */
  export type Project$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveMinAggregateOutputType = {
    id: string | null
    date: Date | null
    reason: string | null
    projectId: string | null
    memberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    reason: string | null
    projectId: string | null
    memberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    date: number
    reason: number
    projectId: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveMinAggregateInputType = {
    id?: true
    date?: true
    reason?: true
    projectId?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    date?: true
    reason?: true
    projectId?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    date?: true
    reason?: true
    projectId?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: string
    date: Date
    reason: string
    projectId: string
    memberId: string
    createdAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    reason?: boolean
    projectId?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    reason?: boolean
    projectId?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    reason?: boolean
    projectId?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    date?: boolean
    reason?: boolean
    projectId?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "reason" | "projectId" | "memberId" | "createdAt" | "updatedAt", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      reason: string
      projectId: string
      memberId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaves and returns the data saved in the database.
     * @param {LeaveCreateManyAndReturnArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves and returns the data updated in the database.
     * @param {LeaveUpdateManyAndReturnArgs} args - Arguments to update many Leaves.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'String'>
    readonly date: FieldRef<"Leave", 'DateTime'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly projectId: FieldRef<"Leave", 'String'>
    readonly memberId: FieldRef<"Leave", 'String'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave createManyAndReturn
   */
  export type LeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave updateManyAndReturn
   */
  export type LeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model Accompaniment
   */

  export type AggregateAccompaniment = {
    _count: AccompanimentCountAggregateOutputType | null
    _avg: AccompanimentAvgAggregateOutputType | null
    _sum: AccompanimentSumAggregateOutputType | null
    _min: AccompanimentMinAggregateOutputType | null
    _max: AccompanimentMaxAggregateOutputType | null
  }

  export type AccompanimentAvgAggregateOutputType = {
    phones: number | null
    budget: number | null
  }

  export type AccompanimentSumAggregateOutputType = {
    phones: number[]
    budget: number | null
  }

  export type AccompanimentMinAggregateOutputType = {
    id: string | null
    name: string | null
    adresse: string | null
    budget: number | null
    status: boolean | null
    usersid: string | null
    fileId: string | null
    projectId: string | null
    planningId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccompanimentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    adresse: string | null
    budget: number | null
    status: boolean | null
    usersid: string | null
    fileId: string | null
    projectId: string | null
    planningId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccompanimentCountAggregateOutputType = {
    id: number
    name: number
    adresse: number
    phones: number
    budget: number
    status: number
    usersid: number
    fileId: number
    projectId: number
    planningId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccompanimentAvgAggregateInputType = {
    phones?: true
    budget?: true
  }

  export type AccompanimentSumAggregateInputType = {
    phones?: true
    budget?: true
  }

  export type AccompanimentMinAggregateInputType = {
    id?: true
    name?: true
    adresse?: true
    budget?: true
    status?: true
    usersid?: true
    fileId?: true
    projectId?: true
    planningId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccompanimentMaxAggregateInputType = {
    id?: true
    name?: true
    adresse?: true
    budget?: true
    status?: true
    usersid?: true
    fileId?: true
    projectId?: true
    planningId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccompanimentCountAggregateInputType = {
    id?: true
    name?: true
    adresse?: true
    phones?: true
    budget?: true
    status?: true
    usersid?: true
    fileId?: true
    projectId?: true
    planningId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccompanimentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accompaniment to aggregate.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accompaniments
    **/
    _count?: true | AccompanimentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccompanimentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccompanimentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccompanimentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccompanimentMaxAggregateInputType
  }

  export type GetAccompanimentAggregateType<T extends AccompanimentAggregateArgs> = {
        [P in keyof T & keyof AggregateAccompaniment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccompaniment[P]>
      : GetScalarType<T[P], AggregateAccompaniment[P]>
  }




  export type AccompanimentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithAggregationInput | AccompanimentOrderByWithAggregationInput[]
    by: AccompanimentScalarFieldEnum[] | AccompanimentScalarFieldEnum
    having?: AccompanimentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccompanimentCountAggregateInputType | true
    _avg?: AccompanimentAvgAggregateInputType
    _sum?: AccompanimentSumAggregateInputType
    _min?: AccompanimentMinAggregateInputType
    _max?: AccompanimentMaxAggregateInputType
  }

  export type AccompanimentGroupByOutputType = {
    id: string
    name: string
    adresse: string
    phones: number[]
    budget: number
    status: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccompanimentCountAggregateOutputType | null
    _avg: AccompanimentAvgAggregateOutputType | null
    _sum: AccompanimentSumAggregateOutputType | null
    _min: AccompanimentMinAggregateOutputType | null
    _max: AccompanimentMaxAggregateOutputType | null
  }

  type GetAccompanimentGroupByPayload<T extends AccompanimentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccompanimentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccompanimentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccompanimentGroupByOutputType[P]>
            : GetScalarType<T[P], AccompanimentGroupByOutputType[P]>
        }
      >
    >


  export type AccompanimentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    adresse?: boolean
    phones?: boolean
    budget?: boolean
    status?: boolean
    usersid?: boolean
    fileId?: boolean
    projectId?: boolean
    planningId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    map?: boolean | Accompaniment$mapArgs<ExtArgs>
    members?: boolean | Accompaniment$membersArgs<ExtArgs>
    file?: boolean | FilesDefaultArgs<ExtArgs>
    media?: boolean | Accompaniment$mediaArgs<ExtArgs>
    purchases?: boolean | Accompaniment$purchasesArgs<ExtArgs>
    conflits?: boolean | Accompaniment$conflitsArgs<ExtArgs>
    rencontre?: boolean | Accompaniment$rencontreArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planning?: boolean | Accompaniment$planningArgs<ExtArgs>
    _count?: boolean | AccompanimentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accompaniment"]>

  export type AccompanimentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    adresse?: boolean
    phones?: boolean
    budget?: boolean
    status?: boolean
    usersid?: boolean
    fileId?: boolean
    projectId?: boolean
    planningId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    file?: boolean | FilesDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planning?: boolean | Accompaniment$planningArgs<ExtArgs>
  }, ExtArgs["result"]["accompaniment"]>

  export type AccompanimentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    adresse?: boolean
    phones?: boolean
    budget?: boolean
    status?: boolean
    usersid?: boolean
    fileId?: boolean
    projectId?: boolean
    planningId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    file?: boolean | FilesDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planning?: boolean | Accompaniment$planningArgs<ExtArgs>
  }, ExtArgs["result"]["accompaniment"]>

  export type AccompanimentSelectScalar = {
    id?: boolean
    name?: boolean
    adresse?: boolean
    phones?: boolean
    budget?: boolean
    status?: boolean
    usersid?: boolean
    fileId?: boolean
    projectId?: boolean
    planningId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccompanimentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "adresse" | "phones" | "budget" | "status" | "usersid" | "fileId" | "projectId" | "planningId" | "createdAt" | "updatedAt", ExtArgs["result"]["accompaniment"]>
  export type AccompanimentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    map?: boolean | Accompaniment$mapArgs<ExtArgs>
    members?: boolean | Accompaniment$membersArgs<ExtArgs>
    file?: boolean | FilesDefaultArgs<ExtArgs>
    media?: boolean | Accompaniment$mediaArgs<ExtArgs>
    purchases?: boolean | Accompaniment$purchasesArgs<ExtArgs>
    conflits?: boolean | Accompaniment$conflitsArgs<ExtArgs>
    rencontre?: boolean | Accompaniment$rencontreArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planning?: boolean | Accompaniment$planningArgs<ExtArgs>
    _count?: boolean | AccompanimentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccompanimentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    file?: boolean | FilesDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planning?: boolean | Accompaniment$planningArgs<ExtArgs>
  }
  export type AccompanimentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    file?: boolean | FilesDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    planning?: boolean | Accompaniment$planningArgs<ExtArgs>
  }

  export type $AccompanimentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Accompaniment"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      map: Prisma.$MapsPayload<ExtArgs> | null
      members: Prisma.$MemberPayload<ExtArgs>[]
      file: Prisma.$FilesPayload<ExtArgs>
      media: Prisma.$FilesPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      conflits: Prisma.$ConflitPayload<ExtArgs>[]
      rencontre: Prisma.$RencontrePayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
      planning: Prisma.$PlanningPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      adresse: string
      phones: number[]
      budget: number
      status: boolean
      usersid: string
      fileId: string
      projectId: string
      planningId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accompaniment"]>
    composites: {}
  }

  type AccompanimentGetPayload<S extends boolean | null | undefined | AccompanimentDefaultArgs> = $Result.GetResult<Prisma.$AccompanimentPayload, S>

  type AccompanimentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccompanimentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccompanimentCountAggregateInputType | true
    }

  export interface AccompanimentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accompaniment'], meta: { name: 'Accompaniment' } }
    /**
     * Find zero or one Accompaniment that matches the filter.
     * @param {AccompanimentFindUniqueArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccompanimentFindUniqueArgs>(args: SelectSubset<T, AccompanimentFindUniqueArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accompaniment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccompanimentFindUniqueOrThrowArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccompanimentFindUniqueOrThrowArgs>(args: SelectSubset<T, AccompanimentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accompaniment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentFindFirstArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccompanimentFindFirstArgs>(args?: SelectSubset<T, AccompanimentFindFirstArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accompaniment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentFindFirstOrThrowArgs} args - Arguments to find a Accompaniment
     * @example
     * // Get one Accompaniment
     * const accompaniment = await prisma.accompaniment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccompanimentFindFirstOrThrowArgs>(args?: SelectSubset<T, AccompanimentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accompaniments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accompaniments
     * const accompaniments = await prisma.accompaniment.findMany()
     * 
     * // Get first 10 Accompaniments
     * const accompaniments = await prisma.accompaniment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accompanimentWithIdOnly = await prisma.accompaniment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccompanimentFindManyArgs>(args?: SelectSubset<T, AccompanimentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accompaniment.
     * @param {AccompanimentCreateArgs} args - Arguments to create a Accompaniment.
     * @example
     * // Create one Accompaniment
     * const Accompaniment = await prisma.accompaniment.create({
     *   data: {
     *     // ... data to create a Accompaniment
     *   }
     * })
     * 
     */
    create<T extends AccompanimentCreateArgs>(args: SelectSubset<T, AccompanimentCreateArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accompaniments.
     * @param {AccompanimentCreateManyArgs} args - Arguments to create many Accompaniments.
     * @example
     * // Create many Accompaniments
     * const accompaniment = await prisma.accompaniment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccompanimentCreateManyArgs>(args?: SelectSubset<T, AccompanimentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accompaniments and returns the data saved in the database.
     * @param {AccompanimentCreateManyAndReturnArgs} args - Arguments to create many Accompaniments.
     * @example
     * // Create many Accompaniments
     * const accompaniment = await prisma.accompaniment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accompaniments and only return the `id`
     * const accompanimentWithIdOnly = await prisma.accompaniment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccompanimentCreateManyAndReturnArgs>(args?: SelectSubset<T, AccompanimentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Accompaniment.
     * @param {AccompanimentDeleteArgs} args - Arguments to delete one Accompaniment.
     * @example
     * // Delete one Accompaniment
     * const Accompaniment = await prisma.accompaniment.delete({
     *   where: {
     *     // ... filter to delete one Accompaniment
     *   }
     * })
     * 
     */
    delete<T extends AccompanimentDeleteArgs>(args: SelectSubset<T, AccompanimentDeleteArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accompaniment.
     * @param {AccompanimentUpdateArgs} args - Arguments to update one Accompaniment.
     * @example
     * // Update one Accompaniment
     * const accompaniment = await prisma.accompaniment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccompanimentUpdateArgs>(args: SelectSubset<T, AccompanimentUpdateArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accompaniments.
     * @param {AccompanimentDeleteManyArgs} args - Arguments to filter Accompaniments to delete.
     * @example
     * // Delete a few Accompaniments
     * const { count } = await prisma.accompaniment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccompanimentDeleteManyArgs>(args?: SelectSubset<T, AccompanimentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accompaniments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accompaniments
     * const accompaniment = await prisma.accompaniment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccompanimentUpdateManyArgs>(args: SelectSubset<T, AccompanimentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accompaniments and returns the data updated in the database.
     * @param {AccompanimentUpdateManyAndReturnArgs} args - Arguments to update many Accompaniments.
     * @example
     * // Update many Accompaniments
     * const accompaniment = await prisma.accompaniment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accompaniments and only return the `id`
     * const accompanimentWithIdOnly = await prisma.accompaniment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccompanimentUpdateManyAndReturnArgs>(args: SelectSubset<T, AccompanimentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Accompaniment.
     * @param {AccompanimentUpsertArgs} args - Arguments to update or create a Accompaniment.
     * @example
     * // Update or create a Accompaniment
     * const accompaniment = await prisma.accompaniment.upsert({
     *   create: {
     *     // ... data to create a Accompaniment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accompaniment we want to update
     *   }
     * })
     */
    upsert<T extends AccompanimentUpsertArgs>(args: SelectSubset<T, AccompanimentUpsertArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accompaniments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentCountArgs} args - Arguments to filter Accompaniments to count.
     * @example
     * // Count the number of Accompaniments
     * const count = await prisma.accompaniment.count({
     *   where: {
     *     // ... the filter for the Accompaniments we want to count
     *   }
     * })
    **/
    count<T extends AccompanimentCountArgs>(
      args?: Subset<T, AccompanimentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccompanimentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accompaniment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccompanimentAggregateArgs>(args: Subset<T, AccompanimentAggregateArgs>): Prisma.PrismaPromise<GetAccompanimentAggregateType<T>>

    /**
     * Group by Accompaniment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccompanimentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccompanimentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccompanimentGroupByArgs['orderBy'] }
        : { orderBy?: AccompanimentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccompanimentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccompanimentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accompaniment model
   */
  readonly fields: AccompanimentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accompaniment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccompanimentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    map<T extends Accompaniment$mapArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$mapArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Accompaniment$membersArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    file<T extends FilesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilesDefaultArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends Accompaniment$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends Accompaniment$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conflits<T extends Accompaniment$conflitsArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$conflitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rencontre<T extends Accompaniment$rencontreArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$rencontreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    planning<T extends Accompaniment$planningArgs<ExtArgs> = {}>(args?: Subset<T, Accompaniment$planningArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Accompaniment model
   */
  interface AccompanimentFieldRefs {
    readonly id: FieldRef<"Accompaniment", 'String'>
    readonly name: FieldRef<"Accompaniment", 'String'>
    readonly adresse: FieldRef<"Accompaniment", 'String'>
    readonly phones: FieldRef<"Accompaniment", 'Int[]'>
    readonly budget: FieldRef<"Accompaniment", 'Int'>
    readonly status: FieldRef<"Accompaniment", 'Boolean'>
    readonly usersid: FieldRef<"Accompaniment", 'String'>
    readonly fileId: FieldRef<"Accompaniment", 'String'>
    readonly projectId: FieldRef<"Accompaniment", 'String'>
    readonly planningId: FieldRef<"Accompaniment", 'String'>
    readonly createdAt: FieldRef<"Accompaniment", 'DateTime'>
    readonly updatedAt: FieldRef<"Accompaniment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Accompaniment findUnique
   */
  export type AccompanimentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where: AccompanimentWhereUniqueInput
  }

  /**
   * Accompaniment findUniqueOrThrow
   */
  export type AccompanimentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where: AccompanimentWhereUniqueInput
  }

  /**
   * Accompaniment findFirst
   */
  export type AccompanimentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accompaniments.
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accompaniments.
     */
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Accompaniment findFirstOrThrow
   */
  export type AccompanimentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniment to fetch.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accompaniments.
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accompaniments.
     */
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Accompaniment findMany
   */
  export type AccompanimentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter, which Accompaniments to fetch.
     */
    where?: AccompanimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accompaniments to fetch.
     */
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accompaniments.
     */
    cursor?: AccompanimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accompaniments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accompaniments.
     */
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Accompaniment create
   */
  export type AccompanimentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * The data needed to create a Accompaniment.
     */
    data: XOR<AccompanimentCreateInput, AccompanimentUncheckedCreateInput>
  }

  /**
   * Accompaniment createMany
   */
  export type AccompanimentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accompaniments.
     */
    data: AccompanimentCreateManyInput | AccompanimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Accompaniment createManyAndReturn
   */
  export type AccompanimentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * The data used to create many Accompaniments.
     */
    data: AccompanimentCreateManyInput | AccompanimentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Accompaniment update
   */
  export type AccompanimentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * The data needed to update a Accompaniment.
     */
    data: XOR<AccompanimentUpdateInput, AccompanimentUncheckedUpdateInput>
    /**
     * Choose, which Accompaniment to update.
     */
    where: AccompanimentWhereUniqueInput
  }

  /**
   * Accompaniment updateMany
   */
  export type AccompanimentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accompaniments.
     */
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyInput>
    /**
     * Filter which Accompaniments to update
     */
    where?: AccompanimentWhereInput
    /**
     * Limit how many Accompaniments to update.
     */
    limit?: number
  }

  /**
   * Accompaniment updateManyAndReturn
   */
  export type AccompanimentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * The data used to update Accompaniments.
     */
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyInput>
    /**
     * Filter which Accompaniments to update
     */
    where?: AccompanimentWhereInput
    /**
     * Limit how many Accompaniments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Accompaniment upsert
   */
  export type AccompanimentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * The filter to search for the Accompaniment to update in case it exists.
     */
    where: AccompanimentWhereUniqueInput
    /**
     * In case the Accompaniment found by the `where` argument doesn't exist, create a new Accompaniment with this data.
     */
    create: XOR<AccompanimentCreateInput, AccompanimentUncheckedCreateInput>
    /**
     * In case the Accompaniment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccompanimentUpdateInput, AccompanimentUncheckedUpdateInput>
  }

  /**
   * Accompaniment delete
   */
  export type AccompanimentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    /**
     * Filter which Accompaniment to delete.
     */
    where: AccompanimentWhereUniqueInput
  }

  /**
   * Accompaniment deleteMany
   */
  export type AccompanimentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accompaniments to delete
     */
    where?: AccompanimentWhereInput
    /**
     * Limit how many Accompaniments to delete.
     */
    limit?: number
  }

  /**
   * Accompaniment.map
   */
  export type Accompaniment$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    where?: MapsWhereInput
  }

  /**
   * Accompaniment.members
   */
  export type Accompaniment$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Accompaniment.media
   */
  export type Accompaniment$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    cursor?: FilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Accompaniment.purchases
   */
  export type Accompaniment$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Accompaniment.conflits
   */
  export type Accompaniment$conflitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    where?: ConflitWhereInput
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    cursor?: ConflitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Accompaniment.rencontre
   */
  export type Accompaniment$rencontreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    where?: RencontreWhereInput
    orderBy?: RencontreOrderByWithRelationInput | RencontreOrderByWithRelationInput[]
    cursor?: RencontreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RencontreScalarFieldEnum | RencontreScalarFieldEnum[]
  }

  /**
   * Accompaniment.planning
   */
  export type Accompaniment$planningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
  }

  /**
   * Accompaniment without action
   */
  export type AccompanimentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
  }


  /**
   * Model Classe
   */

  export type AggregateClasse = {
    _count: ClasseCountAggregateOutputType | null
    _min: ClasseMinAggregateOutputType | null
    _max: ClasseMaxAggregateOutputType | null
  }

  export type ClasseMinAggregateOutputType = {
    id: string | null
    name: string | null
    usersId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClasseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    usersId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClasseCountAggregateOutputType = {
    id: number
    name: number
    usersId: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClasseMinAggregateInputType = {
    id?: true
    name?: true
    usersId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClasseMaxAggregateInputType = {
    id?: true
    name?: true
    usersId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClasseCountAggregateInputType = {
    id?: true
    name?: true
    usersId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classe to aggregate.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClasseMaxAggregateInputType
  }

  export type GetClasseAggregateType<T extends ClasseAggregateArgs> = {
        [P in keyof T & keyof AggregateClasse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasse[P]>
      : GetScalarType<T[P], AggregateClasse[P]>
  }




  export type ClasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithAggregationInput | ClasseOrderByWithAggregationInput[]
    by: ClasseScalarFieldEnum[] | ClasseScalarFieldEnum
    having?: ClasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClasseCountAggregateInputType | true
    _min?: ClasseMinAggregateInputType
    _max?: ClasseMaxAggregateInputType
  }

  export type ClasseGroupByOutputType = {
    id: string
    name: string
    usersId: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: ClasseCountAggregateOutputType | null
    _min: ClasseMinAggregateOutputType | null
    _max: ClasseMaxAggregateOutputType | null
  }

  type GetClasseGroupByPayload<T extends ClasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClasseGroupByOutputType[P]>
            : GetScalarType<T[P], ClasseGroupByOutputType[P]>
        }
      >
    >


  export type ClasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    usersId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    members?: boolean | Classe$membersArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | ClasseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classe"]>

  export type ClasseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    usersId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classe"]>

  export type ClasseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    usersId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classe"]>

  export type ClasseSelectScalar = {
    id?: boolean
    name?: boolean
    usersId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClasseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "usersId" | "projectId" | "createdAt" | "updatedAt", ExtArgs["result"]["classe"]>
  export type ClasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    members?: boolean | Classe$membersArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | ClasseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClasseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ClasseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ClassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classe"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      members: Prisma.$MemberPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      usersId: string
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classe"]>
    composites: {}
  }

  type ClasseGetPayload<S extends boolean | null | undefined | ClasseDefaultArgs> = $Result.GetResult<Prisma.$ClassePayload, S>

  type ClasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClasseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClasseCountAggregateInputType | true
    }

  export interface ClasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classe'], meta: { name: 'Classe' } }
    /**
     * Find zero or one Classe that matches the filter.
     * @param {ClasseFindUniqueArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClasseFindUniqueArgs>(args: SelectSubset<T, ClasseFindUniqueArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClasseFindUniqueOrThrowArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClasseFindUniqueOrThrowArgs>(args: SelectSubset<T, ClasseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindFirstArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClasseFindFirstArgs>(args?: SelectSubset<T, ClasseFindFirstArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindFirstOrThrowArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClasseFindFirstOrThrowArgs>(args?: SelectSubset<T, ClasseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classe.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classeWithIdOnly = await prisma.classe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClasseFindManyArgs>(args?: SelectSubset<T, ClasseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classe.
     * @param {ClasseCreateArgs} args - Arguments to create a Classe.
     * @example
     * // Create one Classe
     * const Classe = await prisma.classe.create({
     *   data: {
     *     // ... data to create a Classe
     *   }
     * })
     * 
     */
    create<T extends ClasseCreateArgs>(args: SelectSubset<T, ClasseCreateArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClasseCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classe = await prisma.classe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClasseCreateManyArgs>(args?: SelectSubset<T, ClasseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClasseCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classe = await prisma.classe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classeWithIdOnly = await prisma.classe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClasseCreateManyAndReturnArgs>(args?: SelectSubset<T, ClasseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classe.
     * @param {ClasseDeleteArgs} args - Arguments to delete one Classe.
     * @example
     * // Delete one Classe
     * const Classe = await prisma.classe.delete({
     *   where: {
     *     // ... filter to delete one Classe
     *   }
     * })
     * 
     */
    delete<T extends ClasseDeleteArgs>(args: SelectSubset<T, ClasseDeleteArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classe.
     * @param {ClasseUpdateArgs} args - Arguments to update one Classe.
     * @example
     * // Update one Classe
     * const classe = await prisma.classe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClasseUpdateArgs>(args: SelectSubset<T, ClasseUpdateArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClasseDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClasseDeleteManyArgs>(args?: SelectSubset<T, ClasseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classe = await prisma.classe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClasseUpdateManyArgs>(args: SelectSubset<T, ClasseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClasseUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const classe = await prisma.classe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classeWithIdOnly = await prisma.classe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClasseUpdateManyAndReturnArgs>(args: SelectSubset<T, ClasseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classe.
     * @param {ClasseUpsertArgs} args - Arguments to update or create a Classe.
     * @example
     * // Update or create a Classe
     * const classe = await prisma.classe.upsert({
     *   create: {
     *     // ... data to create a Classe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classe we want to update
     *   }
     * })
     */
    upsert<T extends ClasseUpsertArgs>(args: SelectSubset<T, ClasseUpsertArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classe.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClasseCountArgs>(
      args?: Subset<T, ClasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClasseAggregateArgs>(args: Subset<T, ClasseAggregateArgs>): Prisma.PrismaPromise<GetClasseAggregateType<T>>

    /**
     * Group by Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClasseGroupByArgs['orderBy'] }
        : { orderBy?: ClasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classe model
   */
  readonly fields: ClasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Classe$membersArgs<ExtArgs> = {}>(args?: Subset<T, Classe$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classe model
   */
  interface ClasseFieldRefs {
    readonly id: FieldRef<"Classe", 'String'>
    readonly name: FieldRef<"Classe", 'String'>
    readonly usersId: FieldRef<"Classe", 'String'>
    readonly projectId: FieldRef<"Classe", 'String'>
    readonly createdAt: FieldRef<"Classe", 'DateTime'>
    readonly updatedAt: FieldRef<"Classe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Classe findUnique
   */
  export type ClasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe findUniqueOrThrow
   */
  export type ClasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe findFirst
   */
  export type ClasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Classe findFirstOrThrow
   */
  export type ClasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Classe findMany
   */
  export type ClasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Classe create
   */
  export type ClasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The data needed to create a Classe.
     */
    data: XOR<ClasseCreateInput, ClasseUncheckedCreateInput>
  }

  /**
   * Classe createMany
   */
  export type ClasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClasseCreateManyInput | ClasseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Classe createManyAndReturn
   */
  export type ClasseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClasseCreateManyInput | ClasseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classe update
   */
  export type ClasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The data needed to update a Classe.
     */
    data: XOR<ClasseUpdateInput, ClasseUncheckedUpdateInput>
    /**
     * Choose, which Classe to update.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe updateMany
   */
  export type ClasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClasseWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Classe updateManyAndReturn
   */
  export type ClasseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClasseWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classe upsert
   */
  export type ClasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The filter to search for the Classe to update in case it exists.
     */
    where: ClasseWhereUniqueInput
    /**
     * In case the Classe found by the `where` argument doesn't exist, create a new Classe with this data.
     */
    create: XOR<ClasseCreateInput, ClasseUncheckedCreateInput>
    /**
     * In case the Classe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClasseUpdateInput, ClasseUncheckedUpdateInput>
  }

  /**
   * Classe delete
   */
  export type ClasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter which Classe to delete.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe deleteMany
   */
  export type ClasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClasseWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Classe.members
   */
  export type Classe$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Classe without action
   */
  export type ClasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classe
     */
    omit?: ClasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    profile: string | null
    name: string | null
    phone: string | null
    gender: string | null
    dob: Date | null
    commune: string | null
    residential: string | null
    disability: string | null
    language: string | null
    attestation: string | null
    accompanimentId: string | null
    classeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    profile: string | null
    name: string | null
    phone: string | null
    gender: string | null
    dob: Date | null
    commune: string | null
    residential: string | null
    disability: string | null
    language: string | null
    attestation: string | null
    accompanimentId: string | null
    classeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    projectId: number
    profile: number
    name: number
    phone: number
    gender: number
    dob: number
    commune: number
    residential: number
    disability: number
    language: number
    attestation: number
    accompanimentId: number
    classeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    projectId?: true
    profile?: true
    name?: true
    phone?: true
    gender?: true
    dob?: true
    commune?: true
    residential?: true
    disability?: true
    language?: true
    attestation?: true
    accompanimentId?: true
    classeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    profile?: true
    name?: true
    phone?: true
    gender?: true
    dob?: true
    commune?: true
    residential?: true
    disability?: true
    language?: true
    attestation?: true
    accompanimentId?: true
    classeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    projectId?: true
    profile?: true
    name?: true
    phone?: true
    gender?: true
    dob?: true
    commune?: true
    residential?: true
    disability?: true
    language?: true
    attestation?: true
    accompanimentId?: true
    classeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId: string | null
    classeId: string
    createdAt: Date
    updatedAt: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    profile?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dob?: boolean
    commune?: boolean
    residential?: boolean
    disability?: boolean
    language?: boolean
    attestation?: boolean
    accompanimentId?: boolean
    classeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    signatures?: boolean | Member$signaturesArgs<ExtArgs>
    emargements?: boolean | Member$emargementsArgs<ExtArgs>
    leave?: boolean | Member$leaveArgs<ExtArgs>
    accompaniment?: boolean | Member$accompanimentArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    profile?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dob?: boolean
    commune?: boolean
    residential?: boolean
    disability?: boolean
    language?: boolean
    attestation?: boolean
    accompanimentId?: boolean
    classeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    accompaniment?: boolean | Member$accompanimentArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    profile?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dob?: boolean
    commune?: boolean
    residential?: boolean
    disability?: boolean
    language?: boolean
    attestation?: boolean
    accompanimentId?: boolean
    classeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    accompaniment?: boolean | Member$accompanimentArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    profile?: boolean
    name?: boolean
    phone?: boolean
    gender?: boolean
    dob?: boolean
    commune?: boolean
    residential?: boolean
    disability?: boolean
    language?: boolean
    attestation?: boolean
    accompanimentId?: boolean
    classeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "profile" | "name" | "phone" | "gender" | "dob" | "commune" | "residential" | "disability" | "language" | "attestation" | "accompanimentId" | "classeId" | "createdAt" | "updatedAt", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    signatures?: boolean | Member$signaturesArgs<ExtArgs>
    emargements?: boolean | Member$emargementsArgs<ExtArgs>
    leave?: boolean | Member$leaveArgs<ExtArgs>
    accompaniment?: boolean | Member$accompanimentArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    accompaniment?: boolean | Member$accompanimentArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    accompaniment?: boolean | Member$accompanimentArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      signatures: Prisma.$SignaturePayload<ExtArgs>[]
      emargements: Prisma.$EmargementPayload<ExtArgs>[]
      leave: Prisma.$LeavePayload<ExtArgs> | null
      accompaniment: Prisma.$AccompanimentPayload<ExtArgs> | null
      classe: Prisma.$ClassePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      profile: string
      name: string
      phone: string
      gender: string
      dob: Date
      commune: string
      residential: string
      disability: string
      language: string
      attestation: string
      accompanimentId: string | null
      classeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signatures<T extends Member$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, Member$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emargements<T extends Member$emargementsArgs<ExtArgs> = {}>(args?: Subset<T, Member$emargementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leave<T extends Member$leaveArgs<ExtArgs> = {}>(args?: Subset<T, Member$leaveArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accompaniment<T extends Member$accompanimentArgs<ExtArgs> = {}>(args?: Subset<T, Member$accompanimentArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    classe<T extends ClasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClasseDefaultArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly projectId: FieldRef<"Member", 'String'>
    readonly profile: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly phone: FieldRef<"Member", 'String'>
    readonly gender: FieldRef<"Member", 'String'>
    readonly dob: FieldRef<"Member", 'DateTime'>
    readonly commune: FieldRef<"Member", 'String'>
    readonly residential: FieldRef<"Member", 'String'>
    readonly disability: FieldRef<"Member", 'String'>
    readonly language: FieldRef<"Member", 'String'>
    readonly attestation: FieldRef<"Member", 'String'>
    readonly accompanimentId: FieldRef<"Member", 'String'>
    readonly classeId: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.signatures
   */
  export type Member$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    cursor?: SignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Member.emargements
   */
  export type Member$emargementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    where?: EmargementWhereInput
    orderBy?: EmargementOrderByWithRelationInput | EmargementOrderByWithRelationInput[]
    cursor?: EmargementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmargementScalarFieldEnum | EmargementScalarFieldEnum[]
  }

  /**
   * Member.leave
   */
  export type Member$leaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
  }

  /**
   * Member.accompaniment
   */
  export type Member$accompanimentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    participants?: boolean | Chat$participantsArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "createdAt" | "updatedAt", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    participants?: boolean | Chat$participantsArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      participants: Prisma.$ChatParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Chat$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Chat$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly projectId: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.participants
   */
  export type Chat$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    where?: ChatParticipantWhereInput
    orderBy?: ChatParticipantOrderByWithRelationInput | ChatParticipantOrderByWithRelationInput[]
    cursor?: ChatParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatParticipantScalarFieldEnum | ChatParticipantScalarFieldEnum[]
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatParticipant
   */

  export type AggregateChatParticipant = {
    _count: ChatParticipantCountAggregateOutputType | null
    _min: ChatParticipantMinAggregateOutputType | null
    _max: ChatParticipantMaxAggregateOutputType | null
  }

  export type ChatParticipantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    chatId: string | null
    joinedAt: Date | null
  }

  export type ChatParticipantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    chatId: string | null
    joinedAt: Date | null
  }

  export type ChatParticipantCountAggregateOutputType = {
    id: number
    userId: number
    chatId: number
    joinedAt: number
    _all: number
  }


  export type ChatParticipantMinAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    joinedAt?: true
  }

  export type ChatParticipantMaxAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    joinedAt?: true
  }

  export type ChatParticipantCountAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    joinedAt?: true
    _all?: true
  }

  export type ChatParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatParticipant to aggregate.
     */
    where?: ChatParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatParticipants to fetch.
     */
    orderBy?: ChatParticipantOrderByWithRelationInput | ChatParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatParticipants
    **/
    _count?: true | ChatParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatParticipantMaxAggregateInputType
  }

  export type GetChatParticipantAggregateType<T extends ChatParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateChatParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatParticipant[P]>
      : GetScalarType<T[P], AggregateChatParticipant[P]>
  }




  export type ChatParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatParticipantWhereInput
    orderBy?: ChatParticipantOrderByWithAggregationInput | ChatParticipantOrderByWithAggregationInput[]
    by: ChatParticipantScalarFieldEnum[] | ChatParticipantScalarFieldEnum
    having?: ChatParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatParticipantCountAggregateInputType | true
    _min?: ChatParticipantMinAggregateInputType
    _max?: ChatParticipantMaxAggregateInputType
  }

  export type ChatParticipantGroupByOutputType = {
    id: string
    userId: string
    chatId: string
    joinedAt: Date
    _count: ChatParticipantCountAggregateOutputType | null
    _min: ChatParticipantMinAggregateOutputType | null
    _max: ChatParticipantMaxAggregateOutputType | null
  }

  type GetChatParticipantGroupByPayload<T extends ChatParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ChatParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ChatParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chatId?: boolean
    joinedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatParticipant"]>

  export type ChatParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chatId?: boolean
    joinedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatParticipant"]>

  export type ChatParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chatId?: boolean
    joinedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatParticipant"]>

  export type ChatParticipantSelectScalar = {
    id?: boolean
    userId?: boolean
    chatId?: boolean
    joinedAt?: boolean
  }

  export type ChatParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "chatId" | "joinedAt", ExtArgs["result"]["chatParticipant"]>
  export type ChatParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type ChatParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type ChatParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $ChatParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatParticipant"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      chat: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      chatId: string
      joinedAt: Date
    }, ExtArgs["result"]["chatParticipant"]>
    composites: {}
  }

  type ChatParticipantGetPayload<S extends boolean | null | undefined | ChatParticipantDefaultArgs> = $Result.GetResult<Prisma.$ChatParticipantPayload, S>

  type ChatParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatParticipantCountAggregateInputType | true
    }

  export interface ChatParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatParticipant'], meta: { name: 'ChatParticipant' } }
    /**
     * Find zero or one ChatParticipant that matches the filter.
     * @param {ChatParticipantFindUniqueArgs} args - Arguments to find a ChatParticipant
     * @example
     * // Get one ChatParticipant
     * const chatParticipant = await prisma.chatParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatParticipantFindUniqueArgs>(args: SelectSubset<T, ChatParticipantFindUniqueArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatParticipantFindUniqueOrThrowArgs} args - Arguments to find a ChatParticipant
     * @example
     * // Get one ChatParticipant
     * const chatParticipant = await prisma.chatParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantFindFirstArgs} args - Arguments to find a ChatParticipant
     * @example
     * // Get one ChatParticipant
     * const chatParticipant = await prisma.chatParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatParticipantFindFirstArgs>(args?: SelectSubset<T, ChatParticipantFindFirstArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantFindFirstOrThrowArgs} args - Arguments to find a ChatParticipant
     * @example
     * // Get one ChatParticipant
     * const chatParticipant = await prisma.chatParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatParticipants
     * const chatParticipants = await prisma.chatParticipant.findMany()
     * 
     * // Get first 10 ChatParticipants
     * const chatParticipants = await prisma.chatParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatParticipantWithIdOnly = await prisma.chatParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatParticipantFindManyArgs>(args?: SelectSubset<T, ChatParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatParticipant.
     * @param {ChatParticipantCreateArgs} args - Arguments to create a ChatParticipant.
     * @example
     * // Create one ChatParticipant
     * const ChatParticipant = await prisma.chatParticipant.create({
     *   data: {
     *     // ... data to create a ChatParticipant
     *   }
     * })
     * 
     */
    create<T extends ChatParticipantCreateArgs>(args: SelectSubset<T, ChatParticipantCreateArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatParticipants.
     * @param {ChatParticipantCreateManyArgs} args - Arguments to create many ChatParticipants.
     * @example
     * // Create many ChatParticipants
     * const chatParticipant = await prisma.chatParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatParticipantCreateManyArgs>(args?: SelectSubset<T, ChatParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatParticipants and returns the data saved in the database.
     * @param {ChatParticipantCreateManyAndReturnArgs} args - Arguments to create many ChatParticipants.
     * @example
     * // Create many ChatParticipants
     * const chatParticipant = await prisma.chatParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatParticipants and only return the `id`
     * const chatParticipantWithIdOnly = await prisma.chatParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatParticipant.
     * @param {ChatParticipantDeleteArgs} args - Arguments to delete one ChatParticipant.
     * @example
     * // Delete one ChatParticipant
     * const ChatParticipant = await prisma.chatParticipant.delete({
     *   where: {
     *     // ... filter to delete one ChatParticipant
     *   }
     * })
     * 
     */
    delete<T extends ChatParticipantDeleteArgs>(args: SelectSubset<T, ChatParticipantDeleteArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatParticipant.
     * @param {ChatParticipantUpdateArgs} args - Arguments to update one ChatParticipant.
     * @example
     * // Update one ChatParticipant
     * const chatParticipant = await prisma.chatParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatParticipantUpdateArgs>(args: SelectSubset<T, ChatParticipantUpdateArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatParticipants.
     * @param {ChatParticipantDeleteManyArgs} args - Arguments to filter ChatParticipants to delete.
     * @example
     * // Delete a few ChatParticipants
     * const { count } = await prisma.chatParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatParticipantDeleteManyArgs>(args?: SelectSubset<T, ChatParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatParticipants
     * const chatParticipant = await prisma.chatParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatParticipantUpdateManyArgs>(args: SelectSubset<T, ChatParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatParticipants and returns the data updated in the database.
     * @param {ChatParticipantUpdateManyAndReturnArgs} args - Arguments to update many ChatParticipants.
     * @example
     * // Update many ChatParticipants
     * const chatParticipant = await prisma.chatParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatParticipants and only return the `id`
     * const chatParticipantWithIdOnly = await prisma.chatParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatParticipant.
     * @param {ChatParticipantUpsertArgs} args - Arguments to update or create a ChatParticipant.
     * @example
     * // Update or create a ChatParticipant
     * const chatParticipant = await prisma.chatParticipant.upsert({
     *   create: {
     *     // ... data to create a ChatParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ChatParticipantUpsertArgs>(args: SelectSubset<T, ChatParticipantUpsertArgs<ExtArgs>>): Prisma__ChatParticipantClient<$Result.GetResult<Prisma.$ChatParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantCountArgs} args - Arguments to filter ChatParticipants to count.
     * @example
     * // Count the number of ChatParticipants
     * const count = await prisma.chatParticipant.count({
     *   where: {
     *     // ... the filter for the ChatParticipants we want to count
     *   }
     * })
    **/
    count<T extends ChatParticipantCountArgs>(
      args?: Subset<T, ChatParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatParticipantAggregateArgs>(args: Subset<T, ChatParticipantAggregateArgs>): Prisma.PrismaPromise<GetChatParticipantAggregateType<T>>

    /**
     * Group by ChatParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ChatParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatParticipant model
   */
  readonly fields: ChatParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatParticipant model
   */
  interface ChatParticipantFieldRefs {
    readonly id: FieldRef<"ChatParticipant", 'String'>
    readonly userId: FieldRef<"ChatParticipant", 'String'>
    readonly chatId: FieldRef<"ChatParticipant", 'String'>
    readonly joinedAt: FieldRef<"ChatParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatParticipant findUnique
   */
  export type ChatParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChatParticipant to fetch.
     */
    where: ChatParticipantWhereUniqueInput
  }

  /**
   * ChatParticipant findUniqueOrThrow
   */
  export type ChatParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChatParticipant to fetch.
     */
    where: ChatParticipantWhereUniqueInput
  }

  /**
   * ChatParticipant findFirst
   */
  export type ChatParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChatParticipant to fetch.
     */
    where?: ChatParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatParticipants to fetch.
     */
    orderBy?: ChatParticipantOrderByWithRelationInput | ChatParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatParticipants.
     */
    cursor?: ChatParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatParticipants.
     */
    distinct?: ChatParticipantScalarFieldEnum | ChatParticipantScalarFieldEnum[]
  }

  /**
   * ChatParticipant findFirstOrThrow
   */
  export type ChatParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChatParticipant to fetch.
     */
    where?: ChatParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatParticipants to fetch.
     */
    orderBy?: ChatParticipantOrderByWithRelationInput | ChatParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatParticipants.
     */
    cursor?: ChatParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatParticipants.
     */
    distinct?: ChatParticipantScalarFieldEnum | ChatParticipantScalarFieldEnum[]
  }

  /**
   * ChatParticipant findMany
   */
  export type ChatParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChatParticipants to fetch.
     */
    where?: ChatParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatParticipants to fetch.
     */
    orderBy?: ChatParticipantOrderByWithRelationInput | ChatParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatParticipants.
     */
    cursor?: ChatParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatParticipants.
     */
    skip?: number
    distinct?: ChatParticipantScalarFieldEnum | ChatParticipantScalarFieldEnum[]
  }

  /**
   * ChatParticipant create
   */
  export type ChatParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatParticipant.
     */
    data: XOR<ChatParticipantCreateInput, ChatParticipantUncheckedCreateInput>
  }

  /**
   * ChatParticipant createMany
   */
  export type ChatParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatParticipants.
     */
    data: ChatParticipantCreateManyInput | ChatParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatParticipant createManyAndReturn
   */
  export type ChatParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ChatParticipants.
     */
    data: ChatParticipantCreateManyInput | ChatParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatParticipant update
   */
  export type ChatParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatParticipant.
     */
    data: XOR<ChatParticipantUpdateInput, ChatParticipantUncheckedUpdateInput>
    /**
     * Choose, which ChatParticipant to update.
     */
    where: ChatParticipantWhereUniqueInput
  }

  /**
   * ChatParticipant updateMany
   */
  export type ChatParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatParticipants.
     */
    data: XOR<ChatParticipantUpdateManyMutationInput, ChatParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChatParticipants to update
     */
    where?: ChatParticipantWhereInput
    /**
     * Limit how many ChatParticipants to update.
     */
    limit?: number
  }

  /**
   * ChatParticipant updateManyAndReturn
   */
  export type ChatParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ChatParticipants.
     */
    data: XOR<ChatParticipantUpdateManyMutationInput, ChatParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChatParticipants to update
     */
    where?: ChatParticipantWhereInput
    /**
     * Limit how many ChatParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatParticipant upsert
   */
  export type ChatParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatParticipant to update in case it exists.
     */
    where: ChatParticipantWhereUniqueInput
    /**
     * In case the ChatParticipant found by the `where` argument doesn't exist, create a new ChatParticipant with this data.
     */
    create: XOR<ChatParticipantCreateInput, ChatParticipantUncheckedCreateInput>
    /**
     * In case the ChatParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatParticipantUpdateInput, ChatParticipantUncheckedUpdateInput>
  }

  /**
   * ChatParticipant delete
   */
  export type ChatParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
    /**
     * Filter which ChatParticipant to delete.
     */
    where: ChatParticipantWhereUniqueInput
  }

  /**
   * ChatParticipant deleteMany
   */
  export type ChatParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatParticipants to delete
     */
    where?: ChatParticipantWhereInput
    /**
     * Limit how many ChatParticipants to delete.
     */
    limit?: number
  }

  /**
   * ChatParticipant without action
   */
  export type ChatParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatParticipant
     */
    select?: ChatParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatParticipant
     */
    omit?: ChatParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    sentAt: Date | null
    senderId: string | null
    chatId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    sentAt: Date | null
    senderId: string | null
    chatId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    sentAt: number
    senderId: number
    chatId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    sentAt?: true
    senderId?: true
    chatId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    sentAt?: true
    senderId?: true
    chatId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    sentAt?: true
    senderId?: true
    chatId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    sentAt: Date
    senderId: string
    chatId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    sentAt?: boolean
    senderId?: boolean
    chatId?: boolean
    messageView?: boolean | Message$messageViewArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    sentAt?: boolean
    senderId?: boolean
    chatId?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    sentAt?: boolean
    senderId?: boolean
    chatId?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    sentAt?: boolean
    senderId?: boolean
    chatId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "sentAt" | "senderId" | "chatId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messageView?: boolean | Message$messageViewArgs<ExtArgs>
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      messageView: Prisma.$MessageViewPayload<ExtArgs>[]
      sender: Prisma.$UsersPayload<ExtArgs>
      chat: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      sentAt: Date
      senderId: string
      chatId: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messageView<T extends Message$messageViewArgs<ExtArgs> = {}>(args?: Subset<T, Message$messageViewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sender<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly sentAt: FieldRef<"Message", 'DateTime'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.messageView
   */
  export type Message$messageViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    where?: MessageViewWhereInput
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    cursor?: MessageViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageView
   */

  export type AggregateMessageView = {
    _count: MessageViewCountAggregateOutputType | null
    _min: MessageViewMinAggregateOutputType | null
    _max: MessageViewMaxAggregateOutputType | null
  }

  export type MessageViewMinAggregateOutputType = {
    id: string | null
    view: boolean | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageViewMaxAggregateOutputType = {
    id: string | null
    view: boolean | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageViewCountAggregateOutputType = {
    id: number
    view: number
    messageId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageViewMinAggregateInputType = {
    id?: true
    view?: true
    messageId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageViewMaxAggregateInputType = {
    id?: true
    view?: true
    messageId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageViewCountAggregateInputType = {
    id?: true
    view?: true
    messageId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageView to aggregate.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageViews
    **/
    _count?: true | MessageViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageViewMaxAggregateInputType
  }

  export type GetMessageViewAggregateType<T extends MessageViewAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageView[P]>
      : GetScalarType<T[P], AggregateMessageView[P]>
  }




  export type MessageViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageViewWhereInput
    orderBy?: MessageViewOrderByWithAggregationInput | MessageViewOrderByWithAggregationInput[]
    by: MessageViewScalarFieldEnum[] | MessageViewScalarFieldEnum
    having?: MessageViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageViewCountAggregateInputType | true
    _min?: MessageViewMinAggregateInputType
    _max?: MessageViewMaxAggregateInputType
  }

  export type MessageViewGroupByOutputType = {
    id: string
    view: boolean
    messageId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MessageViewCountAggregateOutputType | null
    _min: MessageViewMinAggregateOutputType | null
    _max: MessageViewMaxAggregateOutputType | null
  }

  type GetMessageViewGroupByPayload<T extends MessageViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageViewGroupByOutputType[P]>
            : GetScalarType<T[P], MessageViewGroupByOutputType[P]>
        }
      >
    >


  export type MessageViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    view?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageView"]>

  export type MessageViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    view?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageView"]>

  export type MessageViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    view?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageView"]>

  export type MessageViewSelectScalar = {
    id?: boolean
    view?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "view" | "messageId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["messageView"]>
  export type MessageViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MessageViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MessageViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MessageViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageView"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      view: boolean
      messageId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageView"]>
    composites: {}
  }

  type MessageViewGetPayload<S extends boolean | null | undefined | MessageViewDefaultArgs> = $Result.GetResult<Prisma.$MessageViewPayload, S>

  type MessageViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageViewCountAggregateInputType | true
    }

  export interface MessageViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageView'], meta: { name: 'MessageView' } }
    /**
     * Find zero or one MessageView that matches the filter.
     * @param {MessageViewFindUniqueArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageViewFindUniqueArgs>(args: SelectSubset<T, MessageViewFindUniqueArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageViewFindUniqueOrThrowArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageViewFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewFindFirstArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageViewFindFirstArgs>(args?: SelectSubset<T, MessageViewFindFirstArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewFindFirstOrThrowArgs} args - Arguments to find a MessageView
     * @example
     * // Get one MessageView
     * const messageView = await prisma.messageView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageViewFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageViews
     * const messageViews = await prisma.messageView.findMany()
     * 
     * // Get first 10 MessageViews
     * const messageViews = await prisma.messageView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageViewWithIdOnly = await prisma.messageView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageViewFindManyArgs>(args?: SelectSubset<T, MessageViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageView.
     * @param {MessageViewCreateArgs} args - Arguments to create a MessageView.
     * @example
     * // Create one MessageView
     * const MessageView = await prisma.messageView.create({
     *   data: {
     *     // ... data to create a MessageView
     *   }
     * })
     * 
     */
    create<T extends MessageViewCreateArgs>(args: SelectSubset<T, MessageViewCreateArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageViews.
     * @param {MessageViewCreateManyArgs} args - Arguments to create many MessageViews.
     * @example
     * // Create many MessageViews
     * const messageView = await prisma.messageView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageViewCreateManyArgs>(args?: SelectSubset<T, MessageViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageViews and returns the data saved in the database.
     * @param {MessageViewCreateManyAndReturnArgs} args - Arguments to create many MessageViews.
     * @example
     * // Create many MessageViews
     * const messageView = await prisma.messageView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageViews and only return the `id`
     * const messageViewWithIdOnly = await prisma.messageView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageViewCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageView.
     * @param {MessageViewDeleteArgs} args - Arguments to delete one MessageView.
     * @example
     * // Delete one MessageView
     * const MessageView = await prisma.messageView.delete({
     *   where: {
     *     // ... filter to delete one MessageView
     *   }
     * })
     * 
     */
    delete<T extends MessageViewDeleteArgs>(args: SelectSubset<T, MessageViewDeleteArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageView.
     * @param {MessageViewUpdateArgs} args - Arguments to update one MessageView.
     * @example
     * // Update one MessageView
     * const messageView = await prisma.messageView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageViewUpdateArgs>(args: SelectSubset<T, MessageViewUpdateArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageViews.
     * @param {MessageViewDeleteManyArgs} args - Arguments to filter MessageViews to delete.
     * @example
     * // Delete a few MessageViews
     * const { count } = await prisma.messageView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageViewDeleteManyArgs>(args?: SelectSubset<T, MessageViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageViews
     * const messageView = await prisma.messageView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageViewUpdateManyArgs>(args: SelectSubset<T, MessageViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageViews and returns the data updated in the database.
     * @param {MessageViewUpdateManyAndReturnArgs} args - Arguments to update many MessageViews.
     * @example
     * // Update many MessageViews
     * const messageView = await prisma.messageView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageViews and only return the `id`
     * const messageViewWithIdOnly = await prisma.messageView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageViewUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageView.
     * @param {MessageViewUpsertArgs} args - Arguments to update or create a MessageView.
     * @example
     * // Update or create a MessageView
     * const messageView = await prisma.messageView.upsert({
     *   create: {
     *     // ... data to create a MessageView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageView we want to update
     *   }
     * })
     */
    upsert<T extends MessageViewUpsertArgs>(args: SelectSubset<T, MessageViewUpsertArgs<ExtArgs>>): Prisma__MessageViewClient<$Result.GetResult<Prisma.$MessageViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewCountArgs} args - Arguments to filter MessageViews to count.
     * @example
     * // Count the number of MessageViews
     * const count = await prisma.messageView.count({
     *   where: {
     *     // ... the filter for the MessageViews we want to count
     *   }
     * })
    **/
    count<T extends MessageViewCountArgs>(
      args?: Subset<T, MessageViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageViewAggregateArgs>(args: Subset<T, MessageViewAggregateArgs>): Prisma.PrismaPromise<GetMessageViewAggregateType<T>>

    /**
     * Group by MessageView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageViewGroupByArgs['orderBy'] }
        : { orderBy?: MessageViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageView model
   */
  readonly fields: MessageViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageView model
   */
  interface MessageViewFieldRefs {
    readonly id: FieldRef<"MessageView", 'String'>
    readonly view: FieldRef<"MessageView", 'Boolean'>
    readonly messageId: FieldRef<"MessageView", 'String'>
    readonly userId: FieldRef<"MessageView", 'String'>
    readonly createdAt: FieldRef<"MessageView", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageView findUnique
   */
  export type MessageViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView findUniqueOrThrow
   */
  export type MessageViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView findFirst
   */
  export type MessageViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageViews.
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageViews.
     */
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * MessageView findFirstOrThrow
   */
  export type MessageViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageView to fetch.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageViews.
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageViews.
     */
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * MessageView findMany
   */
  export type MessageViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter, which MessageViews to fetch.
     */
    where?: MessageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageViews to fetch.
     */
    orderBy?: MessageViewOrderByWithRelationInput | MessageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageViews.
     */
    cursor?: MessageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageViews.
     */
    skip?: number
    distinct?: MessageViewScalarFieldEnum | MessageViewScalarFieldEnum[]
  }

  /**
   * MessageView create
   */
  export type MessageViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageView.
     */
    data: XOR<MessageViewCreateInput, MessageViewUncheckedCreateInput>
  }

  /**
   * MessageView createMany
   */
  export type MessageViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageViews.
     */
    data: MessageViewCreateManyInput | MessageViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageView createManyAndReturn
   */
  export type MessageViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * The data used to create many MessageViews.
     */
    data: MessageViewCreateManyInput | MessageViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageView update
   */
  export type MessageViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageView.
     */
    data: XOR<MessageViewUpdateInput, MessageViewUncheckedUpdateInput>
    /**
     * Choose, which MessageView to update.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView updateMany
   */
  export type MessageViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageViews.
     */
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyInput>
    /**
     * Filter which MessageViews to update
     */
    where?: MessageViewWhereInput
    /**
     * Limit how many MessageViews to update.
     */
    limit?: number
  }

  /**
   * MessageView updateManyAndReturn
   */
  export type MessageViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * The data used to update MessageViews.
     */
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyInput>
    /**
     * Filter which MessageViews to update
     */
    where?: MessageViewWhereInput
    /**
     * Limit how many MessageViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageView upsert
   */
  export type MessageViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageView to update in case it exists.
     */
    where: MessageViewWhereUniqueInput
    /**
     * In case the MessageView found by the `where` argument doesn't exist, create a new MessageView with this data.
     */
    create: XOR<MessageViewCreateInput, MessageViewUncheckedCreateInput>
    /**
     * In case the MessageView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageViewUpdateInput, MessageViewUncheckedUpdateInput>
  }

  /**
   * MessageView delete
   */
  export type MessageViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
    /**
     * Filter which MessageView to delete.
     */
    where: MessageViewWhereUniqueInput
  }

  /**
   * MessageView deleteMany
   */
  export type MessageViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageViews to delete
     */
    where?: MessageViewWhereInput
    /**
     * Limit how many MessageViews to delete.
     */
    limit?: number
  }

  /**
   * MessageView without action
   */
  export type MessageViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageView
     */
    select?: MessageViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageView
     */
    omit?: MessageViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageViewInclude<ExtArgs> | null
  }


  /**
   * Model Visits
   */

  export type AggregateVisits = {
    _count: VisitsCountAggregateOutputType | null
    _min: VisitsMinAggregateOutputType | null
    _max: VisitsMaxAggregateOutputType | null
  }

  export type VisitsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    status: boolean | null
    location: string | null
    objetif: string | null
    planningId: string | null
  }

  export type VisitsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    status: boolean | null
    location: string | null
    objetif: string | null
    planningId: string | null
  }

  export type VisitsCountAggregateOutputType = {
    id: number
    date: number
    startTime: number
    endTime: number
    status: number
    location: number
    objetif: number
    planningId: number
    _all: number
  }


  export type VisitsMinAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    location?: true
    objetif?: true
    planningId?: true
  }

  export type VisitsMaxAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    location?: true
    objetif?: true
    planningId?: true
  }

  export type VisitsCountAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    location?: true
    objetif?: true
    planningId?: true
    _all?: true
  }

  export type VisitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visits to aggregate.
     */
    where?: VisitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitsOrderByWithRelationInput | VisitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visits
    **/
    _count?: true | VisitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitsMaxAggregateInputType
  }

  export type GetVisitsAggregateType<T extends VisitsAggregateArgs> = {
        [P in keyof T & keyof AggregateVisits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisits[P]>
      : GetScalarType<T[P], AggregateVisits[P]>
  }




  export type VisitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitsWhereInput
    orderBy?: VisitsOrderByWithAggregationInput | VisitsOrderByWithAggregationInput[]
    by: VisitsScalarFieldEnum[] | VisitsScalarFieldEnum
    having?: VisitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitsCountAggregateInputType | true
    _min?: VisitsMinAggregateInputType
    _max?: VisitsMaxAggregateInputType
  }

  export type VisitsGroupByOutputType = {
    id: string
    date: Date
    startTime: string
    endTime: string
    status: boolean
    location: string
    objetif: string
    planningId: string
    _count: VisitsCountAggregateOutputType | null
    _min: VisitsMinAggregateOutputType | null
    _max: VisitsMaxAggregateOutputType | null
  }

  type GetVisitsGroupByPayload<T extends VisitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitsGroupByOutputType[P]>
            : GetScalarType<T[P], VisitsGroupByOutputType[P]>
        }
      >
    >


  export type VisitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    location?: boolean
    objetif?: boolean
    planningId?: boolean
    Planning?: boolean | PlanningDefaultArgs<ExtArgs>
    VisiteTerrain?: boolean | Visits$VisiteTerrainArgs<ExtArgs>
  }, ExtArgs["result"]["visits"]>

  export type VisitsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    location?: boolean
    objetif?: boolean
    planningId?: boolean
    Planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visits"]>

  export type VisitsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    location?: boolean
    objetif?: boolean
    planningId?: boolean
    Planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visits"]>

  export type VisitsSelectScalar = {
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    location?: boolean
    objetif?: boolean
    planningId?: boolean
  }

  export type VisitsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "startTime" | "endTime" | "status" | "location" | "objetif" | "planningId", ExtArgs["result"]["visits"]>
  export type VisitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planning?: boolean | PlanningDefaultArgs<ExtArgs>
    VisiteTerrain?: boolean | Visits$VisiteTerrainArgs<ExtArgs>
  }
  export type VisitsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }
  export type VisitsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planning?: boolean | PlanningDefaultArgs<ExtArgs>
  }

  export type $VisitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visits"
    objects: {
      Planning: Prisma.$PlanningPayload<ExtArgs>
      VisiteTerrain: Prisma.$VisiteTerrainPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      startTime: string
      endTime: string
      status: boolean
      location: string
      objetif: string
      planningId: string
    }, ExtArgs["result"]["visits"]>
    composites: {}
  }

  type VisitsGetPayload<S extends boolean | null | undefined | VisitsDefaultArgs> = $Result.GetResult<Prisma.$VisitsPayload, S>

  type VisitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitsCountAggregateInputType | true
    }

  export interface VisitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visits'], meta: { name: 'Visits' } }
    /**
     * Find zero or one Visits that matches the filter.
     * @param {VisitsFindUniqueArgs} args - Arguments to find a Visits
     * @example
     * // Get one Visits
     * const visits = await prisma.visits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitsFindUniqueArgs>(args: SelectSubset<T, VisitsFindUniqueArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visits that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitsFindUniqueOrThrowArgs} args - Arguments to find a Visits
     * @example
     * // Get one Visits
     * const visits = await prisma.visits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitsFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsFindFirstArgs} args - Arguments to find a Visits
     * @example
     * // Get one Visits
     * const visits = await prisma.visits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitsFindFirstArgs>(args?: SelectSubset<T, VisitsFindFirstArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsFindFirstOrThrowArgs} args - Arguments to find a Visits
     * @example
     * // Get one Visits
     * const visits = await prisma.visits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitsFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visits
     * const visits = await prisma.visits.findMany()
     * 
     * // Get first 10 Visits
     * const visits = await prisma.visits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitsWithIdOnly = await prisma.visits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitsFindManyArgs>(args?: SelectSubset<T, VisitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visits.
     * @param {VisitsCreateArgs} args - Arguments to create a Visits.
     * @example
     * // Create one Visits
     * const Visits = await prisma.visits.create({
     *   data: {
     *     // ... data to create a Visits
     *   }
     * })
     * 
     */
    create<T extends VisitsCreateArgs>(args: SelectSubset<T, VisitsCreateArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visits.
     * @param {VisitsCreateManyArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visits = await prisma.visits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitsCreateManyArgs>(args?: SelectSubset<T, VisitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visits and returns the data saved in the database.
     * @param {VisitsCreateManyAndReturnArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visits = await prisma.visits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visits and only return the `id`
     * const visitsWithIdOnly = await prisma.visits.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitsCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Visits.
     * @param {VisitsDeleteArgs} args - Arguments to delete one Visits.
     * @example
     * // Delete one Visits
     * const Visits = await prisma.visits.delete({
     *   where: {
     *     // ... filter to delete one Visits
     *   }
     * })
     * 
     */
    delete<T extends VisitsDeleteArgs>(args: SelectSubset<T, VisitsDeleteArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visits.
     * @param {VisitsUpdateArgs} args - Arguments to update one Visits.
     * @example
     * // Update one Visits
     * const visits = await prisma.visits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitsUpdateArgs>(args: SelectSubset<T, VisitsUpdateArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visits.
     * @param {VisitsDeleteManyArgs} args - Arguments to filter Visits to delete.
     * @example
     * // Delete a few Visits
     * const { count } = await prisma.visits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitsDeleteManyArgs>(args?: SelectSubset<T, VisitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visits
     * const visits = await prisma.visits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitsUpdateManyArgs>(args: SelectSubset<T, VisitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits and returns the data updated in the database.
     * @param {VisitsUpdateManyAndReturnArgs} args - Arguments to update many Visits.
     * @example
     * // Update many Visits
     * const visits = await prisma.visits.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Visits and only return the `id`
     * const visitsWithIdOnly = await prisma.visits.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisitsUpdateManyAndReturnArgs>(args: SelectSubset<T, VisitsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Visits.
     * @param {VisitsUpsertArgs} args - Arguments to update or create a Visits.
     * @example
     * // Update or create a Visits
     * const visits = await prisma.visits.upsert({
     *   create: {
     *     // ... data to create a Visits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visits we want to update
     *   }
     * })
     */
    upsert<T extends VisitsUpsertArgs>(args: SelectSubset<T, VisitsUpsertArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsCountArgs} args - Arguments to filter Visits to count.
     * @example
     * // Count the number of Visits
     * const count = await prisma.visits.count({
     *   where: {
     *     // ... the filter for the Visits we want to count
     *   }
     * })
    **/
    count<T extends VisitsCountArgs>(
      args?: Subset<T, VisitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitsAggregateArgs>(args: Subset<T, VisitsAggregateArgs>): Prisma.PrismaPromise<GetVisitsAggregateType<T>>

    /**
     * Group by Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitsGroupByArgs['orderBy'] }
        : { orderBy?: VisitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visits model
   */
  readonly fields: VisitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Planning<T extends PlanningDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanningDefaultArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    VisiteTerrain<T extends Visits$VisiteTerrainArgs<ExtArgs> = {}>(args?: Subset<T, Visits$VisiteTerrainArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visits model
   */
  interface VisitsFieldRefs {
    readonly id: FieldRef<"Visits", 'String'>
    readonly date: FieldRef<"Visits", 'DateTime'>
    readonly startTime: FieldRef<"Visits", 'String'>
    readonly endTime: FieldRef<"Visits", 'String'>
    readonly status: FieldRef<"Visits", 'Boolean'>
    readonly location: FieldRef<"Visits", 'String'>
    readonly objetif: FieldRef<"Visits", 'String'>
    readonly planningId: FieldRef<"Visits", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Visits findUnique
   */
  export type VisitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where: VisitsWhereUniqueInput
  }

  /**
   * Visits findUniqueOrThrow
   */
  export type VisitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where: VisitsWhereUniqueInput
  }

  /**
   * Visits findFirst
   */
  export type VisitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitsOrderByWithRelationInput | VisitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitsScalarFieldEnum | VisitsScalarFieldEnum[]
  }

  /**
   * Visits findFirstOrThrow
   */
  export type VisitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitsOrderByWithRelationInput | VisitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitsScalarFieldEnum | VisitsScalarFieldEnum[]
  }

  /**
   * Visits findMany
   */
  export type VisitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitsOrderByWithRelationInput | VisitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visits.
     */
    cursor?: VisitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    distinct?: VisitsScalarFieldEnum | VisitsScalarFieldEnum[]
  }

  /**
   * Visits create
   */
  export type VisitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * The data needed to create a Visits.
     */
    data: XOR<VisitsCreateInput, VisitsUncheckedCreateInput>
  }

  /**
   * Visits createMany
   */
  export type VisitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visits.
     */
    data: VisitsCreateManyInput | VisitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visits createManyAndReturn
   */
  export type VisitsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * The data used to create many Visits.
     */
    data: VisitsCreateManyInput | VisitsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visits update
   */
  export type VisitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * The data needed to update a Visits.
     */
    data: XOR<VisitsUpdateInput, VisitsUncheckedUpdateInput>
    /**
     * Choose, which Visits to update.
     */
    where: VisitsWhereUniqueInput
  }

  /**
   * Visits updateMany
   */
  export type VisitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitsUpdateManyMutationInput, VisitsUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitsWhereInput
    /**
     * Limit how many Visits to update.
     */
    limit?: number
  }

  /**
   * Visits updateManyAndReturn
   */
  export type VisitsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitsUpdateManyMutationInput, VisitsUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitsWhereInput
    /**
     * Limit how many Visits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visits upsert
   */
  export type VisitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * The filter to search for the Visits to update in case it exists.
     */
    where: VisitsWhereUniqueInput
    /**
     * In case the Visits found by the `where` argument doesn't exist, create a new Visits with this data.
     */
    create: XOR<VisitsCreateInput, VisitsUncheckedCreateInput>
    /**
     * In case the Visits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitsUpdateInput, VisitsUncheckedUpdateInput>
  }

  /**
   * Visits delete
   */
  export type VisitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    /**
     * Filter which Visits to delete.
     */
    where: VisitsWhereUniqueInput
  }

  /**
   * Visits deleteMany
   */
  export type VisitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visits to delete
     */
    where?: VisitsWhereInput
    /**
     * Limit how many Visits to delete.
     */
    limit?: number
  }

  /**
   * Visits.VisiteTerrain
   */
  export type Visits$VisiteTerrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    where?: VisiteTerrainWhereInput
  }

  /**
   * Visits without action
   */
  export type VisitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
  }


  /**
   * Model Planning
   */

  export type AggregatePlanning = {
    _count: PlanningCountAggregateOutputType | null
    _min: PlanningMinAggregateOutputType | null
    _max: PlanningMaxAggregateOutputType | null
  }

  export type PlanningMinAggregateOutputType = {
    id: string | null
    usersId: string | null
  }

  export type PlanningMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
  }

  export type PlanningCountAggregateOutputType = {
    id: number
    usersId: number
    _all: number
  }


  export type PlanningMinAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type PlanningMaxAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type PlanningCountAggregateInputType = {
    id?: true
    usersId?: true
    _all?: true
  }

  export type PlanningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planning to aggregate.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plannings
    **/
    _count?: true | PlanningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanningMaxAggregateInputType
  }

  export type GetPlanningAggregateType<T extends PlanningAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanning[P]>
      : GetScalarType<T[P], AggregatePlanning[P]>
  }




  export type PlanningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithAggregationInput | PlanningOrderByWithAggregationInput[]
    by: PlanningScalarFieldEnum[] | PlanningScalarFieldEnum
    having?: PlanningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanningCountAggregateInputType | true
    _min?: PlanningMinAggregateInputType
    _max?: PlanningMaxAggregateInputType
  }

  export type PlanningGroupByOutputType = {
    id: string
    usersId: string
    _count: PlanningCountAggregateOutputType | null
    _min: PlanningMinAggregateOutputType | null
    _max: PlanningMaxAggregateOutputType | null
  }

  type GetPlanningGroupByPayload<T extends PlanningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanningGroupByOutputType[P]>
            : GetScalarType<T[P], PlanningGroupByOutputType[P]>
        }
      >
    >


  export type PlanningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    accompaniments?: boolean | Planning$accompanimentsArgs<ExtArgs>
    visit?: boolean | Planning$visitArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | PlanningCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectScalar = {
    id?: boolean
    usersId?: boolean
  }

  export type PlanningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId", ExtArgs["result"]["planning"]>
  export type PlanningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniments?: boolean | Planning$accompanimentsArgs<ExtArgs>
    visit?: boolean | Planning$visitArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | PlanningCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PlanningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PlanningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Planning"
    objects: {
      accompaniments: Prisma.$AccompanimentPayload<ExtArgs>[]
      visit: Prisma.$VisitsPayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
    }, ExtArgs["result"]["planning"]>
    composites: {}
  }

  type PlanningGetPayload<S extends boolean | null | undefined | PlanningDefaultArgs> = $Result.GetResult<Prisma.$PlanningPayload, S>

  type PlanningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanningCountAggregateInputType | true
    }

  export interface PlanningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Planning'], meta: { name: 'Planning' } }
    /**
     * Find zero or one Planning that matches the filter.
     * @param {PlanningFindUniqueArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanningFindUniqueArgs>(args: SelectSubset<T, PlanningFindUniqueArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Planning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanningFindUniqueOrThrowArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanningFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Planning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindFirstArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanningFindFirstArgs>(args?: SelectSubset<T, PlanningFindFirstArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Planning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindFirstOrThrowArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanningFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanningFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plannings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plannings
     * const plannings = await prisma.planning.findMany()
     * 
     * // Get first 10 Plannings
     * const plannings = await prisma.planning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planningWithIdOnly = await prisma.planning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanningFindManyArgs>(args?: SelectSubset<T, PlanningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Planning.
     * @param {PlanningCreateArgs} args - Arguments to create a Planning.
     * @example
     * // Create one Planning
     * const Planning = await prisma.planning.create({
     *   data: {
     *     // ... data to create a Planning
     *   }
     * })
     * 
     */
    create<T extends PlanningCreateArgs>(args: SelectSubset<T, PlanningCreateArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plannings.
     * @param {PlanningCreateManyArgs} args - Arguments to create many Plannings.
     * @example
     * // Create many Plannings
     * const planning = await prisma.planning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanningCreateManyArgs>(args?: SelectSubset<T, PlanningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plannings and returns the data saved in the database.
     * @param {PlanningCreateManyAndReturnArgs} args - Arguments to create many Plannings.
     * @example
     * // Create many Plannings
     * const planning = await prisma.planning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plannings and only return the `id`
     * const planningWithIdOnly = await prisma.planning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanningCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Planning.
     * @param {PlanningDeleteArgs} args - Arguments to delete one Planning.
     * @example
     * // Delete one Planning
     * const Planning = await prisma.planning.delete({
     *   where: {
     *     // ... filter to delete one Planning
     *   }
     * })
     * 
     */
    delete<T extends PlanningDeleteArgs>(args: SelectSubset<T, PlanningDeleteArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Planning.
     * @param {PlanningUpdateArgs} args - Arguments to update one Planning.
     * @example
     * // Update one Planning
     * const planning = await prisma.planning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanningUpdateArgs>(args: SelectSubset<T, PlanningUpdateArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plannings.
     * @param {PlanningDeleteManyArgs} args - Arguments to filter Plannings to delete.
     * @example
     * // Delete a few Plannings
     * const { count } = await prisma.planning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanningDeleteManyArgs>(args?: SelectSubset<T, PlanningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plannings
     * const planning = await prisma.planning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanningUpdateManyArgs>(args: SelectSubset<T, PlanningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plannings and returns the data updated in the database.
     * @param {PlanningUpdateManyAndReturnArgs} args - Arguments to update many Plannings.
     * @example
     * // Update many Plannings
     * const planning = await prisma.planning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plannings and only return the `id`
     * const planningWithIdOnly = await prisma.planning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanningUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Planning.
     * @param {PlanningUpsertArgs} args - Arguments to update or create a Planning.
     * @example
     * // Update or create a Planning
     * const planning = await prisma.planning.upsert({
     *   create: {
     *     // ... data to create a Planning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planning we want to update
     *   }
     * })
     */
    upsert<T extends PlanningUpsertArgs>(args: SelectSubset<T, PlanningUpsertArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningCountArgs} args - Arguments to filter Plannings to count.
     * @example
     * // Count the number of Plannings
     * const count = await prisma.planning.count({
     *   where: {
     *     // ... the filter for the Plannings we want to count
     *   }
     * })
    **/
    count<T extends PlanningCountArgs>(
      args?: Subset<T, PlanningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanningAggregateArgs>(args: Subset<T, PlanningAggregateArgs>): Prisma.PrismaPromise<GetPlanningAggregateType<T>>

    /**
     * Group by Planning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanningGroupByArgs['orderBy'] }
        : { orderBy?: PlanningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Planning model
   */
  readonly fields: PlanningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Planning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accompaniments<T extends Planning$accompanimentsArgs<ExtArgs> = {}>(args?: Subset<T, Planning$accompanimentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visit<T extends Planning$visitArgs<ExtArgs> = {}>(args?: Subset<T, Planning$visitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Planning model
   */
  interface PlanningFieldRefs {
    readonly id: FieldRef<"Planning", 'String'>
    readonly usersId: FieldRef<"Planning", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Planning findUnique
   */
  export type PlanningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning findUniqueOrThrow
   */
  export type PlanningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning findFirst
   */
  export type PlanningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plannings.
     */
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning findFirstOrThrow
   */
  export type PlanningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plannings.
     */
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning findMany
   */
  export type PlanningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Plannings to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning create
   */
  export type PlanningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The data needed to create a Planning.
     */
    data: XOR<PlanningCreateInput, PlanningUncheckedCreateInput>
  }

  /**
   * Planning createMany
   */
  export type PlanningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plannings.
     */
    data: PlanningCreateManyInput | PlanningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Planning createManyAndReturn
   */
  export type PlanningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * The data used to create many Plannings.
     */
    data: PlanningCreateManyInput | PlanningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planning update
   */
  export type PlanningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The data needed to update a Planning.
     */
    data: XOR<PlanningUpdateInput, PlanningUncheckedUpdateInput>
    /**
     * Choose, which Planning to update.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning updateMany
   */
  export type PlanningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plannings.
     */
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyInput>
    /**
     * Filter which Plannings to update
     */
    where?: PlanningWhereInput
    /**
     * Limit how many Plannings to update.
     */
    limit?: number
  }

  /**
   * Planning updateManyAndReturn
   */
  export type PlanningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * The data used to update Plannings.
     */
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyInput>
    /**
     * Filter which Plannings to update
     */
    where?: PlanningWhereInput
    /**
     * Limit how many Plannings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planning upsert
   */
  export type PlanningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The filter to search for the Planning to update in case it exists.
     */
    where: PlanningWhereUniqueInput
    /**
     * In case the Planning found by the `where` argument doesn't exist, create a new Planning with this data.
     */
    create: XOR<PlanningCreateInput, PlanningUncheckedCreateInput>
    /**
     * In case the Planning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanningUpdateInput, PlanningUncheckedUpdateInput>
  }

  /**
   * Planning delete
   */
  export type PlanningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter which Planning to delete.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning deleteMany
   */
  export type PlanningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plannings to delete
     */
    where?: PlanningWhereInput
    /**
     * Limit how many Plannings to delete.
     */
    limit?: number
  }

  /**
   * Planning.accompaniments
   */
  export type Planning$accompanimentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accompaniment
     */
    select?: AccompanimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accompaniment
     */
    omit?: AccompanimentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccompanimentInclude<ExtArgs> | null
    where?: AccompanimentWhereInput
    orderBy?: AccompanimentOrderByWithRelationInput | AccompanimentOrderByWithRelationInput[]
    cursor?: AccompanimentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccompanimentScalarFieldEnum | AccompanimentScalarFieldEnum[]
  }

  /**
   * Planning.visit
   */
  export type Planning$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visits
     */
    select?: VisitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visits
     */
    omit?: VisitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitsInclude<ExtArgs> | null
    where?: VisitsWhereInput
    orderBy?: VisitsOrderByWithRelationInput | VisitsOrderByWithRelationInput[]
    cursor?: VisitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitsScalarFieldEnum | VisitsScalarFieldEnum[]
  }

  /**
   * Planning without action
   */
  export type PlanningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
  }


  /**
   * Model Maps
   */

  export type AggregateMaps = {
    _count: MapsCountAggregateOutputType | null
    _min: MapsMinAggregateOutputType | null
    _max: MapsMaxAggregateOutputType | null
  }

  export type MapsMinAggregateOutputType = {
    id: string | null
    accompanimentId: string | null
    latitude: string | null
    longitude: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapsMaxAggregateOutputType = {
    id: string | null
    accompanimentId: string | null
    latitude: string | null
    longitude: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapsCountAggregateOutputType = {
    id: number
    accompanimentId: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MapsMinAggregateInputType = {
    id?: true
    accompanimentId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapsMaxAggregateInputType = {
    id?: true
    accompanimentId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapsCountAggregateInputType = {
    id?: true
    accompanimentId?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MapsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maps to aggregate.
     */
    where?: MapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapsOrderByWithRelationInput | MapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maps
    **/
    _count?: true | MapsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapsMaxAggregateInputType
  }

  export type GetMapsAggregateType<T extends MapsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaps[P]>
      : GetScalarType<T[P], AggregateMaps[P]>
  }




  export type MapsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapsWhereInput
    orderBy?: MapsOrderByWithAggregationInput | MapsOrderByWithAggregationInput[]
    by: MapsScalarFieldEnum[] | MapsScalarFieldEnum
    having?: MapsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapsCountAggregateInputType | true
    _min?: MapsMinAggregateInputType
    _max?: MapsMaxAggregateInputType
  }

  export type MapsGroupByOutputType = {
    id: string
    accompanimentId: string
    latitude: string
    longitude: string
    createdAt: Date
    updatedAt: Date
    _count: MapsCountAggregateOutputType | null
    _min: MapsMinAggregateOutputType | null
    _max: MapsMaxAggregateOutputType | null
  }

  type GetMapsGroupByPayload<T extends MapsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapsGroupByOutputType[P]>
            : GetScalarType<T[P], MapsGroupByOutputType[P]>
        }
      >
    >


  export type MapsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accompanimentId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maps"]>

  export type MapsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accompanimentId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maps"]>

  export type MapsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accompanimentId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maps"]>

  export type MapsSelectScalar = {
    id?: boolean
    accompanimentId?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MapsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accompanimentId" | "latitude" | "longitude" | "createdAt" | "updatedAt", ExtArgs["result"]["maps"]>
  export type MapsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }
  export type MapsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }
  export type MapsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }

  export type $MapsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maps"
    objects: {
      accompaniment: Prisma.$AccompanimentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accompanimentId: string
      latitude: string
      longitude: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maps"]>
    composites: {}
  }

  type MapsGetPayload<S extends boolean | null | undefined | MapsDefaultArgs> = $Result.GetResult<Prisma.$MapsPayload, S>

  type MapsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapsCountAggregateInputType | true
    }

  export interface MapsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maps'], meta: { name: 'Maps' } }
    /**
     * Find zero or one Maps that matches the filter.
     * @param {MapsFindUniqueArgs} args - Arguments to find a Maps
     * @example
     * // Get one Maps
     * const maps = await prisma.maps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapsFindUniqueArgs>(args: SelectSubset<T, MapsFindUniqueArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maps that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapsFindUniqueOrThrowArgs} args - Arguments to find a Maps
     * @example
     * // Get one Maps
     * const maps = await prisma.maps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapsFindUniqueOrThrowArgs>(args: SelectSubset<T, MapsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsFindFirstArgs} args - Arguments to find a Maps
     * @example
     * // Get one Maps
     * const maps = await prisma.maps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapsFindFirstArgs>(args?: SelectSubset<T, MapsFindFirstArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsFindFirstOrThrowArgs} args - Arguments to find a Maps
     * @example
     * // Get one Maps
     * const maps = await prisma.maps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapsFindFirstOrThrowArgs>(args?: SelectSubset<T, MapsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maps
     * const maps = await prisma.maps.findMany()
     * 
     * // Get first 10 Maps
     * const maps = await prisma.maps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapsWithIdOnly = await prisma.maps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapsFindManyArgs>(args?: SelectSubset<T, MapsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maps.
     * @param {MapsCreateArgs} args - Arguments to create a Maps.
     * @example
     * // Create one Maps
     * const Maps = await prisma.maps.create({
     *   data: {
     *     // ... data to create a Maps
     *   }
     * })
     * 
     */
    create<T extends MapsCreateArgs>(args: SelectSubset<T, MapsCreateArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maps.
     * @param {MapsCreateManyArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const maps = await prisma.maps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapsCreateManyArgs>(args?: SelectSubset<T, MapsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maps and returns the data saved in the database.
     * @param {MapsCreateManyAndReturnArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const maps = await prisma.maps.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maps and only return the `id`
     * const mapsWithIdOnly = await prisma.maps.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapsCreateManyAndReturnArgs>(args?: SelectSubset<T, MapsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maps.
     * @param {MapsDeleteArgs} args - Arguments to delete one Maps.
     * @example
     * // Delete one Maps
     * const Maps = await prisma.maps.delete({
     *   where: {
     *     // ... filter to delete one Maps
     *   }
     * })
     * 
     */
    delete<T extends MapsDeleteArgs>(args: SelectSubset<T, MapsDeleteArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maps.
     * @param {MapsUpdateArgs} args - Arguments to update one Maps.
     * @example
     * // Update one Maps
     * const maps = await prisma.maps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapsUpdateArgs>(args: SelectSubset<T, MapsUpdateArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maps.
     * @param {MapsDeleteManyArgs} args - Arguments to filter Maps to delete.
     * @example
     * // Delete a few Maps
     * const { count } = await prisma.maps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapsDeleteManyArgs>(args?: SelectSubset<T, MapsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maps
     * const maps = await prisma.maps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapsUpdateManyArgs>(args: SelectSubset<T, MapsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps and returns the data updated in the database.
     * @param {MapsUpdateManyAndReturnArgs} args - Arguments to update many Maps.
     * @example
     * // Update many Maps
     * const maps = await prisma.maps.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maps and only return the `id`
     * const mapsWithIdOnly = await prisma.maps.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapsUpdateManyAndReturnArgs>(args: SelectSubset<T, MapsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maps.
     * @param {MapsUpsertArgs} args - Arguments to update or create a Maps.
     * @example
     * // Update or create a Maps
     * const maps = await prisma.maps.upsert({
     *   create: {
     *     // ... data to create a Maps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maps we want to update
     *   }
     * })
     */
    upsert<T extends MapsUpsertArgs>(args: SelectSubset<T, MapsUpsertArgs<ExtArgs>>): Prisma__MapsClient<$Result.GetResult<Prisma.$MapsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsCountArgs} args - Arguments to filter Maps to count.
     * @example
     * // Count the number of Maps
     * const count = await prisma.maps.count({
     *   where: {
     *     // ... the filter for the Maps we want to count
     *   }
     * })
    **/
    count<T extends MapsCountArgs>(
      args?: Subset<T, MapsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapsAggregateArgs>(args: Subset<T, MapsAggregateArgs>): Prisma.PrismaPromise<GetMapsAggregateType<T>>

    /**
     * Group by Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapsGroupByArgs['orderBy'] }
        : { orderBy?: MapsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maps model
   */
  readonly fields: MapsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accompaniment<T extends AccompanimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccompanimentDefaultArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maps model
   */
  interface MapsFieldRefs {
    readonly id: FieldRef<"Maps", 'String'>
    readonly accompanimentId: FieldRef<"Maps", 'String'>
    readonly latitude: FieldRef<"Maps", 'String'>
    readonly longitude: FieldRef<"Maps", 'String'>
    readonly createdAt: FieldRef<"Maps", 'DateTime'>
    readonly updatedAt: FieldRef<"Maps", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Maps findUnique
   */
  export type MapsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where: MapsWhereUniqueInput
  }

  /**
   * Maps findUniqueOrThrow
   */
  export type MapsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where: MapsWhereUniqueInput
  }

  /**
   * Maps findFirst
   */
  export type MapsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where?: MapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapsOrderByWithRelationInput | MapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapsScalarFieldEnum | MapsScalarFieldEnum[]
  }

  /**
   * Maps findFirstOrThrow
   */
  export type MapsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where?: MapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapsOrderByWithRelationInput | MapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapsScalarFieldEnum | MapsScalarFieldEnum[]
  }

  /**
   * Maps findMany
   */
  export type MapsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where?: MapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapsOrderByWithRelationInput | MapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maps.
     */
    cursor?: MapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    distinct?: MapsScalarFieldEnum | MapsScalarFieldEnum[]
  }

  /**
   * Maps create
   */
  export type MapsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * The data needed to create a Maps.
     */
    data: XOR<MapsCreateInput, MapsUncheckedCreateInput>
  }

  /**
   * Maps createMany
   */
  export type MapsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maps.
     */
    data: MapsCreateManyInput | MapsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maps createManyAndReturn
   */
  export type MapsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * The data used to create many Maps.
     */
    data: MapsCreateManyInput | MapsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maps update
   */
  export type MapsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * The data needed to update a Maps.
     */
    data: XOR<MapsUpdateInput, MapsUncheckedUpdateInput>
    /**
     * Choose, which Maps to update.
     */
    where: MapsWhereUniqueInput
  }

  /**
   * Maps updateMany
   */
  export type MapsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maps.
     */
    data: XOR<MapsUpdateManyMutationInput, MapsUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapsWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
  }

  /**
   * Maps updateManyAndReturn
   */
  export type MapsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * The data used to update Maps.
     */
    data: XOR<MapsUpdateManyMutationInput, MapsUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapsWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maps upsert
   */
  export type MapsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * The filter to search for the Maps to update in case it exists.
     */
    where: MapsWhereUniqueInput
    /**
     * In case the Maps found by the `where` argument doesn't exist, create a new Maps with this data.
     */
    create: XOR<MapsCreateInput, MapsUncheckedCreateInput>
    /**
     * In case the Maps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapsUpdateInput, MapsUncheckedUpdateInput>
  }

  /**
   * Maps delete
   */
  export type MapsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
    /**
     * Filter which Maps to delete.
     */
    where: MapsWhereUniqueInput
  }

  /**
   * Maps deleteMany
   */
  export type MapsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maps to delete
     */
    where?: MapsWhereInput
    /**
     * Limit how many Maps to delete.
     */
    limit?: number
  }

  /**
   * Maps without action
   */
  export type MapsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maps
     */
    select?: MapsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maps
     */
    omit?: MapsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapsInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItems
   */

  export type AggregatePurchaseItems = {
    _count: PurchaseItemsCountAggregateOutputType | null
    _avg: PurchaseItemsAvgAggregateOutputType | null
    _sum: PurchaseItemsSumAggregateOutputType | null
    _min: PurchaseItemsMinAggregateOutputType | null
    _max: PurchaseItemsMaxAggregateOutputType | null
  }

  export type PurchaseItemsAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PurchaseItemsSumAggregateOutputType = {
    quantity: number | null
  }

  export type PurchaseItemsMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    image: string | null
    quantity: number | null
    date: Date | null
    purchaseId: string | null
  }

  export type PurchaseItemsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    image: string | null
    quantity: number | null
    date: Date | null
    purchaseId: string | null
  }

  export type PurchaseItemsCountAggregateOutputType = {
    id: number
    name: number
    price: number
    image: number
    quantity: number
    date: number
    purchaseId: number
    _all: number
  }


  export type PurchaseItemsAvgAggregateInputType = {
    quantity?: true
  }

  export type PurchaseItemsSumAggregateInputType = {
    quantity?: true
  }

  export type PurchaseItemsMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    image?: true
    quantity?: true
    date?: true
    purchaseId?: true
  }

  export type PurchaseItemsMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    image?: true
    quantity?: true
    date?: true
    purchaseId?: true
  }

  export type PurchaseItemsCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    image?: true
    quantity?: true
    date?: true
    purchaseId?: true
    _all?: true
  }

  export type PurchaseItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to aggregate.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemsOrderByWithRelationInput | PurchaseItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemsMaxAggregateInputType
  }

  export type GetPurchaseItemsAggregateType<T extends PurchaseItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItems[P]>
      : GetScalarType<T[P], AggregatePurchaseItems[P]>
  }




  export type PurchaseItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemsWhereInput
    orderBy?: PurchaseItemsOrderByWithAggregationInput | PurchaseItemsOrderByWithAggregationInput[]
    by: PurchaseItemsScalarFieldEnum[] | PurchaseItemsScalarFieldEnum
    having?: PurchaseItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemsCountAggregateInputType | true
    _avg?: PurchaseItemsAvgAggregateInputType
    _sum?: PurchaseItemsSumAggregateInputType
    _min?: PurchaseItemsMinAggregateInputType
    _max?: PurchaseItemsMaxAggregateInputType
  }

  export type PurchaseItemsGroupByOutputType = {
    id: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date
    purchaseId: string
    _count: PurchaseItemsCountAggregateOutputType | null
    _avg: PurchaseItemsAvgAggregateOutputType | null
    _sum: PurchaseItemsSumAggregateOutputType | null
    _min: PurchaseItemsMinAggregateOutputType | null
    _max: PurchaseItemsMaxAggregateOutputType | null
  }

  type GetPurchaseItemsGroupByPayload<T extends PurchaseItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemsGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    image?: boolean
    quantity?: boolean
    date?: boolean
    purchaseId?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItems"]>

  export type PurchaseItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    image?: boolean
    quantity?: boolean
    date?: boolean
    purchaseId?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItems"]>

  export type PurchaseItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    image?: boolean
    quantity?: boolean
    date?: boolean
    purchaseId?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItems"]>

  export type PurchaseItemsSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    image?: boolean
    quantity?: boolean
    date?: boolean
    purchaseId?: boolean
  }

  export type PurchaseItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "image" | "quantity" | "date" | "purchaseId", ExtArgs["result"]["purchaseItems"]>
  export type PurchaseItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
  }
  export type PurchaseItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
  }
  export type PurchaseItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
  }

  export type $PurchaseItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItems"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: string
      image: string
      quantity: number
      date: Date
      purchaseId: string
    }, ExtArgs["result"]["purchaseItems"]>
    composites: {}
  }

  type PurchaseItemsGetPayload<S extends boolean | null | undefined | PurchaseItemsDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemsPayload, S>

  type PurchaseItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseItemsCountAggregateInputType | true
    }

  export interface PurchaseItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItems'], meta: { name: 'PurchaseItems' } }
    /**
     * Find zero or one PurchaseItems that matches the filter.
     * @param {PurchaseItemsFindUniqueArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemsFindUniqueArgs>(args: SelectSubset<T, PurchaseItemsFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseItemsFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsFindFirstArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemsFindFirstArgs>(args?: SelectSubset<T, PurchaseItemsFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsFindFirstOrThrowArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemsWithIdOnly = await prisma.purchaseItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemsFindManyArgs>(args?: SelectSubset<T, PurchaseItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseItems.
     * @param {PurchaseItemsCreateArgs} args - Arguments to create a PurchaseItems.
     * @example
     * // Create one PurchaseItems
     * const PurchaseItems = await prisma.purchaseItems.create({
     *   data: {
     *     // ... data to create a PurchaseItems
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemsCreateArgs>(args: SelectSubset<T, PurchaseItemsCreateArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemsCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemsCreateManyArgs>(args?: SelectSubset<T, PurchaseItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseItems and returns the data saved in the database.
     * @param {PurchaseItemsCreateManyAndReturnArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseItems and only return the `id`
     * const purchaseItemsWithIdOnly = await prisma.purchaseItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseItems.
     * @param {PurchaseItemsDeleteArgs} args - Arguments to delete one PurchaseItems.
     * @example
     * // Delete one PurchaseItems
     * const PurchaseItems = await prisma.purchaseItems.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItems
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemsDeleteArgs>(args: SelectSubset<T, PurchaseItemsDeleteArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseItems.
     * @param {PurchaseItemsUpdateArgs} args - Arguments to update one PurchaseItems.
     * @example
     * // Update one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemsUpdateArgs>(args: SelectSubset<T, PurchaseItemsUpdateArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemsDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemsDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemsUpdateManyArgs>(args: SelectSubset<T, PurchaseItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems and returns the data updated in the database.
     * @param {PurchaseItemsUpdateManyAndReturnArgs} args - Arguments to update many PurchaseItems.
     * @example
     * // Update many PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseItems and only return the `id`
     * const purchaseItemsWithIdOnly = await prisma.purchaseItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseItems.
     * @param {PurchaseItemsUpsertArgs} args - Arguments to update or create a PurchaseItems.
     * @example
     * // Update or create a PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.upsert({
     *   create: {
     *     // ... data to create a PurchaseItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItems we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemsUpsertArgs>(args: SelectSubset<T, PurchaseItemsUpsertArgs<ExtArgs>>): Prisma__PurchaseItemsClient<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItems.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemsCountArgs>(
      args?: Subset<T, PurchaseItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemsAggregateArgs>(args: Subset<T, PurchaseItemsAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemsAggregateType<T>>

    /**
     * Group by PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemsGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItems model
   */
  readonly fields: PurchaseItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItems model
   */
  interface PurchaseItemsFieldRefs {
    readonly id: FieldRef<"PurchaseItems", 'String'>
    readonly name: FieldRef<"PurchaseItems", 'String'>
    readonly price: FieldRef<"PurchaseItems", 'String'>
    readonly image: FieldRef<"PurchaseItems", 'String'>
    readonly quantity: FieldRef<"PurchaseItems", 'Int'>
    readonly date: FieldRef<"PurchaseItems", 'DateTime'>
    readonly purchaseId: FieldRef<"PurchaseItems", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItems findUnique
   */
  export type PurchaseItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where: PurchaseItemsWhereUniqueInput
  }

  /**
   * PurchaseItems findUniqueOrThrow
   */
  export type PurchaseItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where: PurchaseItemsWhereUniqueInput
  }

  /**
   * PurchaseItems findFirst
   */
  export type PurchaseItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemsOrderByWithRelationInput | PurchaseItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemsScalarFieldEnum | PurchaseItemsScalarFieldEnum[]
  }

  /**
   * PurchaseItems findFirstOrThrow
   */
  export type PurchaseItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemsOrderByWithRelationInput | PurchaseItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemsScalarFieldEnum | PurchaseItemsScalarFieldEnum[]
  }

  /**
   * PurchaseItems findMany
   */
  export type PurchaseItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemsOrderByWithRelationInput | PurchaseItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemsScalarFieldEnum | PurchaseItemsScalarFieldEnum[]
  }

  /**
   * PurchaseItems create
   */
  export type PurchaseItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItems.
     */
    data: XOR<PurchaseItemsCreateInput, PurchaseItemsUncheckedCreateInput>
  }

  /**
   * PurchaseItems createMany
   */
  export type PurchaseItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemsCreateManyInput | PurchaseItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseItems createManyAndReturn
   */
  export type PurchaseItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemsCreateManyInput | PurchaseItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItems update
   */
  export type PurchaseItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItems.
     */
    data: XOR<PurchaseItemsUpdateInput, PurchaseItemsUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItems to update.
     */
    where: PurchaseItemsWhereUniqueInput
  }

  /**
   * PurchaseItems updateMany
   */
  export type PurchaseItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemsUpdateManyMutationInput, PurchaseItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemsWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseItems updateManyAndReturn
   */
  export type PurchaseItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemsUpdateManyMutationInput, PurchaseItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemsWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItems upsert
   */
  export type PurchaseItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItems to update in case it exists.
     */
    where: PurchaseItemsWhereUniqueInput
    /**
     * In case the PurchaseItems found by the `where` argument doesn't exist, create a new PurchaseItems with this data.
     */
    create: XOR<PurchaseItemsCreateInput, PurchaseItemsUncheckedCreateInput>
    /**
     * In case the PurchaseItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemsUpdateInput, PurchaseItemsUncheckedUpdateInput>
  }

  /**
   * PurchaseItems delete
   */
  export type PurchaseItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItems to delete.
     */
    where: PurchaseItemsWhereUniqueInput
  }

  /**
   * PurchaseItems deleteMany
   */
  export type PurchaseItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemsWhereInput
    /**
     * Limit how many PurchaseItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseItems without action
   */
  export type PurchaseItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    total: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    total: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    total: number | null
    accompanimentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    total: number | null
    accompanimentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    total: number
    accompanimentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    total?: true
  }

  export type PurchaseSumAggregateInputType = {
    total?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    total?: true
    accompanimentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    total?: true
    accompanimentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    total?: true
    accompanimentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    total: number
    accompanimentId: string
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseItems?: boolean | Purchase$purchaseItemsArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    total?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "total" | "accompanimentId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | Purchase$purchaseItemsArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      purchaseItems: Prisma.$PurchaseItemsPayload<ExtArgs>[]
      accompaniment: Prisma.$AccompanimentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      total: number
      accompanimentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseItems<T extends Purchase$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accompaniment<T extends AccompanimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccompanimentDefaultArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly total: FieldRef<"Purchase", 'Int'>
    readonly accompanimentId: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase.purchaseItems
   */
  export type Purchase$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItems
     */
    omit?: PurchaseItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemsInclude<ExtArgs> | null
    where?: PurchaseItemsWhereInput
    orderBy?: PurchaseItemsOrderByWithRelationInput | PurchaseItemsOrderByWithRelationInput[]
    cursor?: PurchaseItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemsScalarFieldEnum | PurchaseItemsScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Emargement
   */

  export type AggregateEmargement = {
    _count: EmargementCountAggregateOutputType | null
    _avg: EmargementAvgAggregateOutputType | null
    _sum: EmargementSumAggregateOutputType | null
    _min: EmargementMinAggregateOutputType | null
    _max: EmargementMaxAggregateOutputType | null
  }

  export type EmargementAvgAggregateOutputType = {
    montant: number | null
  }

  export type EmargementSumAggregateOutputType = {
    montant: number | null
  }

  export type EmargementMinAggregateOutputType = {
    id: string | null
    date: Date | null
    signature: boolean | null
    cni: string | null
    PhotoCni: string | null
    montant: number | null
    observations: string | null
    usersId: string | null
    memberId: string | null
  }

  export type EmargementMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    signature: boolean | null
    cni: string | null
    PhotoCni: string | null
    montant: number | null
    observations: string | null
    usersId: string | null
    memberId: string | null
  }

  export type EmargementCountAggregateOutputType = {
    id: number
    date: number
    signature: number
    cni: number
    PhotoCni: number
    montant: number
    observations: number
    usersId: number
    memberId: number
    _all: number
  }


  export type EmargementAvgAggregateInputType = {
    montant?: true
  }

  export type EmargementSumAggregateInputType = {
    montant?: true
  }

  export type EmargementMinAggregateInputType = {
    id?: true
    date?: true
    signature?: true
    cni?: true
    PhotoCni?: true
    montant?: true
    observations?: true
    usersId?: true
    memberId?: true
  }

  export type EmargementMaxAggregateInputType = {
    id?: true
    date?: true
    signature?: true
    cni?: true
    PhotoCni?: true
    montant?: true
    observations?: true
    usersId?: true
    memberId?: true
  }

  export type EmargementCountAggregateInputType = {
    id?: true
    date?: true
    signature?: true
    cni?: true
    PhotoCni?: true
    montant?: true
    observations?: true
    usersId?: true
    memberId?: true
    _all?: true
  }

  export type EmargementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emargement to aggregate.
     */
    where?: EmargementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emargements to fetch.
     */
    orderBy?: EmargementOrderByWithRelationInput | EmargementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmargementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emargements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emargements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emargements
    **/
    _count?: true | EmargementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmargementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmargementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmargementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmargementMaxAggregateInputType
  }

  export type GetEmargementAggregateType<T extends EmargementAggregateArgs> = {
        [P in keyof T & keyof AggregateEmargement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmargement[P]>
      : GetScalarType<T[P], AggregateEmargement[P]>
  }




  export type EmargementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmargementWhereInput
    orderBy?: EmargementOrderByWithAggregationInput | EmargementOrderByWithAggregationInput[]
    by: EmargementScalarFieldEnum[] | EmargementScalarFieldEnum
    having?: EmargementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmargementCountAggregateInputType | true
    _avg?: EmargementAvgAggregateInputType
    _sum?: EmargementSumAggregateInputType
    _min?: EmargementMinAggregateInputType
    _max?: EmargementMaxAggregateInputType
  }

  export type EmargementGroupByOutputType = {
    id: string
    date: Date
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    usersId: string
    memberId: string
    _count: EmargementCountAggregateOutputType | null
    _avg: EmargementAvgAggregateOutputType | null
    _sum: EmargementSumAggregateOutputType | null
    _min: EmargementMinAggregateOutputType | null
    _max: EmargementMaxAggregateOutputType | null
  }

  type GetEmargementGroupByPayload<T extends EmargementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmargementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmargementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmargementGroupByOutputType[P]>
            : GetScalarType<T[P], EmargementGroupByOutputType[P]>
        }
      >
    >


  export type EmargementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    signature?: boolean
    cni?: boolean
    PhotoCni?: boolean
    montant?: boolean
    observations?: boolean
    usersId?: boolean
    memberId?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emargement"]>

  export type EmargementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    signature?: boolean
    cni?: boolean
    PhotoCni?: boolean
    montant?: boolean
    observations?: boolean
    usersId?: boolean
    memberId?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emargement"]>

  export type EmargementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    signature?: boolean
    cni?: boolean
    PhotoCni?: boolean
    montant?: boolean
    observations?: boolean
    usersId?: boolean
    memberId?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emargement"]>

  export type EmargementSelectScalar = {
    id?: boolean
    date?: boolean
    signature?: boolean
    cni?: boolean
    PhotoCni?: boolean
    montant?: boolean
    observations?: boolean
    usersId?: boolean
    memberId?: boolean
  }

  export type EmargementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "signature" | "cni" | "PhotoCni" | "montant" | "observations" | "usersId" | "memberId", ExtArgs["result"]["emargement"]>
  export type EmargementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type EmargementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type EmargementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $EmargementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emargement"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      signature: boolean
      cni: string
      PhotoCni: string
      montant: number
      observations: string
      usersId: string
      memberId: string
    }, ExtArgs["result"]["emargement"]>
    composites: {}
  }

  type EmargementGetPayload<S extends boolean | null | undefined | EmargementDefaultArgs> = $Result.GetResult<Prisma.$EmargementPayload, S>

  type EmargementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmargementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmargementCountAggregateInputType | true
    }

  export interface EmargementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emargement'], meta: { name: 'Emargement' } }
    /**
     * Find zero or one Emargement that matches the filter.
     * @param {EmargementFindUniqueArgs} args - Arguments to find a Emargement
     * @example
     * // Get one Emargement
     * const emargement = await prisma.emargement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmargementFindUniqueArgs>(args: SelectSubset<T, EmargementFindUniqueArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emargement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmargementFindUniqueOrThrowArgs} args - Arguments to find a Emargement
     * @example
     * // Get one Emargement
     * const emargement = await prisma.emargement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmargementFindUniqueOrThrowArgs>(args: SelectSubset<T, EmargementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emargement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementFindFirstArgs} args - Arguments to find a Emargement
     * @example
     * // Get one Emargement
     * const emargement = await prisma.emargement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmargementFindFirstArgs>(args?: SelectSubset<T, EmargementFindFirstArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emargement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementFindFirstOrThrowArgs} args - Arguments to find a Emargement
     * @example
     * // Get one Emargement
     * const emargement = await prisma.emargement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmargementFindFirstOrThrowArgs>(args?: SelectSubset<T, EmargementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emargements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emargements
     * const emargements = await prisma.emargement.findMany()
     * 
     * // Get first 10 Emargements
     * const emargements = await prisma.emargement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emargementWithIdOnly = await prisma.emargement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmargementFindManyArgs>(args?: SelectSubset<T, EmargementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emargement.
     * @param {EmargementCreateArgs} args - Arguments to create a Emargement.
     * @example
     * // Create one Emargement
     * const Emargement = await prisma.emargement.create({
     *   data: {
     *     // ... data to create a Emargement
     *   }
     * })
     * 
     */
    create<T extends EmargementCreateArgs>(args: SelectSubset<T, EmargementCreateArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emargements.
     * @param {EmargementCreateManyArgs} args - Arguments to create many Emargements.
     * @example
     * // Create many Emargements
     * const emargement = await prisma.emargement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmargementCreateManyArgs>(args?: SelectSubset<T, EmargementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emargements and returns the data saved in the database.
     * @param {EmargementCreateManyAndReturnArgs} args - Arguments to create many Emargements.
     * @example
     * // Create many Emargements
     * const emargement = await prisma.emargement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emargements and only return the `id`
     * const emargementWithIdOnly = await prisma.emargement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmargementCreateManyAndReturnArgs>(args?: SelectSubset<T, EmargementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Emargement.
     * @param {EmargementDeleteArgs} args - Arguments to delete one Emargement.
     * @example
     * // Delete one Emargement
     * const Emargement = await prisma.emargement.delete({
     *   where: {
     *     // ... filter to delete one Emargement
     *   }
     * })
     * 
     */
    delete<T extends EmargementDeleteArgs>(args: SelectSubset<T, EmargementDeleteArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emargement.
     * @param {EmargementUpdateArgs} args - Arguments to update one Emargement.
     * @example
     * // Update one Emargement
     * const emargement = await prisma.emargement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmargementUpdateArgs>(args: SelectSubset<T, EmargementUpdateArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emargements.
     * @param {EmargementDeleteManyArgs} args - Arguments to filter Emargements to delete.
     * @example
     * // Delete a few Emargements
     * const { count } = await prisma.emargement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmargementDeleteManyArgs>(args?: SelectSubset<T, EmargementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emargements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emargements
     * const emargement = await prisma.emargement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmargementUpdateManyArgs>(args: SelectSubset<T, EmargementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emargements and returns the data updated in the database.
     * @param {EmargementUpdateManyAndReturnArgs} args - Arguments to update many Emargements.
     * @example
     * // Update many Emargements
     * const emargement = await prisma.emargement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emargements and only return the `id`
     * const emargementWithIdOnly = await prisma.emargement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmargementUpdateManyAndReturnArgs>(args: SelectSubset<T, EmargementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Emargement.
     * @param {EmargementUpsertArgs} args - Arguments to update or create a Emargement.
     * @example
     * // Update or create a Emargement
     * const emargement = await prisma.emargement.upsert({
     *   create: {
     *     // ... data to create a Emargement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emargement we want to update
     *   }
     * })
     */
    upsert<T extends EmargementUpsertArgs>(args: SelectSubset<T, EmargementUpsertArgs<ExtArgs>>): Prisma__EmargementClient<$Result.GetResult<Prisma.$EmargementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emargements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementCountArgs} args - Arguments to filter Emargements to count.
     * @example
     * // Count the number of Emargements
     * const count = await prisma.emargement.count({
     *   where: {
     *     // ... the filter for the Emargements we want to count
     *   }
     * })
    **/
    count<T extends EmargementCountArgs>(
      args?: Subset<T, EmargementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmargementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emargement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmargementAggregateArgs>(args: Subset<T, EmargementAggregateArgs>): Prisma.PrismaPromise<GetEmargementAggregateType<T>>

    /**
     * Group by Emargement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmargementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmargementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmargementGroupByArgs['orderBy'] }
        : { orderBy?: EmargementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmargementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmargementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emargement model
   */
  readonly fields: EmargementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emargement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmargementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emargement model
   */
  interface EmargementFieldRefs {
    readonly id: FieldRef<"Emargement", 'String'>
    readonly date: FieldRef<"Emargement", 'DateTime'>
    readonly signature: FieldRef<"Emargement", 'Boolean'>
    readonly cni: FieldRef<"Emargement", 'String'>
    readonly PhotoCni: FieldRef<"Emargement", 'String'>
    readonly montant: FieldRef<"Emargement", 'Int'>
    readonly observations: FieldRef<"Emargement", 'String'>
    readonly usersId: FieldRef<"Emargement", 'String'>
    readonly memberId: FieldRef<"Emargement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Emargement findUnique
   */
  export type EmargementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * Filter, which Emargement to fetch.
     */
    where: EmargementWhereUniqueInput
  }

  /**
   * Emargement findUniqueOrThrow
   */
  export type EmargementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * Filter, which Emargement to fetch.
     */
    where: EmargementWhereUniqueInput
  }

  /**
   * Emargement findFirst
   */
  export type EmargementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * Filter, which Emargement to fetch.
     */
    where?: EmargementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emargements to fetch.
     */
    orderBy?: EmargementOrderByWithRelationInput | EmargementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emargements.
     */
    cursor?: EmargementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emargements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emargements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emargements.
     */
    distinct?: EmargementScalarFieldEnum | EmargementScalarFieldEnum[]
  }

  /**
   * Emargement findFirstOrThrow
   */
  export type EmargementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * Filter, which Emargement to fetch.
     */
    where?: EmargementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emargements to fetch.
     */
    orderBy?: EmargementOrderByWithRelationInput | EmargementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emargements.
     */
    cursor?: EmargementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emargements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emargements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emargements.
     */
    distinct?: EmargementScalarFieldEnum | EmargementScalarFieldEnum[]
  }

  /**
   * Emargement findMany
   */
  export type EmargementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * Filter, which Emargements to fetch.
     */
    where?: EmargementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emargements to fetch.
     */
    orderBy?: EmargementOrderByWithRelationInput | EmargementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emargements.
     */
    cursor?: EmargementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emargements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emargements.
     */
    skip?: number
    distinct?: EmargementScalarFieldEnum | EmargementScalarFieldEnum[]
  }

  /**
   * Emargement create
   */
  export type EmargementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * The data needed to create a Emargement.
     */
    data: XOR<EmargementCreateInput, EmargementUncheckedCreateInput>
  }

  /**
   * Emargement createMany
   */
  export type EmargementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emargements.
     */
    data: EmargementCreateManyInput | EmargementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emargement createManyAndReturn
   */
  export type EmargementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * The data used to create many Emargements.
     */
    data: EmargementCreateManyInput | EmargementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emargement update
   */
  export type EmargementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * The data needed to update a Emargement.
     */
    data: XOR<EmargementUpdateInput, EmargementUncheckedUpdateInput>
    /**
     * Choose, which Emargement to update.
     */
    where: EmargementWhereUniqueInput
  }

  /**
   * Emargement updateMany
   */
  export type EmargementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emargements.
     */
    data: XOR<EmargementUpdateManyMutationInput, EmargementUncheckedUpdateManyInput>
    /**
     * Filter which Emargements to update
     */
    where?: EmargementWhereInput
    /**
     * Limit how many Emargements to update.
     */
    limit?: number
  }

  /**
   * Emargement updateManyAndReturn
   */
  export type EmargementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * The data used to update Emargements.
     */
    data: XOR<EmargementUpdateManyMutationInput, EmargementUncheckedUpdateManyInput>
    /**
     * Filter which Emargements to update
     */
    where?: EmargementWhereInput
    /**
     * Limit how many Emargements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emargement upsert
   */
  export type EmargementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * The filter to search for the Emargement to update in case it exists.
     */
    where: EmargementWhereUniqueInput
    /**
     * In case the Emargement found by the `where` argument doesn't exist, create a new Emargement with this data.
     */
    create: XOR<EmargementCreateInput, EmargementUncheckedCreateInput>
    /**
     * In case the Emargement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmargementUpdateInput, EmargementUncheckedUpdateInput>
  }

  /**
   * Emargement delete
   */
  export type EmargementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
    /**
     * Filter which Emargement to delete.
     */
    where: EmargementWhereUniqueInput
  }

  /**
   * Emargement deleteMany
   */
  export type EmargementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emargements to delete
     */
    where?: EmargementWhereInput
    /**
     * Limit how many Emargements to delete.
     */
    limit?: number
  }

  /**
   * Emargement without action
   */
  export type EmargementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emargement
     */
    select?: EmargementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emargement
     */
    omit?: EmargementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmargementInclude<ExtArgs> | null
  }


  /**
   * Model VisiteTerrain
   */

  export type AggregateVisiteTerrain = {
    _count: VisiteTerrainCountAggregateOutputType | null
    _min: VisiteTerrainMinAggregateOutputType | null
    _max: VisiteTerrainMaxAggregateOutputType | null
  }

  export type VisiteTerrainMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    observations: string | null
    usersId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisiteTerrainMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    observations: string | null
    usersId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisiteTerrainCountAggregateOutputType = {
    id: number
    visitId: number
    observations: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisiteTerrainMinAggregateInputType = {
    id?: true
    visitId?: true
    observations?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisiteTerrainMaxAggregateInputType = {
    id?: true
    visitId?: true
    observations?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisiteTerrainCountAggregateInputType = {
    id?: true
    visitId?: true
    observations?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisiteTerrainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisiteTerrain to aggregate.
     */
    where?: VisiteTerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisiteTerrains to fetch.
     */
    orderBy?: VisiteTerrainOrderByWithRelationInput | VisiteTerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisiteTerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisiteTerrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisiteTerrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisiteTerrains
    **/
    _count?: true | VisiteTerrainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisiteTerrainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisiteTerrainMaxAggregateInputType
  }

  export type GetVisiteTerrainAggregateType<T extends VisiteTerrainAggregateArgs> = {
        [P in keyof T & keyof AggregateVisiteTerrain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisiteTerrain[P]>
      : GetScalarType<T[P], AggregateVisiteTerrain[P]>
  }




  export type VisiteTerrainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisiteTerrainWhereInput
    orderBy?: VisiteTerrainOrderByWithAggregationInput | VisiteTerrainOrderByWithAggregationInput[]
    by: VisiteTerrainScalarFieldEnum[] | VisiteTerrainScalarFieldEnum
    having?: VisiteTerrainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisiteTerrainCountAggregateInputType | true
    _min?: VisiteTerrainMinAggregateInputType
    _max?: VisiteTerrainMaxAggregateInputType
  }

  export type VisiteTerrainGroupByOutputType = {
    id: string
    visitId: string
    observations: string
    usersId: string
    createdAt: Date
    updatedAt: Date
    _count: VisiteTerrainCountAggregateOutputType | null
    _min: VisiteTerrainMinAggregateOutputType | null
    _max: VisiteTerrainMaxAggregateOutputType | null
  }

  type GetVisiteTerrainGroupByPayload<T extends VisiteTerrainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisiteTerrainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisiteTerrainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisiteTerrainGroupByOutputType[P]>
            : GetScalarType<T[P], VisiteTerrainGroupByOutputType[P]>
        }
      >
    >


  export type VisiteTerrainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    observations?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | VisitsDefaultArgs<ExtArgs>
    personnes?: boolean | VisiteTerrain$personnesArgs<ExtArgs>
    files?: boolean | VisiteTerrain$filesArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | VisiteTerrainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visiteTerrain"]>

  export type VisiteTerrainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    observations?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | VisitsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visiteTerrain"]>

  export type VisiteTerrainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    observations?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | VisitsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visiteTerrain"]>

  export type VisiteTerrainSelectScalar = {
    id?: boolean
    visitId?: boolean
    observations?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisiteTerrainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "visitId" | "observations" | "usersId" | "createdAt" | "updatedAt", ExtArgs["result"]["visiteTerrain"]>
  export type VisiteTerrainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitsDefaultArgs<ExtArgs>
    personnes?: boolean | VisiteTerrain$personnesArgs<ExtArgs>
    files?: boolean | VisiteTerrain$filesArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | VisiteTerrainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisiteTerrainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type VisiteTerrainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $VisiteTerrainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisiteTerrain"
    objects: {
      visit: Prisma.$VisitsPayload<ExtArgs>
      personnes: Prisma.$PersonnesPayload<ExtArgs>[]
      files: Prisma.$FilesPayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      observations: string
      usersId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visiteTerrain"]>
    composites: {}
  }

  type VisiteTerrainGetPayload<S extends boolean | null | undefined | VisiteTerrainDefaultArgs> = $Result.GetResult<Prisma.$VisiteTerrainPayload, S>

  type VisiteTerrainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisiteTerrainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisiteTerrainCountAggregateInputType | true
    }

  export interface VisiteTerrainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisiteTerrain'], meta: { name: 'VisiteTerrain' } }
    /**
     * Find zero or one VisiteTerrain that matches the filter.
     * @param {VisiteTerrainFindUniqueArgs} args - Arguments to find a VisiteTerrain
     * @example
     * // Get one VisiteTerrain
     * const visiteTerrain = await prisma.visiteTerrain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisiteTerrainFindUniqueArgs>(args: SelectSubset<T, VisiteTerrainFindUniqueArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisiteTerrain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisiteTerrainFindUniqueOrThrowArgs} args - Arguments to find a VisiteTerrain
     * @example
     * // Get one VisiteTerrain
     * const visiteTerrain = await prisma.visiteTerrain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisiteTerrainFindUniqueOrThrowArgs>(args: SelectSubset<T, VisiteTerrainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisiteTerrain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainFindFirstArgs} args - Arguments to find a VisiteTerrain
     * @example
     * // Get one VisiteTerrain
     * const visiteTerrain = await prisma.visiteTerrain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisiteTerrainFindFirstArgs>(args?: SelectSubset<T, VisiteTerrainFindFirstArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisiteTerrain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainFindFirstOrThrowArgs} args - Arguments to find a VisiteTerrain
     * @example
     * // Get one VisiteTerrain
     * const visiteTerrain = await prisma.visiteTerrain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisiteTerrainFindFirstOrThrowArgs>(args?: SelectSubset<T, VisiteTerrainFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisiteTerrains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisiteTerrains
     * const visiteTerrains = await prisma.visiteTerrain.findMany()
     * 
     * // Get first 10 VisiteTerrains
     * const visiteTerrains = await prisma.visiteTerrain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visiteTerrainWithIdOnly = await prisma.visiteTerrain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisiteTerrainFindManyArgs>(args?: SelectSubset<T, VisiteTerrainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisiteTerrain.
     * @param {VisiteTerrainCreateArgs} args - Arguments to create a VisiteTerrain.
     * @example
     * // Create one VisiteTerrain
     * const VisiteTerrain = await prisma.visiteTerrain.create({
     *   data: {
     *     // ... data to create a VisiteTerrain
     *   }
     * })
     * 
     */
    create<T extends VisiteTerrainCreateArgs>(args: SelectSubset<T, VisiteTerrainCreateArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisiteTerrains.
     * @param {VisiteTerrainCreateManyArgs} args - Arguments to create many VisiteTerrains.
     * @example
     * // Create many VisiteTerrains
     * const visiteTerrain = await prisma.visiteTerrain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisiteTerrainCreateManyArgs>(args?: SelectSubset<T, VisiteTerrainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisiteTerrains and returns the data saved in the database.
     * @param {VisiteTerrainCreateManyAndReturnArgs} args - Arguments to create many VisiteTerrains.
     * @example
     * // Create many VisiteTerrains
     * const visiteTerrain = await prisma.visiteTerrain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisiteTerrains and only return the `id`
     * const visiteTerrainWithIdOnly = await prisma.visiteTerrain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisiteTerrainCreateManyAndReturnArgs>(args?: SelectSubset<T, VisiteTerrainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisiteTerrain.
     * @param {VisiteTerrainDeleteArgs} args - Arguments to delete one VisiteTerrain.
     * @example
     * // Delete one VisiteTerrain
     * const VisiteTerrain = await prisma.visiteTerrain.delete({
     *   where: {
     *     // ... filter to delete one VisiteTerrain
     *   }
     * })
     * 
     */
    delete<T extends VisiteTerrainDeleteArgs>(args: SelectSubset<T, VisiteTerrainDeleteArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisiteTerrain.
     * @param {VisiteTerrainUpdateArgs} args - Arguments to update one VisiteTerrain.
     * @example
     * // Update one VisiteTerrain
     * const visiteTerrain = await prisma.visiteTerrain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisiteTerrainUpdateArgs>(args: SelectSubset<T, VisiteTerrainUpdateArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisiteTerrains.
     * @param {VisiteTerrainDeleteManyArgs} args - Arguments to filter VisiteTerrains to delete.
     * @example
     * // Delete a few VisiteTerrains
     * const { count } = await prisma.visiteTerrain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisiteTerrainDeleteManyArgs>(args?: SelectSubset<T, VisiteTerrainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisiteTerrains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisiteTerrains
     * const visiteTerrain = await prisma.visiteTerrain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisiteTerrainUpdateManyArgs>(args: SelectSubset<T, VisiteTerrainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisiteTerrains and returns the data updated in the database.
     * @param {VisiteTerrainUpdateManyAndReturnArgs} args - Arguments to update many VisiteTerrains.
     * @example
     * // Update many VisiteTerrains
     * const visiteTerrain = await prisma.visiteTerrain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisiteTerrains and only return the `id`
     * const visiteTerrainWithIdOnly = await prisma.visiteTerrain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisiteTerrainUpdateManyAndReturnArgs>(args: SelectSubset<T, VisiteTerrainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisiteTerrain.
     * @param {VisiteTerrainUpsertArgs} args - Arguments to update or create a VisiteTerrain.
     * @example
     * // Update or create a VisiteTerrain
     * const visiteTerrain = await prisma.visiteTerrain.upsert({
     *   create: {
     *     // ... data to create a VisiteTerrain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisiteTerrain we want to update
     *   }
     * })
     */
    upsert<T extends VisiteTerrainUpsertArgs>(args: SelectSubset<T, VisiteTerrainUpsertArgs<ExtArgs>>): Prisma__VisiteTerrainClient<$Result.GetResult<Prisma.$VisiteTerrainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisiteTerrains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainCountArgs} args - Arguments to filter VisiteTerrains to count.
     * @example
     * // Count the number of VisiteTerrains
     * const count = await prisma.visiteTerrain.count({
     *   where: {
     *     // ... the filter for the VisiteTerrains we want to count
     *   }
     * })
    **/
    count<T extends VisiteTerrainCountArgs>(
      args?: Subset<T, VisiteTerrainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisiteTerrainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisiteTerrain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisiteTerrainAggregateArgs>(args: Subset<T, VisiteTerrainAggregateArgs>): Prisma.PrismaPromise<GetVisiteTerrainAggregateType<T>>

    /**
     * Group by VisiteTerrain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisiteTerrainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisiteTerrainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisiteTerrainGroupByArgs['orderBy'] }
        : { orderBy?: VisiteTerrainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisiteTerrainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisiteTerrainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisiteTerrain model
   */
  readonly fields: VisiteTerrainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisiteTerrain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisiteTerrainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitsDefaultArgs<ExtArgs>>): Prisma__VisitsClient<$Result.GetResult<Prisma.$VisitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personnes<T extends VisiteTerrain$personnesArgs<ExtArgs> = {}>(args?: Subset<T, VisiteTerrain$personnesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends VisiteTerrain$filesArgs<ExtArgs> = {}>(args?: Subset<T, VisiteTerrain$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisiteTerrain model
   */
  interface VisiteTerrainFieldRefs {
    readonly id: FieldRef<"VisiteTerrain", 'String'>
    readonly visitId: FieldRef<"VisiteTerrain", 'String'>
    readonly observations: FieldRef<"VisiteTerrain", 'String'>
    readonly usersId: FieldRef<"VisiteTerrain", 'String'>
    readonly createdAt: FieldRef<"VisiteTerrain", 'DateTime'>
    readonly updatedAt: FieldRef<"VisiteTerrain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisiteTerrain findUnique
   */
  export type VisiteTerrainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * Filter, which VisiteTerrain to fetch.
     */
    where: VisiteTerrainWhereUniqueInput
  }

  /**
   * VisiteTerrain findUniqueOrThrow
   */
  export type VisiteTerrainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * Filter, which VisiteTerrain to fetch.
     */
    where: VisiteTerrainWhereUniqueInput
  }

  /**
   * VisiteTerrain findFirst
   */
  export type VisiteTerrainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * Filter, which VisiteTerrain to fetch.
     */
    where?: VisiteTerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisiteTerrains to fetch.
     */
    orderBy?: VisiteTerrainOrderByWithRelationInput | VisiteTerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisiteTerrains.
     */
    cursor?: VisiteTerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisiteTerrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisiteTerrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisiteTerrains.
     */
    distinct?: VisiteTerrainScalarFieldEnum | VisiteTerrainScalarFieldEnum[]
  }

  /**
   * VisiteTerrain findFirstOrThrow
   */
  export type VisiteTerrainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * Filter, which VisiteTerrain to fetch.
     */
    where?: VisiteTerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisiteTerrains to fetch.
     */
    orderBy?: VisiteTerrainOrderByWithRelationInput | VisiteTerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisiteTerrains.
     */
    cursor?: VisiteTerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisiteTerrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisiteTerrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisiteTerrains.
     */
    distinct?: VisiteTerrainScalarFieldEnum | VisiteTerrainScalarFieldEnum[]
  }

  /**
   * VisiteTerrain findMany
   */
  export type VisiteTerrainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * Filter, which VisiteTerrains to fetch.
     */
    where?: VisiteTerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisiteTerrains to fetch.
     */
    orderBy?: VisiteTerrainOrderByWithRelationInput | VisiteTerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisiteTerrains.
     */
    cursor?: VisiteTerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisiteTerrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisiteTerrains.
     */
    skip?: number
    distinct?: VisiteTerrainScalarFieldEnum | VisiteTerrainScalarFieldEnum[]
  }

  /**
   * VisiteTerrain create
   */
  export type VisiteTerrainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * The data needed to create a VisiteTerrain.
     */
    data: XOR<VisiteTerrainCreateInput, VisiteTerrainUncheckedCreateInput>
  }

  /**
   * VisiteTerrain createMany
   */
  export type VisiteTerrainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisiteTerrains.
     */
    data: VisiteTerrainCreateManyInput | VisiteTerrainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisiteTerrain createManyAndReturn
   */
  export type VisiteTerrainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * The data used to create many VisiteTerrains.
     */
    data: VisiteTerrainCreateManyInput | VisiteTerrainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisiteTerrain update
   */
  export type VisiteTerrainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * The data needed to update a VisiteTerrain.
     */
    data: XOR<VisiteTerrainUpdateInput, VisiteTerrainUncheckedUpdateInput>
    /**
     * Choose, which VisiteTerrain to update.
     */
    where: VisiteTerrainWhereUniqueInput
  }

  /**
   * VisiteTerrain updateMany
   */
  export type VisiteTerrainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisiteTerrains.
     */
    data: XOR<VisiteTerrainUpdateManyMutationInput, VisiteTerrainUncheckedUpdateManyInput>
    /**
     * Filter which VisiteTerrains to update
     */
    where?: VisiteTerrainWhereInput
    /**
     * Limit how many VisiteTerrains to update.
     */
    limit?: number
  }

  /**
   * VisiteTerrain updateManyAndReturn
   */
  export type VisiteTerrainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * The data used to update VisiteTerrains.
     */
    data: XOR<VisiteTerrainUpdateManyMutationInput, VisiteTerrainUncheckedUpdateManyInput>
    /**
     * Filter which VisiteTerrains to update
     */
    where?: VisiteTerrainWhereInput
    /**
     * Limit how many VisiteTerrains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisiteTerrain upsert
   */
  export type VisiteTerrainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * The filter to search for the VisiteTerrain to update in case it exists.
     */
    where: VisiteTerrainWhereUniqueInput
    /**
     * In case the VisiteTerrain found by the `where` argument doesn't exist, create a new VisiteTerrain with this data.
     */
    create: XOR<VisiteTerrainCreateInput, VisiteTerrainUncheckedCreateInput>
    /**
     * In case the VisiteTerrain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisiteTerrainUpdateInput, VisiteTerrainUncheckedUpdateInput>
  }

  /**
   * VisiteTerrain delete
   */
  export type VisiteTerrainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
    /**
     * Filter which VisiteTerrain to delete.
     */
    where: VisiteTerrainWhereUniqueInput
  }

  /**
   * VisiteTerrain deleteMany
   */
  export type VisiteTerrainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisiteTerrains to delete
     */
    where?: VisiteTerrainWhereInput
    /**
     * Limit how many VisiteTerrains to delete.
     */
    limit?: number
  }

  /**
   * VisiteTerrain.personnes
   */
  export type VisiteTerrain$personnesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    where?: PersonnesWhereInput
    orderBy?: PersonnesOrderByWithRelationInput | PersonnesOrderByWithRelationInput[]
    cursor?: PersonnesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnesScalarFieldEnum | PersonnesScalarFieldEnum[]
  }

  /**
   * VisiteTerrain.files
   */
  export type VisiteTerrain$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    cursor?: FilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * VisiteTerrain without action
   */
  export type VisiteTerrainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisiteTerrain
     */
    select?: VisiteTerrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisiteTerrain
     */
    omit?: VisiteTerrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisiteTerrainInclude<ExtArgs> | null
  }


  /**
   * Model Conflit
   */

  export type AggregateConflit = {
    _count: ConflitCountAggregateOutputType | null
    _min: ConflitMinAggregateOutputType | null
    _max: ConflitMaxAggregateOutputType | null
  }

  export type ConflitMinAggregateOutputType = {
    id: string | null
    nature: string | null
    resolution: string | null
    usersId: string | null
    status: boolean | null
    accompanimentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConflitMaxAggregateOutputType = {
    id: string | null
    nature: string | null
    resolution: string | null
    usersId: string | null
    status: boolean | null
    accompanimentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConflitCountAggregateOutputType = {
    id: number
    nature: number
    resolution: number
    usersId: number
    status: number
    accompanimentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConflitMinAggregateInputType = {
    id?: true
    nature?: true
    resolution?: true
    usersId?: true
    status?: true
    accompanimentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConflitMaxAggregateInputType = {
    id?: true
    nature?: true
    resolution?: true
    usersId?: true
    status?: true
    accompanimentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConflitCountAggregateInputType = {
    id?: true
    nature?: true
    resolution?: true
    usersId?: true
    status?: true
    accompanimentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConflitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conflit to aggregate.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conflits
    **/
    _count?: true | ConflitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConflitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConflitMaxAggregateInputType
  }

  export type GetConflitAggregateType<T extends ConflitAggregateArgs> = {
        [P in keyof T & keyof AggregateConflit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConflit[P]>
      : GetScalarType<T[P], AggregateConflit[P]>
  }




  export type ConflitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflitWhereInput
    orderBy?: ConflitOrderByWithAggregationInput | ConflitOrderByWithAggregationInput[]
    by: ConflitScalarFieldEnum[] | ConflitScalarFieldEnum
    having?: ConflitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConflitCountAggregateInputType | true
    _min?: ConflitMinAggregateInputType
    _max?: ConflitMaxAggregateInputType
  }

  export type ConflitGroupByOutputType = {
    id: string
    nature: string
    resolution: string
    usersId: string
    status: boolean
    accompanimentId: string
    createdAt: Date
    updatedAt: Date
    _count: ConflitCountAggregateOutputType | null
    _min: ConflitMinAggregateOutputType | null
    _max: ConflitMaxAggregateOutputType | null
  }

  type GetConflitGroupByPayload<T extends ConflitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConflitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConflitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConflitGroupByOutputType[P]>
            : GetScalarType<T[P], ConflitGroupByOutputType[P]>
        }
      >
    >


  export type ConflitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nature?: boolean
    resolution?: boolean
    usersId?: boolean
    status?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partieImpliques?: boolean | Conflit$partieImpliquesArgs<ExtArgs>
    files?: boolean | Conflit$filesArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    _count?: boolean | ConflitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conflit"]>

  export type ConflitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nature?: boolean
    resolution?: boolean
    usersId?: boolean
    status?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conflit"]>

  export type ConflitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nature?: boolean
    resolution?: boolean
    usersId?: boolean
    status?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conflit"]>

  export type ConflitSelectScalar = {
    id?: boolean
    nature?: boolean
    resolution?: boolean
    usersId?: boolean
    status?: boolean
    accompanimentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConflitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nature" | "resolution" | "usersId" | "status" | "accompanimentId" | "createdAt" | "updatedAt", ExtArgs["result"]["conflit"]>
  export type ConflitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partieImpliques?: boolean | Conflit$partieImpliquesArgs<ExtArgs>
    files?: boolean | Conflit$filesArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    _count?: boolean | ConflitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConflitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }
  export type ConflitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
  }

  export type $ConflitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conflit"
    objects: {
      partieImpliques: Prisma.$PersonnesPayload<ExtArgs>[]
      files: Prisma.$FilesPayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs>
      accompaniment: Prisma.$AccompanimentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nature: string
      resolution: string
      usersId: string
      status: boolean
      accompanimentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conflit"]>
    composites: {}
  }

  type ConflitGetPayload<S extends boolean | null | undefined | ConflitDefaultArgs> = $Result.GetResult<Prisma.$ConflitPayload, S>

  type ConflitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConflitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConflitCountAggregateInputType | true
    }

  export interface ConflitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conflit'], meta: { name: 'Conflit' } }
    /**
     * Find zero or one Conflit that matches the filter.
     * @param {ConflitFindUniqueArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConflitFindUniqueArgs>(args: SelectSubset<T, ConflitFindUniqueArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conflit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConflitFindUniqueOrThrowArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConflitFindUniqueOrThrowArgs>(args: SelectSubset<T, ConflitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conflit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitFindFirstArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConflitFindFirstArgs>(args?: SelectSubset<T, ConflitFindFirstArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conflit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitFindFirstOrThrowArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConflitFindFirstOrThrowArgs>(args?: SelectSubset<T, ConflitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conflits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conflits
     * const conflits = await prisma.conflit.findMany()
     * 
     * // Get first 10 Conflits
     * const conflits = await prisma.conflit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conflitWithIdOnly = await prisma.conflit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConflitFindManyArgs>(args?: SelectSubset<T, ConflitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conflit.
     * @param {ConflitCreateArgs} args - Arguments to create a Conflit.
     * @example
     * // Create one Conflit
     * const Conflit = await prisma.conflit.create({
     *   data: {
     *     // ... data to create a Conflit
     *   }
     * })
     * 
     */
    create<T extends ConflitCreateArgs>(args: SelectSubset<T, ConflitCreateArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conflits.
     * @param {ConflitCreateManyArgs} args - Arguments to create many Conflits.
     * @example
     * // Create many Conflits
     * const conflit = await prisma.conflit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConflitCreateManyArgs>(args?: SelectSubset<T, ConflitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conflits and returns the data saved in the database.
     * @param {ConflitCreateManyAndReturnArgs} args - Arguments to create many Conflits.
     * @example
     * // Create many Conflits
     * const conflit = await prisma.conflit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conflits and only return the `id`
     * const conflitWithIdOnly = await prisma.conflit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConflitCreateManyAndReturnArgs>(args?: SelectSubset<T, ConflitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conflit.
     * @param {ConflitDeleteArgs} args - Arguments to delete one Conflit.
     * @example
     * // Delete one Conflit
     * const Conflit = await prisma.conflit.delete({
     *   where: {
     *     // ... filter to delete one Conflit
     *   }
     * })
     * 
     */
    delete<T extends ConflitDeleteArgs>(args: SelectSubset<T, ConflitDeleteArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conflit.
     * @param {ConflitUpdateArgs} args - Arguments to update one Conflit.
     * @example
     * // Update one Conflit
     * const conflit = await prisma.conflit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConflitUpdateArgs>(args: SelectSubset<T, ConflitUpdateArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conflits.
     * @param {ConflitDeleteManyArgs} args - Arguments to filter Conflits to delete.
     * @example
     * // Delete a few Conflits
     * const { count } = await prisma.conflit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConflitDeleteManyArgs>(args?: SelectSubset<T, ConflitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conflits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conflits
     * const conflit = await prisma.conflit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConflitUpdateManyArgs>(args: SelectSubset<T, ConflitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conflits and returns the data updated in the database.
     * @param {ConflitUpdateManyAndReturnArgs} args - Arguments to update many Conflits.
     * @example
     * // Update many Conflits
     * const conflit = await prisma.conflit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conflits and only return the `id`
     * const conflitWithIdOnly = await prisma.conflit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConflitUpdateManyAndReturnArgs>(args: SelectSubset<T, ConflitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conflit.
     * @param {ConflitUpsertArgs} args - Arguments to update or create a Conflit.
     * @example
     * // Update or create a Conflit
     * const conflit = await prisma.conflit.upsert({
     *   create: {
     *     // ... data to create a Conflit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conflit we want to update
     *   }
     * })
     */
    upsert<T extends ConflitUpsertArgs>(args: SelectSubset<T, ConflitUpsertArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conflits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitCountArgs} args - Arguments to filter Conflits to count.
     * @example
     * // Count the number of Conflits
     * const count = await prisma.conflit.count({
     *   where: {
     *     // ... the filter for the Conflits we want to count
     *   }
     * })
    **/
    count<T extends ConflitCountArgs>(
      args?: Subset<T, ConflitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConflitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conflit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConflitAggregateArgs>(args: Subset<T, ConflitAggregateArgs>): Prisma.PrismaPromise<GetConflitAggregateType<T>>

    /**
     * Group by Conflit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConflitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConflitGroupByArgs['orderBy'] }
        : { orderBy?: ConflitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConflitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConflitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conflit model
   */
  readonly fields: ConflitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conflit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConflitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partieImpliques<T extends Conflit$partieImpliquesArgs<ExtArgs> = {}>(args?: Subset<T, Conflit$partieImpliquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Conflit$filesArgs<ExtArgs> = {}>(args?: Subset<T, Conflit$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accompaniment<T extends AccompanimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccompanimentDefaultArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conflit model
   */
  interface ConflitFieldRefs {
    readonly id: FieldRef<"Conflit", 'String'>
    readonly nature: FieldRef<"Conflit", 'String'>
    readonly resolution: FieldRef<"Conflit", 'String'>
    readonly usersId: FieldRef<"Conflit", 'String'>
    readonly status: FieldRef<"Conflit", 'Boolean'>
    readonly accompanimentId: FieldRef<"Conflit", 'String'>
    readonly createdAt: FieldRef<"Conflit", 'DateTime'>
    readonly updatedAt: FieldRef<"Conflit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conflit findUnique
   */
  export type ConflitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit findUniqueOrThrow
   */
  export type ConflitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit findFirst
   */
  export type ConflitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conflits.
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conflits.
     */
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Conflit findFirstOrThrow
   */
  export type ConflitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conflits.
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conflits.
     */
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Conflit findMany
   */
  export type ConflitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflits to fetch.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conflits.
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Conflit create
   */
  export type ConflitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * The data needed to create a Conflit.
     */
    data: XOR<ConflitCreateInput, ConflitUncheckedCreateInput>
  }

  /**
   * Conflit createMany
   */
  export type ConflitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conflits.
     */
    data: ConflitCreateManyInput | ConflitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conflit createManyAndReturn
   */
  export type ConflitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * The data used to create many Conflits.
     */
    data: ConflitCreateManyInput | ConflitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conflit update
   */
  export type ConflitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * The data needed to update a Conflit.
     */
    data: XOR<ConflitUpdateInput, ConflitUncheckedUpdateInput>
    /**
     * Choose, which Conflit to update.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit updateMany
   */
  export type ConflitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conflits.
     */
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyInput>
    /**
     * Filter which Conflits to update
     */
    where?: ConflitWhereInput
    /**
     * Limit how many Conflits to update.
     */
    limit?: number
  }

  /**
   * Conflit updateManyAndReturn
   */
  export type ConflitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * The data used to update Conflits.
     */
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyInput>
    /**
     * Filter which Conflits to update
     */
    where?: ConflitWhereInput
    /**
     * Limit how many Conflits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conflit upsert
   */
  export type ConflitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * The filter to search for the Conflit to update in case it exists.
     */
    where: ConflitWhereUniqueInput
    /**
     * In case the Conflit found by the `where` argument doesn't exist, create a new Conflit with this data.
     */
    create: XOR<ConflitCreateInput, ConflitUncheckedCreateInput>
    /**
     * In case the Conflit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConflitUpdateInput, ConflitUncheckedUpdateInput>
  }

  /**
   * Conflit delete
   */
  export type ConflitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter which Conflit to delete.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit deleteMany
   */
  export type ConflitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conflits to delete
     */
    where?: ConflitWhereInput
    /**
     * Limit how many Conflits to delete.
     */
    limit?: number
  }

  /**
   * Conflit.partieImpliques
   */
  export type Conflit$partieImpliquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnes
     */
    select?: PersonnesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Personnes
     */
    omit?: PersonnesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnesInclude<ExtArgs> | null
    where?: PersonnesWhereInput
    orderBy?: PersonnesOrderByWithRelationInput | PersonnesOrderByWithRelationInput[]
    cursor?: PersonnesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnesScalarFieldEnum | PersonnesScalarFieldEnum[]
  }

  /**
   * Conflit.files
   */
  export type Conflit$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    cursor?: FilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Conflit without action
   */
  export type ConflitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conflit
     */
    omit?: ConflitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
  }


  /**
   * Model Rencontre
   */

  export type AggregateRencontre = {
    _count: RencontreCountAggregateOutputType | null
    _min: RencontreMinAggregateOutputType | null
    _max: RencontreMaxAggregateOutputType | null
  }

  export type RencontreMinAggregateOutputType = {
    id: string | null
    date: Date | null
    lieu: string | null
    accompanimentId: string | null
    usersId: string | null
  }

  export type RencontreMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    lieu: string | null
    accompanimentId: string | null
    usersId: string | null
  }

  export type RencontreCountAggregateOutputType = {
    id: number
    date: number
    lieu: number
    order: number
    decisions: number
    actions: number
    accompanimentId: number
    usersId: number
    _all: number
  }


  export type RencontreMinAggregateInputType = {
    id?: true
    date?: true
    lieu?: true
    accompanimentId?: true
    usersId?: true
  }

  export type RencontreMaxAggregateInputType = {
    id?: true
    date?: true
    lieu?: true
    accompanimentId?: true
    usersId?: true
  }

  export type RencontreCountAggregateInputType = {
    id?: true
    date?: true
    lieu?: true
    order?: true
    decisions?: true
    actions?: true
    accompanimentId?: true
    usersId?: true
    _all?: true
  }

  export type RencontreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rencontre to aggregate.
     */
    where?: RencontreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rencontres to fetch.
     */
    orderBy?: RencontreOrderByWithRelationInput | RencontreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RencontreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rencontres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rencontres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rencontres
    **/
    _count?: true | RencontreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RencontreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RencontreMaxAggregateInputType
  }

  export type GetRencontreAggregateType<T extends RencontreAggregateArgs> = {
        [P in keyof T & keyof AggregateRencontre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRencontre[P]>
      : GetScalarType<T[P], AggregateRencontre[P]>
  }




  export type RencontreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RencontreWhereInput
    orderBy?: RencontreOrderByWithAggregationInput | RencontreOrderByWithAggregationInput[]
    by: RencontreScalarFieldEnum[] | RencontreScalarFieldEnum
    having?: RencontreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RencontreCountAggregateInputType | true
    _min?: RencontreMinAggregateInputType
    _max?: RencontreMaxAggregateInputType
  }

  export type RencontreGroupByOutputType = {
    id: string
    date: Date
    lieu: string
    order: string[]
    decisions: string[]
    actions: string[]
    accompanimentId: string
    usersId: string
    _count: RencontreCountAggregateOutputType | null
    _min: RencontreMinAggregateOutputType | null
    _max: RencontreMaxAggregateOutputType | null
  }

  type GetRencontreGroupByPayload<T extends RencontreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RencontreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RencontreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RencontreGroupByOutputType[P]>
            : GetScalarType<T[P], RencontreGroupByOutputType[P]>
        }
      >
    >


  export type RencontreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    lieu?: boolean
    order?: boolean
    decisions?: boolean
    actions?: boolean
    accompanimentId?: boolean
    usersId?: boolean
    signatures?: boolean | Rencontre$signaturesArgs<ExtArgs>
    files?: boolean | Rencontre$filesArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | RencontreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rencontre"]>

  export type RencontreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    lieu?: boolean
    order?: boolean
    decisions?: boolean
    actions?: boolean
    accompanimentId?: boolean
    usersId?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rencontre"]>

  export type RencontreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    lieu?: boolean
    order?: boolean
    decisions?: boolean
    actions?: boolean
    accompanimentId?: boolean
    usersId?: boolean
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rencontre"]>

  export type RencontreSelectScalar = {
    id?: boolean
    date?: boolean
    lieu?: boolean
    order?: boolean
    decisions?: boolean
    actions?: boolean
    accompanimentId?: boolean
    usersId?: boolean
  }

  export type RencontreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "lieu" | "order" | "decisions" | "actions" | "accompanimentId" | "usersId", ExtArgs["result"]["rencontre"]>
  export type RencontreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signatures?: boolean | Rencontre$signaturesArgs<ExtArgs>
    files?: boolean | Rencontre$filesArgs<ExtArgs>
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | RencontreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RencontreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type RencontreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accompaniment?: boolean | AccompanimentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $RencontrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rencontre"
    objects: {
      signatures: Prisma.$SignaturePayload<ExtArgs>[]
      files: Prisma.$FilesPayload<ExtArgs>[]
      accompaniment: Prisma.$AccompanimentPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      lieu: string
      order: string[]
      decisions: string[]
      actions: string[]
      accompanimentId: string
      usersId: string
    }, ExtArgs["result"]["rencontre"]>
    composites: {}
  }

  type RencontreGetPayload<S extends boolean | null | undefined | RencontreDefaultArgs> = $Result.GetResult<Prisma.$RencontrePayload, S>

  type RencontreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RencontreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RencontreCountAggregateInputType | true
    }

  export interface RencontreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rencontre'], meta: { name: 'Rencontre' } }
    /**
     * Find zero or one Rencontre that matches the filter.
     * @param {RencontreFindUniqueArgs} args - Arguments to find a Rencontre
     * @example
     * // Get one Rencontre
     * const rencontre = await prisma.rencontre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RencontreFindUniqueArgs>(args: SelectSubset<T, RencontreFindUniqueArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rencontre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RencontreFindUniqueOrThrowArgs} args - Arguments to find a Rencontre
     * @example
     * // Get one Rencontre
     * const rencontre = await prisma.rencontre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RencontreFindUniqueOrThrowArgs>(args: SelectSubset<T, RencontreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rencontre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreFindFirstArgs} args - Arguments to find a Rencontre
     * @example
     * // Get one Rencontre
     * const rencontre = await prisma.rencontre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RencontreFindFirstArgs>(args?: SelectSubset<T, RencontreFindFirstArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rencontre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreFindFirstOrThrowArgs} args - Arguments to find a Rencontre
     * @example
     * // Get one Rencontre
     * const rencontre = await prisma.rencontre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RencontreFindFirstOrThrowArgs>(args?: SelectSubset<T, RencontreFindFirstOrThrowArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rencontres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rencontres
     * const rencontres = await prisma.rencontre.findMany()
     * 
     * // Get first 10 Rencontres
     * const rencontres = await prisma.rencontre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rencontreWithIdOnly = await prisma.rencontre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RencontreFindManyArgs>(args?: SelectSubset<T, RencontreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rencontre.
     * @param {RencontreCreateArgs} args - Arguments to create a Rencontre.
     * @example
     * // Create one Rencontre
     * const Rencontre = await prisma.rencontre.create({
     *   data: {
     *     // ... data to create a Rencontre
     *   }
     * })
     * 
     */
    create<T extends RencontreCreateArgs>(args: SelectSubset<T, RencontreCreateArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rencontres.
     * @param {RencontreCreateManyArgs} args - Arguments to create many Rencontres.
     * @example
     * // Create many Rencontres
     * const rencontre = await prisma.rencontre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RencontreCreateManyArgs>(args?: SelectSubset<T, RencontreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rencontres and returns the data saved in the database.
     * @param {RencontreCreateManyAndReturnArgs} args - Arguments to create many Rencontres.
     * @example
     * // Create many Rencontres
     * const rencontre = await prisma.rencontre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rencontres and only return the `id`
     * const rencontreWithIdOnly = await prisma.rencontre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RencontreCreateManyAndReturnArgs>(args?: SelectSubset<T, RencontreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rencontre.
     * @param {RencontreDeleteArgs} args - Arguments to delete one Rencontre.
     * @example
     * // Delete one Rencontre
     * const Rencontre = await prisma.rencontre.delete({
     *   where: {
     *     // ... filter to delete one Rencontre
     *   }
     * })
     * 
     */
    delete<T extends RencontreDeleteArgs>(args: SelectSubset<T, RencontreDeleteArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rencontre.
     * @param {RencontreUpdateArgs} args - Arguments to update one Rencontre.
     * @example
     * // Update one Rencontre
     * const rencontre = await prisma.rencontre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RencontreUpdateArgs>(args: SelectSubset<T, RencontreUpdateArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rencontres.
     * @param {RencontreDeleteManyArgs} args - Arguments to filter Rencontres to delete.
     * @example
     * // Delete a few Rencontres
     * const { count } = await prisma.rencontre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RencontreDeleteManyArgs>(args?: SelectSubset<T, RencontreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rencontres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rencontres
     * const rencontre = await prisma.rencontre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RencontreUpdateManyArgs>(args: SelectSubset<T, RencontreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rencontres and returns the data updated in the database.
     * @param {RencontreUpdateManyAndReturnArgs} args - Arguments to update many Rencontres.
     * @example
     * // Update many Rencontres
     * const rencontre = await prisma.rencontre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rencontres and only return the `id`
     * const rencontreWithIdOnly = await prisma.rencontre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RencontreUpdateManyAndReturnArgs>(args: SelectSubset<T, RencontreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rencontre.
     * @param {RencontreUpsertArgs} args - Arguments to update or create a Rencontre.
     * @example
     * // Update or create a Rencontre
     * const rencontre = await prisma.rencontre.upsert({
     *   create: {
     *     // ... data to create a Rencontre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rencontre we want to update
     *   }
     * })
     */
    upsert<T extends RencontreUpsertArgs>(args: SelectSubset<T, RencontreUpsertArgs<ExtArgs>>): Prisma__RencontreClient<$Result.GetResult<Prisma.$RencontrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rencontres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreCountArgs} args - Arguments to filter Rencontres to count.
     * @example
     * // Count the number of Rencontres
     * const count = await prisma.rencontre.count({
     *   where: {
     *     // ... the filter for the Rencontres we want to count
     *   }
     * })
    **/
    count<T extends RencontreCountArgs>(
      args?: Subset<T, RencontreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RencontreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rencontre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RencontreAggregateArgs>(args: Subset<T, RencontreAggregateArgs>): Prisma.PrismaPromise<GetRencontreAggregateType<T>>

    /**
     * Group by Rencontre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RencontreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RencontreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RencontreGroupByArgs['orderBy'] }
        : { orderBy?: RencontreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RencontreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRencontreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rencontre model
   */
  readonly fields: RencontreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rencontre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RencontreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    signatures<T extends Rencontre$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, Rencontre$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Rencontre$filesArgs<ExtArgs> = {}>(args?: Subset<T, Rencontre$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accompaniment<T extends AccompanimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccompanimentDefaultArgs<ExtArgs>>): Prisma__AccompanimentClient<$Result.GetResult<Prisma.$AccompanimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rencontre model
   */
  interface RencontreFieldRefs {
    readonly id: FieldRef<"Rencontre", 'String'>
    readonly date: FieldRef<"Rencontre", 'DateTime'>
    readonly lieu: FieldRef<"Rencontre", 'String'>
    readonly order: FieldRef<"Rencontre", 'String[]'>
    readonly decisions: FieldRef<"Rencontre", 'String[]'>
    readonly actions: FieldRef<"Rencontre", 'String[]'>
    readonly accompanimentId: FieldRef<"Rencontre", 'String'>
    readonly usersId: FieldRef<"Rencontre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rencontre findUnique
   */
  export type RencontreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * Filter, which Rencontre to fetch.
     */
    where: RencontreWhereUniqueInput
  }

  /**
   * Rencontre findUniqueOrThrow
   */
  export type RencontreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * Filter, which Rencontre to fetch.
     */
    where: RencontreWhereUniqueInput
  }

  /**
   * Rencontre findFirst
   */
  export type RencontreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * Filter, which Rencontre to fetch.
     */
    where?: RencontreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rencontres to fetch.
     */
    orderBy?: RencontreOrderByWithRelationInput | RencontreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rencontres.
     */
    cursor?: RencontreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rencontres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rencontres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rencontres.
     */
    distinct?: RencontreScalarFieldEnum | RencontreScalarFieldEnum[]
  }

  /**
   * Rencontre findFirstOrThrow
   */
  export type RencontreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * Filter, which Rencontre to fetch.
     */
    where?: RencontreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rencontres to fetch.
     */
    orderBy?: RencontreOrderByWithRelationInput | RencontreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rencontres.
     */
    cursor?: RencontreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rencontres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rencontres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rencontres.
     */
    distinct?: RencontreScalarFieldEnum | RencontreScalarFieldEnum[]
  }

  /**
   * Rencontre findMany
   */
  export type RencontreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * Filter, which Rencontres to fetch.
     */
    where?: RencontreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rencontres to fetch.
     */
    orderBy?: RencontreOrderByWithRelationInput | RencontreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rencontres.
     */
    cursor?: RencontreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rencontres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rencontres.
     */
    skip?: number
    distinct?: RencontreScalarFieldEnum | RencontreScalarFieldEnum[]
  }

  /**
   * Rencontre create
   */
  export type RencontreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * The data needed to create a Rencontre.
     */
    data: XOR<RencontreCreateInput, RencontreUncheckedCreateInput>
  }

  /**
   * Rencontre createMany
   */
  export type RencontreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rencontres.
     */
    data: RencontreCreateManyInput | RencontreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rencontre createManyAndReturn
   */
  export type RencontreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * The data used to create many Rencontres.
     */
    data: RencontreCreateManyInput | RencontreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rencontre update
   */
  export type RencontreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * The data needed to update a Rencontre.
     */
    data: XOR<RencontreUpdateInput, RencontreUncheckedUpdateInput>
    /**
     * Choose, which Rencontre to update.
     */
    where: RencontreWhereUniqueInput
  }

  /**
   * Rencontre updateMany
   */
  export type RencontreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rencontres.
     */
    data: XOR<RencontreUpdateManyMutationInput, RencontreUncheckedUpdateManyInput>
    /**
     * Filter which Rencontres to update
     */
    where?: RencontreWhereInput
    /**
     * Limit how many Rencontres to update.
     */
    limit?: number
  }

  /**
   * Rencontre updateManyAndReturn
   */
  export type RencontreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * The data used to update Rencontres.
     */
    data: XOR<RencontreUpdateManyMutationInput, RencontreUncheckedUpdateManyInput>
    /**
     * Filter which Rencontres to update
     */
    where?: RencontreWhereInput
    /**
     * Limit how many Rencontres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rencontre upsert
   */
  export type RencontreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * The filter to search for the Rencontre to update in case it exists.
     */
    where: RencontreWhereUniqueInput
    /**
     * In case the Rencontre found by the `where` argument doesn't exist, create a new Rencontre with this data.
     */
    create: XOR<RencontreCreateInput, RencontreUncheckedCreateInput>
    /**
     * In case the Rencontre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RencontreUpdateInput, RencontreUncheckedUpdateInput>
  }

  /**
   * Rencontre delete
   */
  export type RencontreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
    /**
     * Filter which Rencontre to delete.
     */
    where: RencontreWhereUniqueInput
  }

  /**
   * Rencontre deleteMany
   */
  export type RencontreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rencontres to delete
     */
    where?: RencontreWhereInput
    /**
     * Limit how many Rencontres to delete.
     */
    limit?: number
  }

  /**
   * Rencontre.signatures
   */
  export type Rencontre$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    cursor?: SignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Rencontre.files
   */
  export type Rencontre$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Files
     */
    omit?: FilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    cursor?: FilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Rencontre without action
   */
  export type RencontreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rencontre
     */
    select?: RencontreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rencontre
     */
    omit?: RencontreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RencontreInclude<ExtArgs> | null
  }


  /**
   * Model Upload
   */

  export type AggregateUpload = {
    _count: UploadCountAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  export type UploadMinAggregateOutputType = {
    id: string | null
    titre: string | null
    date: Date | null
    fileId: string | null
    userId: string | null
  }

  export type UploadMaxAggregateOutputType = {
    id: string | null
    titre: string | null
    date: Date | null
    fileId: string | null
    userId: string | null
  }

  export type UploadCountAggregateOutputType = {
    id: number
    titre: number
    date: number
    fileId: number
    userId: number
    _all: number
  }


  export type UploadMinAggregateInputType = {
    id?: true
    titre?: true
    date?: true
    fileId?: true
    userId?: true
  }

  export type UploadMaxAggregateInputType = {
    id?: true
    titre?: true
    date?: true
    fileId?: true
    userId?: true
  }

  export type UploadCountAggregateInputType = {
    id?: true
    titre?: true
    date?: true
    fileId?: true
    userId?: true
    _all?: true
  }

  export type UploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Upload to aggregate.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Uploads
    **/
    _count?: true | UploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadMaxAggregateInputType
  }

  export type GetUploadAggregateType<T extends UploadAggregateArgs> = {
        [P in keyof T & keyof AggregateUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpload[P]>
      : GetScalarType<T[P], AggregateUpload[P]>
  }




  export type UploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithAggregationInput | UploadOrderByWithAggregationInput[]
    by: UploadScalarFieldEnum[] | UploadScalarFieldEnum
    having?: UploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadCountAggregateInputType | true
    _min?: UploadMinAggregateInputType
    _max?: UploadMaxAggregateInputType
  }

  export type UploadGroupByOutputType = {
    id: string
    titre: string
    date: Date
    fileId: string
    userId: string
    _count: UploadCountAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  type GetUploadGroupByPayload<T extends UploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadGroupByOutputType[P]>
            : GetScalarType<T[P], UploadGroupByOutputType[P]>
        }
      >
    >


  export type UploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    date?: boolean
    fileId?: boolean
    userId?: boolean
    file?: boolean | FilesDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    date?: boolean
    fileId?: boolean
    userId?: boolean
    file?: boolean | FilesDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    date?: boolean
    fileId?: boolean
    userId?: boolean
    file?: boolean | FilesDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectScalar = {
    id?: boolean
    titre?: boolean
    date?: boolean
    fileId?: boolean
    userId?: boolean
  }

  export type UploadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titre" | "date" | "fileId" | "userId", ExtArgs["result"]["upload"]>
  export type UploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FilesDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type UploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FilesDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type UploadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FilesDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Upload"
    objects: {
      file: Prisma.$FilesPayload<ExtArgs>
      user: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titre: string
      date: Date
      fileId: string
      userId: string
    }, ExtArgs["result"]["upload"]>
    composites: {}
  }

  type UploadGetPayload<S extends boolean | null | undefined | UploadDefaultArgs> = $Result.GetResult<Prisma.$UploadPayload, S>

  type UploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UploadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UploadCountAggregateInputType | true
    }

  export interface UploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Upload'], meta: { name: 'Upload' } }
    /**
     * Find zero or one Upload that matches the filter.
     * @param {UploadFindUniqueArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadFindUniqueArgs>(args: SelectSubset<T, UploadFindUniqueArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Upload that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UploadFindUniqueOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadFindFirstArgs>(args?: SelectSubset<T, UploadFindFirstArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uploads
     * const uploads = await prisma.upload.findMany()
     * 
     * // Get first 10 Uploads
     * const uploads = await prisma.upload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadWithIdOnly = await prisma.upload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadFindManyArgs>(args?: SelectSubset<T, UploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Upload.
     * @param {UploadCreateArgs} args - Arguments to create a Upload.
     * @example
     * // Create one Upload
     * const Upload = await prisma.upload.create({
     *   data: {
     *     // ... data to create a Upload
     *   }
     * })
     * 
     */
    create<T extends UploadCreateArgs>(args: SelectSubset<T, UploadCreateArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uploads.
     * @param {UploadCreateManyArgs} args - Arguments to create many Uploads.
     * @example
     * // Create many Uploads
     * const upload = await prisma.upload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadCreateManyArgs>(args?: SelectSubset<T, UploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Uploads and returns the data saved in the database.
     * @param {UploadCreateManyAndReturnArgs} args - Arguments to create many Uploads.
     * @example
     * // Create many Uploads
     * const upload = await prisma.upload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Uploads and only return the `id`
     * const uploadWithIdOnly = await prisma.upload.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Upload.
     * @param {UploadDeleteArgs} args - Arguments to delete one Upload.
     * @example
     * // Delete one Upload
     * const Upload = await prisma.upload.delete({
     *   where: {
     *     // ... filter to delete one Upload
     *   }
     * })
     * 
     */
    delete<T extends UploadDeleteArgs>(args: SelectSubset<T, UploadDeleteArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Upload.
     * @param {UploadUpdateArgs} args - Arguments to update one Upload.
     * @example
     * // Update one Upload
     * const upload = await prisma.upload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadUpdateArgs>(args: SelectSubset<T, UploadUpdateArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uploads.
     * @param {UploadDeleteManyArgs} args - Arguments to filter Uploads to delete.
     * @example
     * // Delete a few Uploads
     * const { count } = await prisma.upload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadDeleteManyArgs>(args?: SelectSubset<T, UploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadUpdateManyArgs>(args: SelectSubset<T, UploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads and returns the data updated in the database.
     * @param {UploadUpdateManyAndReturnArgs} args - Arguments to update many Uploads.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Uploads and only return the `id`
     * const uploadWithIdOnly = await prisma.upload.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UploadUpdateManyAndReturnArgs>(args: SelectSubset<T, UploadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Upload.
     * @param {UploadUpsertArgs} args - Arguments to update or create a Upload.
     * @example
     * // Update or create a Upload
     * const upload = await prisma.upload.upsert({
     *   create: {
     *     // ... data to create a Upload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upload we want to update
     *   }
     * })
     */
    upsert<T extends UploadUpsertArgs>(args: SelectSubset<T, UploadUpsertArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadCountArgs} args - Arguments to filter Uploads to count.
     * @example
     * // Count the number of Uploads
     * const count = await prisma.upload.count({
     *   where: {
     *     // ... the filter for the Uploads we want to count
     *   }
     * })
    **/
    count<T extends UploadCountArgs>(
      args?: Subset<T, UploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadAggregateArgs>(args: Subset<T, UploadAggregateArgs>): Prisma.PrismaPromise<GetUploadAggregateType<T>>

    /**
     * Group by Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadGroupByArgs['orderBy'] }
        : { orderBy?: UploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Upload model
   */
  readonly fields: UploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Upload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FilesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilesDefaultArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Upload model
   */
  interface UploadFieldRefs {
    readonly id: FieldRef<"Upload", 'String'>
    readonly titre: FieldRef<"Upload", 'String'>
    readonly date: FieldRef<"Upload", 'DateTime'>
    readonly fileId: FieldRef<"Upload", 'String'>
    readonly userId: FieldRef<"Upload", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Upload findUnique
   */
  export type UploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findUniqueOrThrow
   */
  export type UploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findFirst
   */
  export type UploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload findFirstOrThrow
   */
  export type UploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload findMany
   */
  export type UploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Uploads to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload create
   */
  export type UploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The data needed to create a Upload.
     */
    data: XOR<UploadCreateInput, UploadUncheckedCreateInput>
  }

  /**
   * Upload createMany
   */
  export type UploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Uploads.
     */
    data: UploadCreateManyInput | UploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Upload createManyAndReturn
   */
  export type UploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * The data used to create many Uploads.
     */
    data: UploadCreateManyInput | UploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Upload update
   */
  export type UploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The data needed to update a Upload.
     */
    data: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
    /**
     * Choose, which Upload to update.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload updateMany
   */
  export type UploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to update.
     */
    limit?: number
  }

  /**
   * Upload updateManyAndReturn
   */
  export type UploadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Upload upsert
   */
  export type UploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The filter to search for the Upload to update in case it exists.
     */
    where: UploadWhereUniqueInput
    /**
     * In case the Upload found by the `where` argument doesn't exist, create a new Upload with this data.
     */
    create: XOR<UploadCreateInput, UploadUncheckedCreateInput>
    /**
     * In case the Upload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
  }

  /**
   * Upload delete
   */
  export type UploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter which Upload to delete.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload deleteMany
   */
  export type UploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Uploads to delete
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to delete.
     */
    limit?: number
  }

  /**
   * Upload without action
   */
  export type UploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PersonnesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    signature: 'signature',
    conflitId: 'conflitId',
    visiteTerrainId: 'visiteTerrainId'
  };

  export type PersonnesScalarFieldEnum = (typeof PersonnesScalarFieldEnum)[keyof typeof PersonnesScalarFieldEnum]


  export const SignatureScalarFieldEnum: {
    id: 'id',
    date: 'date',
    present: 'present',
    memberId: 'memberId',
    rencontreId: 'rencontreId'
  };

  export type SignatureScalarFieldEnum = (typeof SignatureScalarFieldEnum)[keyof typeof SignatureScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    url: 'url',
    size: 'size',
    visiteTerrainId: 'visiteTerrainId',
    conflitId: 'conflitId',
    rencontreId: 'rencontreId'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    profile: 'profile',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    gender: 'gender',
    dob: 'dob',
    filesId: 'filesId',
    status: 'status',
    type: 'type',
    routes: 'routes',
    access: 'access',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    local: 'local',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    date: 'date',
    reason: 'reason',
    projectId: 'projectId',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const AccompanimentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    adresse: 'adresse',
    phones: 'phones',
    budget: 'budget',
    status: 'status',
    usersid: 'usersid',
    fileId: 'fileId',
    projectId: 'projectId',
    planningId: 'planningId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccompanimentScalarFieldEnum = (typeof AccompanimentScalarFieldEnum)[keyof typeof AccompanimentScalarFieldEnum]


  export const ClasseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    usersId: 'usersId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClasseScalarFieldEnum = (typeof ClasseScalarFieldEnum)[keyof typeof ClasseScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    profile: 'profile',
    name: 'name',
    phone: 'phone',
    gender: 'gender',
    dob: 'dob',
    commune: 'commune',
    residential: 'residential',
    disability: 'disability',
    language: 'language',
    attestation: 'attestation',
    accompanimentId: 'accompanimentId',
    classeId: 'classeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatParticipantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    chatId: 'chatId',
    joinedAt: 'joinedAt'
  };

  export type ChatParticipantScalarFieldEnum = (typeof ChatParticipantScalarFieldEnum)[keyof typeof ChatParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    sentAt: 'sentAt',
    senderId: 'senderId',
    chatId: 'chatId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageViewScalarFieldEnum: {
    id: 'id',
    view: 'view',
    messageId: 'messageId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageViewScalarFieldEnum = (typeof MessageViewScalarFieldEnum)[keyof typeof MessageViewScalarFieldEnum]


  export const VisitsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    location: 'location',
    objetif: 'objetif',
    planningId: 'planningId'
  };

  export type VisitsScalarFieldEnum = (typeof VisitsScalarFieldEnum)[keyof typeof VisitsScalarFieldEnum]


  export const PlanningScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId'
  };

  export type PlanningScalarFieldEnum = (typeof PlanningScalarFieldEnum)[keyof typeof PlanningScalarFieldEnum]


  export const MapsScalarFieldEnum: {
    id: 'id',
    accompanimentId: 'accompanimentId',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MapsScalarFieldEnum = (typeof MapsScalarFieldEnum)[keyof typeof MapsScalarFieldEnum]


  export const PurchaseItemsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    image: 'image',
    quantity: 'quantity',
    date: 'date',
    purchaseId: 'purchaseId'
  };

  export type PurchaseItemsScalarFieldEnum = (typeof PurchaseItemsScalarFieldEnum)[keyof typeof PurchaseItemsScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    total: 'total',
    accompanimentId: 'accompanimentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const EmargementScalarFieldEnum: {
    id: 'id',
    date: 'date',
    signature: 'signature',
    cni: 'cni',
    PhotoCni: 'PhotoCni',
    montant: 'montant',
    observations: 'observations',
    usersId: 'usersId',
    memberId: 'memberId'
  };

  export type EmargementScalarFieldEnum = (typeof EmargementScalarFieldEnum)[keyof typeof EmargementScalarFieldEnum]


  export const VisiteTerrainScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    observations: 'observations',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisiteTerrainScalarFieldEnum = (typeof VisiteTerrainScalarFieldEnum)[keyof typeof VisiteTerrainScalarFieldEnum]


  export const ConflitScalarFieldEnum: {
    id: 'id',
    nature: 'nature',
    resolution: 'resolution',
    usersId: 'usersId',
    status: 'status',
    accompanimentId: 'accompanimentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConflitScalarFieldEnum = (typeof ConflitScalarFieldEnum)[keyof typeof ConflitScalarFieldEnum]


  export const RencontreScalarFieldEnum: {
    id: 'id',
    date: 'date',
    lieu: 'lieu',
    order: 'order',
    decisions: 'decisions',
    actions: 'actions',
    accompanimentId: 'accompanimentId',
    usersId: 'usersId'
  };

  export type RencontreScalarFieldEnum = (typeof RencontreScalarFieldEnum)[keyof typeof RencontreScalarFieldEnum]


  export const UploadScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    date: 'date',
    fileId: 'fileId',
    userId: 'userId'
  };

  export type UploadScalarFieldEnum = (typeof UploadScalarFieldEnum)[keyof typeof UploadScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Type'
   */
  export type EnumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Type'>
    


  /**
   * Reference to a field of type 'Type[]'
   */
  export type ListEnumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Type[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PersonnesWhereInput = {
    AND?: PersonnesWhereInput | PersonnesWhereInput[]
    OR?: PersonnesWhereInput[]
    NOT?: PersonnesWhereInput | PersonnesWhereInput[]
    id?: UuidFilter<"Personnes"> | string
    name?: StringFilter<"Personnes"> | string
    role?: StringFilter<"Personnes"> | string
    signature?: BoolFilter<"Personnes"> | boolean
    conflitId?: UuidNullableFilter<"Personnes"> | string | null
    visiteTerrainId?: UuidNullableFilter<"Personnes"> | string | null
    Conflit?: XOR<ConflitNullableScalarRelationFilter, ConflitWhereInput> | null
    VisiteTerrain?: XOR<VisiteTerrainNullableScalarRelationFilter, VisiteTerrainWhereInput> | null
  }

  export type PersonnesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    signature?: SortOrder
    conflitId?: SortOrderInput | SortOrder
    visiteTerrainId?: SortOrderInput | SortOrder
    Conflit?: ConflitOrderByWithRelationInput
    VisiteTerrain?: VisiteTerrainOrderByWithRelationInput
  }

  export type PersonnesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonnesWhereInput | PersonnesWhereInput[]
    OR?: PersonnesWhereInput[]
    NOT?: PersonnesWhereInput | PersonnesWhereInput[]
    name?: StringFilter<"Personnes"> | string
    role?: StringFilter<"Personnes"> | string
    signature?: BoolFilter<"Personnes"> | boolean
    conflitId?: UuidNullableFilter<"Personnes"> | string | null
    visiteTerrainId?: UuidNullableFilter<"Personnes"> | string | null
    Conflit?: XOR<ConflitNullableScalarRelationFilter, ConflitWhereInput> | null
    VisiteTerrain?: XOR<VisiteTerrainNullableScalarRelationFilter, VisiteTerrainWhereInput> | null
  }, "id">

  export type PersonnesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    signature?: SortOrder
    conflitId?: SortOrderInput | SortOrder
    visiteTerrainId?: SortOrderInput | SortOrder
    _count?: PersonnesCountOrderByAggregateInput
    _max?: PersonnesMaxOrderByAggregateInput
    _min?: PersonnesMinOrderByAggregateInput
  }

  export type PersonnesScalarWhereWithAggregatesInput = {
    AND?: PersonnesScalarWhereWithAggregatesInput | PersonnesScalarWhereWithAggregatesInput[]
    OR?: PersonnesScalarWhereWithAggregatesInput[]
    NOT?: PersonnesScalarWhereWithAggregatesInput | PersonnesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Personnes"> | string
    name?: StringWithAggregatesFilter<"Personnes"> | string
    role?: StringWithAggregatesFilter<"Personnes"> | string
    signature?: BoolWithAggregatesFilter<"Personnes"> | boolean
    conflitId?: UuidNullableWithAggregatesFilter<"Personnes"> | string | null
    visiteTerrainId?: UuidNullableWithAggregatesFilter<"Personnes"> | string | null
  }

  export type SignatureWhereInput = {
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    id?: UuidFilter<"Signature"> | string
    date?: DateTimeFilter<"Signature"> | Date | string
    present?: BoolFilter<"Signature"> | boolean
    memberId?: UuidFilter<"Signature"> | string
    rencontreId?: UuidNullableFilter<"Signature"> | string | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    Rencontre?: XOR<RencontreNullableScalarRelationFilter, RencontreWhereInput> | null
  }

  export type SignatureOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    present?: SortOrder
    memberId?: SortOrder
    rencontreId?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
    Rencontre?: RencontreOrderByWithRelationInput
  }

  export type SignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    date?: DateTimeFilter<"Signature"> | Date | string
    present?: BoolFilter<"Signature"> | boolean
    memberId?: UuidFilter<"Signature"> | string
    rencontreId?: UuidNullableFilter<"Signature"> | string | null
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    Rencontre?: XOR<RencontreNullableScalarRelationFilter, RencontreWhereInput> | null
  }, "id">

  export type SignatureOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    present?: SortOrder
    memberId?: SortOrder
    rencontreId?: SortOrderInput | SortOrder
    _count?: SignatureCountOrderByAggregateInput
    _max?: SignatureMaxOrderByAggregateInput
    _min?: SignatureMinOrderByAggregateInput
  }

  export type SignatureScalarWhereWithAggregatesInput = {
    AND?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    OR?: SignatureScalarWhereWithAggregatesInput[]
    NOT?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Signature"> | string
    date?: DateTimeWithAggregatesFilter<"Signature"> | Date | string
    present?: BoolWithAggregatesFilter<"Signature"> | boolean
    memberId?: UuidWithAggregatesFilter<"Signature"> | string
    rencontreId?: UuidNullableWithAggregatesFilter<"Signature"> | string | null
  }

  export type FilesWhereInput = {
    AND?: FilesWhereInput | FilesWhereInput[]
    OR?: FilesWhereInput[]
    NOT?: FilesWhereInput | FilesWhereInput[]
    id?: UuidFilter<"Files"> | string
    name?: StringFilter<"Files"> | string
    type?: StringFilter<"Files"> | string
    url?: StringFilter<"Files"> | string
    size?: IntFilter<"Files"> | number
    visiteTerrainId?: UuidNullableFilter<"Files"> | string | null
    conflitId?: UuidNullableFilter<"Files"> | string | null
    rencontreId?: UuidNullableFilter<"Files"> | string | null
    visiteTerrain?: XOR<VisiteTerrainNullableScalarRelationFilter, VisiteTerrainWhereInput> | null
    conflit?: XOR<ConflitNullableScalarRelationFilter, ConflitWhereInput> | null
    rencontre?: XOR<RencontreNullableScalarRelationFilter, RencontreWhereInput> | null
    Upload?: UploadListRelationFilter
    Users?: UsersListRelationFilter
    accompaniments?: AccompanimentListRelationFilter
    media?: AccompanimentListRelationFilter
  }

  export type FilesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    visiteTerrainId?: SortOrderInput | SortOrder
    conflitId?: SortOrderInput | SortOrder
    rencontreId?: SortOrderInput | SortOrder
    visiteTerrain?: VisiteTerrainOrderByWithRelationInput
    conflit?: ConflitOrderByWithRelationInput
    rencontre?: RencontreOrderByWithRelationInput
    Upload?: UploadOrderByRelationAggregateInput
    Users?: UsersOrderByRelationAggregateInput
    accompaniments?: AccompanimentOrderByRelationAggregateInput
    media?: AccompanimentOrderByRelationAggregateInput
  }

  export type FilesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FilesWhereInput | FilesWhereInput[]
    OR?: FilesWhereInput[]
    NOT?: FilesWhereInput | FilesWhereInput[]
    name?: StringFilter<"Files"> | string
    type?: StringFilter<"Files"> | string
    url?: StringFilter<"Files"> | string
    size?: IntFilter<"Files"> | number
    visiteTerrainId?: UuidNullableFilter<"Files"> | string | null
    conflitId?: UuidNullableFilter<"Files"> | string | null
    rencontreId?: UuidNullableFilter<"Files"> | string | null
    visiteTerrain?: XOR<VisiteTerrainNullableScalarRelationFilter, VisiteTerrainWhereInput> | null
    conflit?: XOR<ConflitNullableScalarRelationFilter, ConflitWhereInput> | null
    rencontre?: XOR<RencontreNullableScalarRelationFilter, RencontreWhereInput> | null
    Upload?: UploadListRelationFilter
    Users?: UsersListRelationFilter
    accompaniments?: AccompanimentListRelationFilter
    media?: AccompanimentListRelationFilter
  }, "id">

  export type FilesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    visiteTerrainId?: SortOrderInput | SortOrder
    conflitId?: SortOrderInput | SortOrder
    rencontreId?: SortOrderInput | SortOrder
    _count?: FilesCountOrderByAggregateInput
    _avg?: FilesAvgOrderByAggregateInput
    _max?: FilesMaxOrderByAggregateInput
    _min?: FilesMinOrderByAggregateInput
    _sum?: FilesSumOrderByAggregateInput
  }

  export type FilesScalarWhereWithAggregatesInput = {
    AND?: FilesScalarWhereWithAggregatesInput | FilesScalarWhereWithAggregatesInput[]
    OR?: FilesScalarWhereWithAggregatesInput[]
    NOT?: FilesScalarWhereWithAggregatesInput | FilesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Files"> | string
    name?: StringWithAggregatesFilter<"Files"> | string
    type?: StringWithAggregatesFilter<"Files"> | string
    url?: StringWithAggregatesFilter<"Files"> | string
    size?: IntWithAggregatesFilter<"Files"> | number
    visiteTerrainId?: UuidNullableWithAggregatesFilter<"Files"> | string | null
    conflitId?: UuidNullableWithAggregatesFilter<"Files"> | string | null
    rencontreId?: UuidNullableWithAggregatesFilter<"Files"> | string | null
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: UuidFilter<"Users"> | string
    authId?: StringFilter<"Users"> | string
    profile?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone?: StringFilter<"Users"> | string
    address?: StringFilter<"Users"> | string
    gender?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    filesId?: UuidNullableFilter<"Users"> | string | null
    status?: EnumStatusFilter<"Users"> | $Enums.Status
    type?: EnumTypeFilter<"Users"> | $Enums.Type
    routes?: StringNullableListFilter<"Users">
    access?: StringNullableListFilter<"Users">
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    cv?: XOR<FilesNullableScalarRelationFilter, FilesWhereInput> | null
    accompaniments?: AccompanimentListRelationFilter
    plannings?: PlanningListRelationFilter
    emargements?: EmargementListRelationFilter
    visiteTerrains?: VisiteTerrainListRelationFilter
    rencontres?: RencontreListRelationFilter
    conflit?: ConflitListRelationFilter
    chatParticipant?: ChatParticipantListRelationFilter
    message?: MessageListRelationFilter
    uploads?: UploadListRelationFilter
    messageView?: MessageViewListRelationFilter
    Classe?: ClasseListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    filesId?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    routes?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cv?: FilesOrderByWithRelationInput
    accompaniments?: AccompanimentOrderByRelationAggregateInput
    plannings?: PlanningOrderByRelationAggregateInput
    emargements?: EmargementOrderByRelationAggregateInput
    visiteTerrains?: VisiteTerrainOrderByRelationAggregateInput
    rencontres?: RencontreOrderByRelationAggregateInput
    conflit?: ConflitOrderByRelationAggregateInput
    chatParticipant?: ChatParticipantOrderByRelationAggregateInput
    message?: MessageOrderByRelationAggregateInput
    uploads?: UploadOrderByRelationAggregateInput
    messageView?: MessageViewOrderByRelationAggregateInput
    Classe?: ClasseOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    profile?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    phone?: StringFilter<"Users"> | string
    address?: StringFilter<"Users"> | string
    gender?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    filesId?: UuidNullableFilter<"Users"> | string | null
    status?: EnumStatusFilter<"Users"> | $Enums.Status
    type?: EnumTypeFilter<"Users"> | $Enums.Type
    routes?: StringNullableListFilter<"Users">
    access?: StringNullableListFilter<"Users">
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    cv?: XOR<FilesNullableScalarRelationFilter, FilesWhereInput> | null
    accompaniments?: AccompanimentListRelationFilter
    plannings?: PlanningListRelationFilter
    emargements?: EmargementListRelationFilter
    visiteTerrains?: VisiteTerrainListRelationFilter
    rencontres?: RencontreListRelationFilter
    conflit?: ConflitListRelationFilter
    chatParticipant?: ChatParticipantListRelationFilter
    message?: MessageListRelationFilter
    uploads?: UploadListRelationFilter
    messageView?: MessageViewListRelationFilter
    Classe?: ClasseListRelationFilter
  }, "id" | "authId" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    filesId?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    routes?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Users"> | string
    authId?: StringWithAggregatesFilter<"Users"> | string
    profile?: StringWithAggregatesFilter<"Users"> | string
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    phone?: StringWithAggregatesFilter<"Users"> | string
    address?: StringWithAggregatesFilter<"Users"> | string
    gender?: StringWithAggregatesFilter<"Users"> | string
    dob?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    filesId?: UuidNullableWithAggregatesFilter<"Users"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Users"> | $Enums.Status
    type?: EnumTypeWithAggregatesFilter<"Users"> | $Enums.Type
    routes?: StringNullableListFilter<"Users">
    access?: StringNullableListFilter<"Users">
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: UuidFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    status?: BoolFilter<"Project"> | boolean
    local?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeFilter<"Project"> | Date | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    accompaniments?: AccompanimentListRelationFilter
    leave?: LeaveListRelationFilter
    members?: MemberListRelationFilter
    classes?: ClasseListRelationFilter
    chat?: XOR<ChatNullableScalarRelationFilter, ChatWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    local?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accompaniments?: AccompanimentOrderByRelationAggregateInput
    leave?: LeaveOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    classes?: ClasseOrderByRelationAggregateInput
    chat?: ChatOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    status?: BoolFilter<"Project"> | boolean
    local?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeFilter<"Project"> | Date | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    accompaniments?: AccompanimentListRelationFilter
    leave?: LeaveListRelationFilter
    members?: MemberListRelationFilter
    classes?: ClasseListRelationFilter
    chat?: XOR<ChatNullableScalarRelationFilter, ChatWhereInput> | null
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    local?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    status?: BoolWithAggregatesFilter<"Project"> | boolean
    local?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: UuidFilter<"Leave"> | string
    date?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringFilter<"Leave"> | string
    projectId?: UuidFilter<"Leave"> | string
    memberId?: UuidFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    projectId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId?: string
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    date?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringFilter<"Leave"> | string
    projectId?: UuidFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "memberId">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    projectId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Leave"> | string
    date?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    reason?: StringWithAggregatesFilter<"Leave"> | string
    projectId?: UuidWithAggregatesFilter<"Leave"> | string
    memberId?: UuidWithAggregatesFilter<"Leave"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
  }

  export type AccompanimentWhereInput = {
    AND?: AccompanimentWhereInput | AccompanimentWhereInput[]
    OR?: AccompanimentWhereInput[]
    NOT?: AccompanimentWhereInput | AccompanimentWhereInput[]
    id?: UuidFilter<"Accompaniment"> | string
    name?: StringFilter<"Accompaniment"> | string
    adresse?: StringFilter<"Accompaniment"> | string
    phones?: IntNullableListFilter<"Accompaniment">
    budget?: IntFilter<"Accompaniment"> | number
    status?: BoolFilter<"Accompaniment"> | boolean
    usersid?: UuidFilter<"Accompaniment"> | string
    fileId?: UuidFilter<"Accompaniment"> | string
    projectId?: UuidFilter<"Accompaniment"> | string
    planningId?: UuidNullableFilter<"Accompaniment"> | string | null
    createdAt?: DateTimeFilter<"Accompaniment"> | Date | string
    updatedAt?: DateTimeFilter<"Accompaniment"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    map?: XOR<MapsNullableScalarRelationFilter, MapsWhereInput> | null
    members?: MemberListRelationFilter
    file?: XOR<FilesScalarRelationFilter, FilesWhereInput>
    media?: FilesListRelationFilter
    purchases?: PurchaseListRelationFilter
    conflits?: ConflitListRelationFilter
    rencontre?: RencontreListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    planning?: XOR<PlanningNullableScalarRelationFilter, PlanningWhereInput> | null
  }

  export type AccompanimentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    adresse?: SortOrder
    phones?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    usersid?: SortOrder
    fileId?: SortOrder
    projectId?: SortOrder
    planningId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    map?: MapsOrderByWithRelationInput
    members?: MemberOrderByRelationAggregateInput
    file?: FilesOrderByWithRelationInput
    media?: FilesOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    conflits?: ConflitOrderByRelationAggregateInput
    rencontre?: RencontreOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    planning?: PlanningOrderByWithRelationInput
  }

  export type AccompanimentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccompanimentWhereInput | AccompanimentWhereInput[]
    OR?: AccompanimentWhereInput[]
    NOT?: AccompanimentWhereInput | AccompanimentWhereInput[]
    name?: StringFilter<"Accompaniment"> | string
    adresse?: StringFilter<"Accompaniment"> | string
    phones?: IntNullableListFilter<"Accompaniment">
    budget?: IntFilter<"Accompaniment"> | number
    status?: BoolFilter<"Accompaniment"> | boolean
    usersid?: UuidFilter<"Accompaniment"> | string
    fileId?: UuidFilter<"Accompaniment"> | string
    projectId?: UuidFilter<"Accompaniment"> | string
    planningId?: UuidNullableFilter<"Accompaniment"> | string | null
    createdAt?: DateTimeFilter<"Accompaniment"> | Date | string
    updatedAt?: DateTimeFilter<"Accompaniment"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    map?: XOR<MapsNullableScalarRelationFilter, MapsWhereInput> | null
    members?: MemberListRelationFilter
    file?: XOR<FilesScalarRelationFilter, FilesWhereInput>
    media?: FilesListRelationFilter
    purchases?: PurchaseListRelationFilter
    conflits?: ConflitListRelationFilter
    rencontre?: RencontreListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    planning?: XOR<PlanningNullableScalarRelationFilter, PlanningWhereInput> | null
  }, "id">

  export type AccompanimentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    adresse?: SortOrder
    phones?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    usersid?: SortOrder
    fileId?: SortOrder
    projectId?: SortOrder
    planningId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccompanimentCountOrderByAggregateInput
    _avg?: AccompanimentAvgOrderByAggregateInput
    _max?: AccompanimentMaxOrderByAggregateInput
    _min?: AccompanimentMinOrderByAggregateInput
    _sum?: AccompanimentSumOrderByAggregateInput
  }

  export type AccompanimentScalarWhereWithAggregatesInput = {
    AND?: AccompanimentScalarWhereWithAggregatesInput | AccompanimentScalarWhereWithAggregatesInput[]
    OR?: AccompanimentScalarWhereWithAggregatesInput[]
    NOT?: AccompanimentScalarWhereWithAggregatesInput | AccompanimentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Accompaniment"> | string
    name?: StringWithAggregatesFilter<"Accompaniment"> | string
    adresse?: StringWithAggregatesFilter<"Accompaniment"> | string
    phones?: IntNullableListFilter<"Accompaniment">
    budget?: IntWithAggregatesFilter<"Accompaniment"> | number
    status?: BoolWithAggregatesFilter<"Accompaniment"> | boolean
    usersid?: UuidWithAggregatesFilter<"Accompaniment"> | string
    fileId?: UuidWithAggregatesFilter<"Accompaniment"> | string
    projectId?: UuidWithAggregatesFilter<"Accompaniment"> | string
    planningId?: UuidNullableWithAggregatesFilter<"Accompaniment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Accompaniment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Accompaniment"> | Date | string
  }

  export type ClasseWhereInput = {
    AND?: ClasseWhereInput | ClasseWhereInput[]
    OR?: ClasseWhereInput[]
    NOT?: ClasseWhereInput | ClasseWhereInput[]
    id?: UuidFilter<"Classe"> | string
    name?: StringFilter<"Classe"> | string
    usersId?: UuidFilter<"Classe"> | string
    projectId?: UuidFilter<"Classe"> | string
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    members?: MemberListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ClasseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    usersId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    members?: MemberOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ClasseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClasseWhereInput | ClasseWhereInput[]
    OR?: ClasseWhereInput[]
    NOT?: ClasseWhereInput | ClasseWhereInput[]
    name?: StringFilter<"Classe"> | string
    usersId?: UuidFilter<"Classe"> | string
    projectId?: UuidFilter<"Classe"> | string
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    members?: MemberListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ClasseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    usersId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClasseCountOrderByAggregateInput
    _max?: ClasseMaxOrderByAggregateInput
    _min?: ClasseMinOrderByAggregateInput
  }

  export type ClasseScalarWhereWithAggregatesInput = {
    AND?: ClasseScalarWhereWithAggregatesInput | ClasseScalarWhereWithAggregatesInput[]
    OR?: ClasseScalarWhereWithAggregatesInput[]
    NOT?: ClasseScalarWhereWithAggregatesInput | ClasseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Classe"> | string
    name?: StringWithAggregatesFilter<"Classe"> | string
    usersId?: UuidWithAggregatesFilter<"Classe"> | string
    projectId?: UuidWithAggregatesFilter<"Classe"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Classe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classe"> | Date | string
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: UuidFilter<"Member"> | string
    projectId?: UuidFilter<"Member"> | string
    profile?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    phone?: StringFilter<"Member"> | string
    gender?: StringFilter<"Member"> | string
    dob?: DateTimeFilter<"Member"> | Date | string
    commune?: StringFilter<"Member"> | string
    residential?: StringFilter<"Member"> | string
    disability?: StringFilter<"Member"> | string
    language?: StringFilter<"Member"> | string
    attestation?: StringFilter<"Member"> | string
    accompanimentId?: UuidNullableFilter<"Member"> | string | null
    classeId?: UuidFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    signatures?: SignatureListRelationFilter
    emargements?: EmargementListRelationFilter
    leave?: XOR<LeaveNullableScalarRelationFilter, LeaveWhereInput> | null
    accompaniment?: XOR<AccompanimentNullableScalarRelationFilter, AccompanimentWhereInput> | null
    classe?: XOR<ClasseScalarRelationFilter, ClasseWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    commune?: SortOrder
    residential?: SortOrder
    disability?: SortOrder
    language?: SortOrder
    attestation?: SortOrder
    accompanimentId?: SortOrderInput | SortOrder
    classeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    signatures?: SignatureOrderByRelationAggregateInput
    emargements?: EmargementOrderByRelationAggregateInput
    leave?: LeaveOrderByWithRelationInput
    accompaniment?: AccompanimentOrderByWithRelationInput
    classe?: ClasseOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    projectId?: UuidFilter<"Member"> | string
    profile?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    phone?: StringFilter<"Member"> | string
    gender?: StringFilter<"Member"> | string
    dob?: DateTimeFilter<"Member"> | Date | string
    commune?: StringFilter<"Member"> | string
    residential?: StringFilter<"Member"> | string
    disability?: StringFilter<"Member"> | string
    language?: StringFilter<"Member"> | string
    attestation?: StringFilter<"Member"> | string
    accompanimentId?: UuidNullableFilter<"Member"> | string | null
    classeId?: UuidFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    signatures?: SignatureListRelationFilter
    emargements?: EmargementListRelationFilter
    leave?: XOR<LeaveNullableScalarRelationFilter, LeaveWhereInput> | null
    accompaniment?: XOR<AccompanimentNullableScalarRelationFilter, AccompanimentWhereInput> | null
    classe?: XOR<ClasseScalarRelationFilter, ClasseWhereInput>
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    commune?: SortOrder
    residential?: SortOrder
    disability?: SortOrder
    language?: SortOrder
    attestation?: SortOrder
    accompanimentId?: SortOrderInput | SortOrder
    classeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Member"> | string
    projectId?: UuidWithAggregatesFilter<"Member"> | string
    profile?: StringWithAggregatesFilter<"Member"> | string
    name?: StringWithAggregatesFilter<"Member"> | string
    phone?: StringWithAggregatesFilter<"Member"> | string
    gender?: StringWithAggregatesFilter<"Member"> | string
    dob?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    commune?: StringWithAggregatesFilter<"Member"> | string
    residential?: StringWithAggregatesFilter<"Member"> | string
    disability?: StringWithAggregatesFilter<"Member"> | string
    language?: StringWithAggregatesFilter<"Member"> | string
    attestation?: StringWithAggregatesFilter<"Member"> | string
    accompanimentId?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    classeId?: UuidWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: UuidFilter<"Chat"> | string
    projectId?: UuidFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    participants?: ChatParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    participants?: ChatParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    participants?: ChatParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id" | "projectId">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Chat"> | string
    projectId?: UuidWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type ChatParticipantWhereInput = {
    AND?: ChatParticipantWhereInput | ChatParticipantWhereInput[]
    OR?: ChatParticipantWhereInput[]
    NOT?: ChatParticipantWhereInput | ChatParticipantWhereInput[]
    id?: UuidFilter<"ChatParticipant"> | string
    userId?: UuidFilter<"ChatParticipant"> | string
    chatId?: UuidFilter<"ChatParticipant"> | string
    joinedAt?: DateTimeFilter<"ChatParticipant"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }

  export type ChatParticipantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    joinedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
  }

  export type ChatParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_chatId?: ChatParticipantUserIdChatIdCompoundUniqueInput
    AND?: ChatParticipantWhereInput | ChatParticipantWhereInput[]
    OR?: ChatParticipantWhereInput[]
    NOT?: ChatParticipantWhereInput | ChatParticipantWhereInput[]
    userId?: UuidFilter<"ChatParticipant"> | string
    chatId?: UuidFilter<"ChatParticipant"> | string
    joinedAt?: DateTimeFilter<"ChatParticipant"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }, "id" | "userId_chatId">

  export type ChatParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    joinedAt?: SortOrder
    _count?: ChatParticipantCountOrderByAggregateInput
    _max?: ChatParticipantMaxOrderByAggregateInput
    _min?: ChatParticipantMinOrderByAggregateInput
  }

  export type ChatParticipantScalarWhereWithAggregatesInput = {
    AND?: ChatParticipantScalarWhereWithAggregatesInput | ChatParticipantScalarWhereWithAggregatesInput[]
    OR?: ChatParticipantScalarWhereWithAggregatesInput[]
    NOT?: ChatParticipantScalarWhereWithAggregatesInput | ChatParticipantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChatParticipant"> | string
    userId?: UuidWithAggregatesFilter<"ChatParticipant"> | string
    chatId?: UuidWithAggregatesFilter<"ChatParticipant"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ChatParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    sentAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: UuidFilter<"Message"> | string
    chatId?: UuidFilter<"Message"> | string
    messageView?: MessageViewListRelationFilter
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    senderId?: SortOrder
    chatId?: SortOrder
    messageView?: MessageViewOrderByRelationAggregateInput
    sender?: UsersOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    sentAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: UuidFilter<"Message"> | string
    chatId?: UuidFilter<"Message"> | string
    messageView?: MessageViewListRelationFilter
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    senderId?: SortOrder
    chatId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    sentAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    senderId?: UuidWithAggregatesFilter<"Message"> | string
    chatId?: UuidWithAggregatesFilter<"Message"> | string
  }

  export type MessageViewWhereInput = {
    AND?: MessageViewWhereInput | MessageViewWhereInput[]
    OR?: MessageViewWhereInput[]
    NOT?: MessageViewWhereInput | MessageViewWhereInput[]
    id?: UuidFilter<"MessageView"> | string
    view?: BoolFilter<"MessageView"> | boolean
    messageId?: UuidFilter<"MessageView"> | string
    userId?: UuidFilter<"MessageView"> | string
    createdAt?: DateTimeFilter<"MessageView"> | Date | string
    updatedAt?: DateTimeFilter<"MessageView"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type MessageViewOrderByWithRelationInput = {
    id?: SortOrder
    view?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UsersOrderByWithRelationInput
  }

  export type MessageViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageViewMessageIdUserIdCompoundUniqueInput
    AND?: MessageViewWhereInput | MessageViewWhereInput[]
    OR?: MessageViewWhereInput[]
    NOT?: MessageViewWhereInput | MessageViewWhereInput[]
    view?: BoolFilter<"MessageView"> | boolean
    messageId?: UuidFilter<"MessageView"> | string
    userId?: UuidFilter<"MessageView"> | string
    createdAt?: DateTimeFilter<"MessageView"> | Date | string
    updatedAt?: DateTimeFilter<"MessageView"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "messageId_userId">

  export type MessageViewOrderByWithAggregationInput = {
    id?: SortOrder
    view?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageViewCountOrderByAggregateInput
    _max?: MessageViewMaxOrderByAggregateInput
    _min?: MessageViewMinOrderByAggregateInput
  }

  export type MessageViewScalarWhereWithAggregatesInput = {
    AND?: MessageViewScalarWhereWithAggregatesInput | MessageViewScalarWhereWithAggregatesInput[]
    OR?: MessageViewScalarWhereWithAggregatesInput[]
    NOT?: MessageViewScalarWhereWithAggregatesInput | MessageViewScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MessageView"> | string
    view?: BoolWithAggregatesFilter<"MessageView"> | boolean
    messageId?: UuidWithAggregatesFilter<"MessageView"> | string
    userId?: UuidWithAggregatesFilter<"MessageView"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageView"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageView"> | Date | string
  }

  export type VisitsWhereInput = {
    AND?: VisitsWhereInput | VisitsWhereInput[]
    OR?: VisitsWhereInput[]
    NOT?: VisitsWhereInput | VisitsWhereInput[]
    id?: UuidFilter<"Visits"> | string
    date?: DateTimeFilter<"Visits"> | Date | string
    startTime?: StringFilter<"Visits"> | string
    endTime?: StringFilter<"Visits"> | string
    status?: BoolFilter<"Visits"> | boolean
    location?: StringFilter<"Visits"> | string
    objetif?: StringFilter<"Visits"> | string
    planningId?: UuidFilter<"Visits"> | string
    Planning?: XOR<PlanningScalarRelationFilter, PlanningWhereInput>
    VisiteTerrain?: XOR<VisiteTerrainNullableScalarRelationFilter, VisiteTerrainWhereInput> | null
  }

  export type VisitsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    objetif?: SortOrder
    planningId?: SortOrder
    Planning?: PlanningOrderByWithRelationInput
    VisiteTerrain?: VisiteTerrainOrderByWithRelationInput
  }

  export type VisitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitsWhereInput | VisitsWhereInput[]
    OR?: VisitsWhereInput[]
    NOT?: VisitsWhereInput | VisitsWhereInput[]
    date?: DateTimeFilter<"Visits"> | Date | string
    startTime?: StringFilter<"Visits"> | string
    endTime?: StringFilter<"Visits"> | string
    status?: BoolFilter<"Visits"> | boolean
    location?: StringFilter<"Visits"> | string
    objetif?: StringFilter<"Visits"> | string
    planningId?: UuidFilter<"Visits"> | string
    Planning?: XOR<PlanningScalarRelationFilter, PlanningWhereInput>
    VisiteTerrain?: XOR<VisiteTerrainNullableScalarRelationFilter, VisiteTerrainWhereInput> | null
  }, "id">

  export type VisitsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    objetif?: SortOrder
    planningId?: SortOrder
    _count?: VisitsCountOrderByAggregateInput
    _max?: VisitsMaxOrderByAggregateInput
    _min?: VisitsMinOrderByAggregateInput
  }

  export type VisitsScalarWhereWithAggregatesInput = {
    AND?: VisitsScalarWhereWithAggregatesInput | VisitsScalarWhereWithAggregatesInput[]
    OR?: VisitsScalarWhereWithAggregatesInput[]
    NOT?: VisitsScalarWhereWithAggregatesInput | VisitsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Visits"> | string
    date?: DateTimeWithAggregatesFilter<"Visits"> | Date | string
    startTime?: StringWithAggregatesFilter<"Visits"> | string
    endTime?: StringWithAggregatesFilter<"Visits"> | string
    status?: BoolWithAggregatesFilter<"Visits"> | boolean
    location?: StringWithAggregatesFilter<"Visits"> | string
    objetif?: StringWithAggregatesFilter<"Visits"> | string
    planningId?: UuidWithAggregatesFilter<"Visits"> | string
  }

  export type PlanningWhereInput = {
    AND?: PlanningWhereInput | PlanningWhereInput[]
    OR?: PlanningWhereInput[]
    NOT?: PlanningWhereInput | PlanningWhereInput[]
    id?: UuidFilter<"Planning"> | string
    usersId?: UuidFilter<"Planning"> | string
    accompaniments?: AccompanimentListRelationFilter
    visit?: VisitsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type PlanningOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    accompaniments?: AccompanimentOrderByRelationAggregateInput
    visit?: VisitsOrderByRelationAggregateInput
    users?: UsersOrderByWithRelationInput
  }

  export type PlanningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanningWhereInput | PlanningWhereInput[]
    OR?: PlanningWhereInput[]
    NOT?: PlanningWhereInput | PlanningWhereInput[]
    usersId?: UuidFilter<"Planning"> | string
    accompaniments?: AccompanimentListRelationFilter
    visit?: VisitsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type PlanningOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    _count?: PlanningCountOrderByAggregateInput
    _max?: PlanningMaxOrderByAggregateInput
    _min?: PlanningMinOrderByAggregateInput
  }

  export type PlanningScalarWhereWithAggregatesInput = {
    AND?: PlanningScalarWhereWithAggregatesInput | PlanningScalarWhereWithAggregatesInput[]
    OR?: PlanningScalarWhereWithAggregatesInput[]
    NOT?: PlanningScalarWhereWithAggregatesInput | PlanningScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Planning"> | string
    usersId?: UuidWithAggregatesFilter<"Planning"> | string
  }

  export type MapsWhereInput = {
    AND?: MapsWhereInput | MapsWhereInput[]
    OR?: MapsWhereInput[]
    NOT?: MapsWhereInput | MapsWhereInput[]
    id?: UuidFilter<"Maps"> | string
    accompanimentId?: UuidFilter<"Maps"> | string
    latitude?: StringFilter<"Maps"> | string
    longitude?: StringFilter<"Maps"> | string
    createdAt?: DateTimeFilter<"Maps"> | Date | string
    updatedAt?: DateTimeFilter<"Maps"> | Date | string
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
  }

  export type MapsOrderByWithRelationInput = {
    id?: SortOrder
    accompanimentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accompaniment?: AccompanimentOrderByWithRelationInput
  }

  export type MapsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accompanimentId?: string
    AND?: MapsWhereInput | MapsWhereInput[]
    OR?: MapsWhereInput[]
    NOT?: MapsWhereInput | MapsWhereInput[]
    latitude?: StringFilter<"Maps"> | string
    longitude?: StringFilter<"Maps"> | string
    createdAt?: DateTimeFilter<"Maps"> | Date | string
    updatedAt?: DateTimeFilter<"Maps"> | Date | string
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
  }, "id" | "accompanimentId">

  export type MapsOrderByWithAggregationInput = {
    id?: SortOrder
    accompanimentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MapsCountOrderByAggregateInput
    _max?: MapsMaxOrderByAggregateInput
    _min?: MapsMinOrderByAggregateInput
  }

  export type MapsScalarWhereWithAggregatesInput = {
    AND?: MapsScalarWhereWithAggregatesInput | MapsScalarWhereWithAggregatesInput[]
    OR?: MapsScalarWhereWithAggregatesInput[]
    NOT?: MapsScalarWhereWithAggregatesInput | MapsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Maps"> | string
    accompanimentId?: UuidWithAggregatesFilter<"Maps"> | string
    latitude?: StringWithAggregatesFilter<"Maps"> | string
    longitude?: StringWithAggregatesFilter<"Maps"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Maps"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Maps"> | Date | string
  }

  export type PurchaseItemsWhereInput = {
    AND?: PurchaseItemsWhereInput | PurchaseItemsWhereInput[]
    OR?: PurchaseItemsWhereInput[]
    NOT?: PurchaseItemsWhereInput | PurchaseItemsWhereInput[]
    id?: UuidFilter<"PurchaseItems"> | string
    name?: StringFilter<"PurchaseItems"> | string
    price?: StringFilter<"PurchaseItems"> | string
    image?: StringFilter<"PurchaseItems"> | string
    quantity?: IntFilter<"PurchaseItems"> | number
    date?: DateTimeFilter<"PurchaseItems"> | Date | string
    purchaseId?: UuidFilter<"PurchaseItems"> | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
  }

  export type PurchaseItemsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    image?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    purchaseId?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
  }

  export type PurchaseItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseItemsWhereInput | PurchaseItemsWhereInput[]
    OR?: PurchaseItemsWhereInput[]
    NOT?: PurchaseItemsWhereInput | PurchaseItemsWhereInput[]
    name?: StringFilter<"PurchaseItems"> | string
    price?: StringFilter<"PurchaseItems"> | string
    image?: StringFilter<"PurchaseItems"> | string
    quantity?: IntFilter<"PurchaseItems"> | number
    date?: DateTimeFilter<"PurchaseItems"> | Date | string
    purchaseId?: UuidFilter<"PurchaseItems"> | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
  }, "id">

  export type PurchaseItemsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    image?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    purchaseId?: SortOrder
    _count?: PurchaseItemsCountOrderByAggregateInput
    _avg?: PurchaseItemsAvgOrderByAggregateInput
    _max?: PurchaseItemsMaxOrderByAggregateInput
    _min?: PurchaseItemsMinOrderByAggregateInput
    _sum?: PurchaseItemsSumOrderByAggregateInput
  }

  export type PurchaseItemsScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemsScalarWhereWithAggregatesInput | PurchaseItemsScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemsScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemsScalarWhereWithAggregatesInput | PurchaseItemsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PurchaseItems"> | string
    name?: StringWithAggregatesFilter<"PurchaseItems"> | string
    price?: StringWithAggregatesFilter<"PurchaseItems"> | string
    image?: StringWithAggregatesFilter<"PurchaseItems"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseItems"> | number
    date?: DateTimeWithAggregatesFilter<"PurchaseItems"> | Date | string
    purchaseId?: UuidWithAggregatesFilter<"PurchaseItems"> | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: UuidFilter<"Purchase"> | string
    total?: IntFilter<"Purchase"> | number
    accompanimentId?: UuidFilter<"Purchase"> | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    purchaseItems?: PurchaseItemsListRelationFilter
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    total?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseItems?: PurchaseItemsOrderByRelationAggregateInput
    accompaniment?: AccompanimentOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    total?: IntFilter<"Purchase"> | number
    accompanimentId?: UuidFilter<"Purchase"> | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    purchaseItems?: PurchaseItemsListRelationFilter
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    total?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Purchase"> | string
    total?: IntWithAggregatesFilter<"Purchase"> | number
    accompanimentId?: UuidWithAggregatesFilter<"Purchase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type EmargementWhereInput = {
    AND?: EmargementWhereInput | EmargementWhereInput[]
    OR?: EmargementWhereInput[]
    NOT?: EmargementWhereInput | EmargementWhereInput[]
    id?: UuidFilter<"Emargement"> | string
    date?: DateTimeFilter<"Emargement"> | Date | string
    signature?: BoolFilter<"Emargement"> | boolean
    cni?: StringFilter<"Emargement"> | string
    PhotoCni?: StringFilter<"Emargement"> | string
    montant?: IntFilter<"Emargement"> | number
    observations?: StringFilter<"Emargement"> | string
    usersId?: UuidFilter<"Emargement"> | string
    memberId?: UuidFilter<"Emargement"> | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type EmargementOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    signature?: SortOrder
    cni?: SortOrder
    PhotoCni?: SortOrder
    montant?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    memberId?: SortOrder
    users?: UsersOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type EmargementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmargementWhereInput | EmargementWhereInput[]
    OR?: EmargementWhereInput[]
    NOT?: EmargementWhereInput | EmargementWhereInput[]
    date?: DateTimeFilter<"Emargement"> | Date | string
    signature?: BoolFilter<"Emargement"> | boolean
    cni?: StringFilter<"Emargement"> | string
    PhotoCni?: StringFilter<"Emargement"> | string
    montant?: IntFilter<"Emargement"> | number
    observations?: StringFilter<"Emargement"> | string
    usersId?: UuidFilter<"Emargement"> | string
    memberId?: UuidFilter<"Emargement"> | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type EmargementOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    signature?: SortOrder
    cni?: SortOrder
    PhotoCni?: SortOrder
    montant?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    memberId?: SortOrder
    _count?: EmargementCountOrderByAggregateInput
    _avg?: EmargementAvgOrderByAggregateInput
    _max?: EmargementMaxOrderByAggregateInput
    _min?: EmargementMinOrderByAggregateInput
    _sum?: EmargementSumOrderByAggregateInput
  }

  export type EmargementScalarWhereWithAggregatesInput = {
    AND?: EmargementScalarWhereWithAggregatesInput | EmargementScalarWhereWithAggregatesInput[]
    OR?: EmargementScalarWhereWithAggregatesInput[]
    NOT?: EmargementScalarWhereWithAggregatesInput | EmargementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Emargement"> | string
    date?: DateTimeWithAggregatesFilter<"Emargement"> | Date | string
    signature?: BoolWithAggregatesFilter<"Emargement"> | boolean
    cni?: StringWithAggregatesFilter<"Emargement"> | string
    PhotoCni?: StringWithAggregatesFilter<"Emargement"> | string
    montant?: IntWithAggregatesFilter<"Emargement"> | number
    observations?: StringWithAggregatesFilter<"Emargement"> | string
    usersId?: UuidWithAggregatesFilter<"Emargement"> | string
    memberId?: UuidWithAggregatesFilter<"Emargement"> | string
  }

  export type VisiteTerrainWhereInput = {
    AND?: VisiteTerrainWhereInput | VisiteTerrainWhereInput[]
    OR?: VisiteTerrainWhereInput[]
    NOT?: VisiteTerrainWhereInput | VisiteTerrainWhereInput[]
    id?: UuidFilter<"VisiteTerrain"> | string
    visitId?: UuidFilter<"VisiteTerrain"> | string
    observations?: StringFilter<"VisiteTerrain"> | string
    usersId?: UuidFilter<"VisiteTerrain"> | string
    createdAt?: DateTimeFilter<"VisiteTerrain"> | Date | string
    updatedAt?: DateTimeFilter<"VisiteTerrain"> | Date | string
    visit?: XOR<VisitsScalarRelationFilter, VisitsWhereInput>
    personnes?: PersonnesListRelationFilter
    files?: FilesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type VisiteTerrainOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visit?: VisitsOrderByWithRelationInput
    personnes?: PersonnesOrderByRelationAggregateInput
    files?: FilesOrderByRelationAggregateInput
    users?: UsersOrderByWithRelationInput
  }

  export type VisiteTerrainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    visitId?: string
    AND?: VisiteTerrainWhereInput | VisiteTerrainWhereInput[]
    OR?: VisiteTerrainWhereInput[]
    NOT?: VisiteTerrainWhereInput | VisiteTerrainWhereInput[]
    observations?: StringFilter<"VisiteTerrain"> | string
    usersId?: UuidFilter<"VisiteTerrain"> | string
    createdAt?: DateTimeFilter<"VisiteTerrain"> | Date | string
    updatedAt?: DateTimeFilter<"VisiteTerrain"> | Date | string
    visit?: XOR<VisitsScalarRelationFilter, VisitsWhereInput>
    personnes?: PersonnesListRelationFilter
    files?: FilesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "visitId">

  export type VisiteTerrainOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisiteTerrainCountOrderByAggregateInput
    _max?: VisiteTerrainMaxOrderByAggregateInput
    _min?: VisiteTerrainMinOrderByAggregateInput
  }

  export type VisiteTerrainScalarWhereWithAggregatesInput = {
    AND?: VisiteTerrainScalarWhereWithAggregatesInput | VisiteTerrainScalarWhereWithAggregatesInput[]
    OR?: VisiteTerrainScalarWhereWithAggregatesInput[]
    NOT?: VisiteTerrainScalarWhereWithAggregatesInput | VisiteTerrainScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VisiteTerrain"> | string
    visitId?: UuidWithAggregatesFilter<"VisiteTerrain"> | string
    observations?: StringWithAggregatesFilter<"VisiteTerrain"> | string
    usersId?: UuidWithAggregatesFilter<"VisiteTerrain"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VisiteTerrain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VisiteTerrain"> | Date | string
  }

  export type ConflitWhereInput = {
    AND?: ConflitWhereInput | ConflitWhereInput[]
    OR?: ConflitWhereInput[]
    NOT?: ConflitWhereInput | ConflitWhereInput[]
    id?: UuidFilter<"Conflit"> | string
    nature?: StringFilter<"Conflit"> | string
    resolution?: StringFilter<"Conflit"> | string
    usersId?: UuidFilter<"Conflit"> | string
    status?: BoolFilter<"Conflit"> | boolean
    accompanimentId?: UuidFilter<"Conflit"> | string
    createdAt?: DateTimeFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeFilter<"Conflit"> | Date | string
    partieImpliques?: PersonnesListRelationFilter
    files?: FilesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
  }

  export type ConflitOrderByWithRelationInput = {
    id?: SortOrder
    nature?: SortOrder
    resolution?: SortOrder
    usersId?: SortOrder
    status?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partieImpliques?: PersonnesOrderByRelationAggregateInput
    files?: FilesOrderByRelationAggregateInput
    users?: UsersOrderByWithRelationInput
    accompaniment?: AccompanimentOrderByWithRelationInput
  }

  export type ConflitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConflitWhereInput | ConflitWhereInput[]
    OR?: ConflitWhereInput[]
    NOT?: ConflitWhereInput | ConflitWhereInput[]
    nature?: StringFilter<"Conflit"> | string
    resolution?: StringFilter<"Conflit"> | string
    usersId?: UuidFilter<"Conflit"> | string
    status?: BoolFilter<"Conflit"> | boolean
    accompanimentId?: UuidFilter<"Conflit"> | string
    createdAt?: DateTimeFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeFilter<"Conflit"> | Date | string
    partieImpliques?: PersonnesListRelationFilter
    files?: FilesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
  }, "id">

  export type ConflitOrderByWithAggregationInput = {
    id?: SortOrder
    nature?: SortOrder
    resolution?: SortOrder
    usersId?: SortOrder
    status?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConflitCountOrderByAggregateInput
    _max?: ConflitMaxOrderByAggregateInput
    _min?: ConflitMinOrderByAggregateInput
  }

  export type ConflitScalarWhereWithAggregatesInput = {
    AND?: ConflitScalarWhereWithAggregatesInput | ConflitScalarWhereWithAggregatesInput[]
    OR?: ConflitScalarWhereWithAggregatesInput[]
    NOT?: ConflitScalarWhereWithAggregatesInput | ConflitScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Conflit"> | string
    nature?: StringWithAggregatesFilter<"Conflit"> | string
    resolution?: StringWithAggregatesFilter<"Conflit"> | string
    usersId?: UuidWithAggregatesFilter<"Conflit"> | string
    status?: BoolWithAggregatesFilter<"Conflit"> | boolean
    accompanimentId?: UuidWithAggregatesFilter<"Conflit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conflit"> | Date | string
  }

  export type RencontreWhereInput = {
    AND?: RencontreWhereInput | RencontreWhereInput[]
    OR?: RencontreWhereInput[]
    NOT?: RencontreWhereInput | RencontreWhereInput[]
    id?: UuidFilter<"Rencontre"> | string
    date?: DateTimeFilter<"Rencontre"> | Date | string
    lieu?: StringFilter<"Rencontre"> | string
    order?: StringNullableListFilter<"Rencontre">
    decisions?: StringNullableListFilter<"Rencontre">
    actions?: StringNullableListFilter<"Rencontre">
    accompanimentId?: UuidFilter<"Rencontre"> | string
    usersId?: UuidFilter<"Rencontre"> | string
    signatures?: SignatureListRelationFilter
    files?: FilesListRelationFilter
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type RencontreOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    lieu?: SortOrder
    order?: SortOrder
    decisions?: SortOrder
    actions?: SortOrder
    accompanimentId?: SortOrder
    usersId?: SortOrder
    signatures?: SignatureOrderByRelationAggregateInput
    files?: FilesOrderByRelationAggregateInput
    accompaniment?: AccompanimentOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type RencontreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RencontreWhereInput | RencontreWhereInput[]
    OR?: RencontreWhereInput[]
    NOT?: RencontreWhereInput | RencontreWhereInput[]
    date?: DateTimeFilter<"Rencontre"> | Date | string
    lieu?: StringFilter<"Rencontre"> | string
    order?: StringNullableListFilter<"Rencontre">
    decisions?: StringNullableListFilter<"Rencontre">
    actions?: StringNullableListFilter<"Rencontre">
    accompanimentId?: UuidFilter<"Rencontre"> | string
    usersId?: UuidFilter<"Rencontre"> | string
    signatures?: SignatureListRelationFilter
    files?: FilesListRelationFilter
    accompaniment?: XOR<AccompanimentScalarRelationFilter, AccompanimentWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type RencontreOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    lieu?: SortOrder
    order?: SortOrder
    decisions?: SortOrder
    actions?: SortOrder
    accompanimentId?: SortOrder
    usersId?: SortOrder
    _count?: RencontreCountOrderByAggregateInput
    _max?: RencontreMaxOrderByAggregateInput
    _min?: RencontreMinOrderByAggregateInput
  }

  export type RencontreScalarWhereWithAggregatesInput = {
    AND?: RencontreScalarWhereWithAggregatesInput | RencontreScalarWhereWithAggregatesInput[]
    OR?: RencontreScalarWhereWithAggregatesInput[]
    NOT?: RencontreScalarWhereWithAggregatesInput | RencontreScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Rencontre"> | string
    date?: DateTimeWithAggregatesFilter<"Rencontre"> | Date | string
    lieu?: StringWithAggregatesFilter<"Rencontre"> | string
    order?: StringNullableListFilter<"Rencontre">
    decisions?: StringNullableListFilter<"Rencontre">
    actions?: StringNullableListFilter<"Rencontre">
    accompanimentId?: UuidWithAggregatesFilter<"Rencontre"> | string
    usersId?: UuidWithAggregatesFilter<"Rencontre"> | string
  }

  export type UploadWhereInput = {
    AND?: UploadWhereInput | UploadWhereInput[]
    OR?: UploadWhereInput[]
    NOT?: UploadWhereInput | UploadWhereInput[]
    id?: UuidFilter<"Upload"> | string
    titre?: StringFilter<"Upload"> | string
    date?: DateTimeFilter<"Upload"> | Date | string
    fileId?: UuidFilter<"Upload"> | string
    userId?: UuidFilter<"Upload"> | string
    file?: XOR<FilesScalarRelationFilter, FilesWhereInput>
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type UploadOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    date?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    file?: FilesOrderByWithRelationInput
    user?: UsersOrderByWithRelationInput
  }

  export type UploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UploadWhereInput | UploadWhereInput[]
    OR?: UploadWhereInput[]
    NOT?: UploadWhereInput | UploadWhereInput[]
    titre?: StringFilter<"Upload"> | string
    date?: DateTimeFilter<"Upload"> | Date | string
    fileId?: UuidFilter<"Upload"> | string
    userId?: UuidFilter<"Upload"> | string
    file?: XOR<FilesScalarRelationFilter, FilesWhereInput>
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type UploadOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    date?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
    _count?: UploadCountOrderByAggregateInput
    _max?: UploadMaxOrderByAggregateInput
    _min?: UploadMinOrderByAggregateInput
  }

  export type UploadScalarWhereWithAggregatesInput = {
    AND?: UploadScalarWhereWithAggregatesInput | UploadScalarWhereWithAggregatesInput[]
    OR?: UploadScalarWhereWithAggregatesInput[]
    NOT?: UploadScalarWhereWithAggregatesInput | UploadScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Upload"> | string
    titre?: StringWithAggregatesFilter<"Upload"> | string
    date?: DateTimeWithAggregatesFilter<"Upload"> | Date | string
    fileId?: UuidWithAggregatesFilter<"Upload"> | string
    userId?: UuidWithAggregatesFilter<"Upload"> | string
  }

  export type PersonnesCreateInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    Conflit?: ConflitCreateNestedOneWithoutPartieImpliquesInput
    VisiteTerrain?: VisiteTerrainCreateNestedOneWithoutPersonnesInput
  }

  export type PersonnesUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    conflitId?: string | null
    visiteTerrainId?: string | null
  }

  export type PersonnesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    Conflit?: ConflitUpdateOneWithoutPartieImpliquesNestedInput
    VisiteTerrain?: VisiteTerrainUpdateOneWithoutPersonnesNestedInput
  }

  export type PersonnesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnesCreateManyInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    conflitId?: string | null
    visiteTerrainId?: string | null
  }

  export type PersonnesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureCreateInput = {
    id?: string
    date: Date | string
    present?: boolean
    member: MemberCreateNestedOneWithoutSignaturesInput
    Rencontre?: RencontreCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateInput = {
    id?: string
    date: Date | string
    present?: boolean
    memberId: string
    rencontreId?: string | null
  }

  export type SignatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    member?: MemberUpdateOneRequiredWithoutSignaturesNestedInput
    Rencontre?: RencontreUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    memberId?: StringFieldUpdateOperationsInput | string
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureCreateManyInput = {
    id?: string
    date: Date | string
    present?: boolean
    memberId: string
    rencontreId?: string | null
  }

  export type SignatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SignatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    memberId?: StringFieldUpdateOperationsInput | string
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilesCreateInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    Users?: UsersCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    rencontreId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FilesCreateManyInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    rencontreId?: string | null
  }

  export type FilesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type FilesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentCreateNestedManyWithoutProjectInput
    leave?: LeaveCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    classes?: ClasseCreateNestedManyWithoutProjectInput
    chat?: ChatCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProjectInput
    leave?: LeaveUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    classes?: ClasseUncheckedCreateNestedManyWithoutProjectInput
    chat?: ChatUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUpdateManyWithoutProjectNestedInput
    leave?: LeaveUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    classes?: ClasseUpdateManyWithoutProjectNestedInput
    chat?: ChatUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProjectNestedInput
    leave?: LeaveUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutProjectNestedInput
    chat?: ChatUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateInput = {
    id?: string
    date: Date | string
    reason: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLeaveInput
    member: MemberCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: string
    date: Date | string
    reason: string
    projectId: string
    memberId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLeaveNestedInput
    member?: MemberUpdateOneRequiredWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateManyInput = {
    id?: string
    date: Date | string
    reason: string
    projectId: string
    memberId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentCreateInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type AccompanimentCreateManyInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type AccompanimentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClasseCreateInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutClasseInput
    members?: MemberCreateNestedManyWithoutClasseInput
    project: ProjectCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateInput = {
    id?: string
    name: string
    usersId: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutClasseNestedInput
    members?: MemberUpdateManyWithoutClasseNestedInput
    project?: ProjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseCreateManyInput = {
    id?: string
    name: string
    usersId: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ClasseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClasseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    signatures?: SignatureCreateNestedManyWithoutMemberInput
    emargements?: EmargementCreateNestedManyWithoutMemberInput
    leave?: LeaveCreateNestedOneWithoutMemberInput
    accompaniment?: AccompanimentCreateNestedOneWithoutMembersInput
    classe: ClasseCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutMemberInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutMemberInput
    leave?: LeaveUncheckedCreateNestedOneWithoutMemberInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    signatures?: SignatureUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUpdateManyWithoutMemberNestedInput
    leave?: LeaveUpdateOneWithoutMemberNestedInput
    accompaniment?: AccompanimentUpdateOneWithoutMembersNestedInput
    classe?: ClasseUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutMemberNestedInput
    leave?: LeaveUncheckedUpdateOneWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChatInput
    participants?: ChatParticipantCreateNestedManyWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChatParticipantUncheckedCreateNestedManyWithoutChatInput
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChatNestedInput
    participants?: ChatParticipantUpdateManyWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChatParticipantUncheckedUpdateManyWithoutChatNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatParticipantCreateInput = {
    id?: string
    joinedAt?: Date | string
    user: UsersCreateNestedOneWithoutChatParticipantInput
    chat: ChatCreateNestedOneWithoutParticipantsInput
  }

  export type ChatParticipantUncheckedCreateInput = {
    id?: string
    userId: string
    chatId: string
    joinedAt?: Date | string
  }

  export type ChatParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutChatParticipantNestedInput
    chat?: ChatUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChatParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatParticipantCreateManyInput = {
    id?: string
    userId: string
    chatId: string
    joinedAt?: Date | string
  }

  export type ChatParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    sentAt?: Date | string
    messageView?: MessageViewCreateNestedManyWithoutMessageInput
    sender: UsersCreateNestedOneWithoutMessageInput
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    sentAt?: Date | string
    senderId: string
    chatId: string
    messageView?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageView?: MessageViewUpdateManyWithoutMessageNestedInput
    sender?: UsersUpdateOneRequiredWithoutMessageNestedInput
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    messageView?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    sentAt?: Date | string
    senderId: string
    chatId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageViewCreateInput = {
    id?: string
    view?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    message: MessageCreateNestedOneWithoutMessageViewInput
    user: UsersCreateNestedOneWithoutMessageViewInput
  }

  export type MessageViewUncheckedCreateInput = {
    id?: string
    view?: boolean
    messageId: string
    userId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MessageViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutMessageViewNestedInput
    user?: UsersUpdateOneRequiredWithoutMessageViewNestedInput
  }

  export type MessageViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewCreateManyInput = {
    id?: string
    view?: boolean
    messageId: string
    userId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MessageViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitsCreateInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    Planning: PlanningCreateNestedOneWithoutVisitInput
    VisiteTerrain?: VisiteTerrainCreateNestedOneWithoutVisitInput
  }

  export type VisitsUncheckedCreateInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    planningId: string
    VisiteTerrain?: VisiteTerrainUncheckedCreateNestedOneWithoutVisitInput
  }

  export type VisitsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    Planning?: PlanningUpdateOneRequiredWithoutVisitNestedInput
    VisiteTerrain?: VisiteTerrainUpdateOneWithoutVisitNestedInput
  }

  export type VisitsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    planningId?: StringFieldUpdateOperationsInput | string
    VisiteTerrain?: VisiteTerrainUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type VisitsCreateManyInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    planningId: string
  }

  export type VisitsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
  }

  export type VisitsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    planningId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanningCreateInput = {
    id?: string
    accompaniments?: AccompanimentCreateNestedManyWithoutPlanningInput
    visit?: VisitsCreateNestedManyWithoutPlanningInput
    users: UsersCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateInput = {
    id?: string
    usersId: string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutPlanningInput
    visit?: VisitsUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accompaniments?: AccompanimentUpdateManyWithoutPlanningNestedInput
    visit?: VisitsUpdateManyWithoutPlanningNestedInput
    users?: UsersUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutPlanningNestedInput
    visit?: VisitsUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningCreateManyInput = {
    id?: string
    usersId: string
  }

  export type PlanningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PlanningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
  }

  export type MapsCreateInput = {
    id?: string
    latitude: string
    longitude: string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniment: AccompanimentCreateNestedOneWithoutMapInput
  }

  export type MapsUncheckedCreateInput = {
    id?: string
    accompanimentId: string
    latitude: string
    longitude: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MapsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    longitude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniment?: AccompanimentUpdateOneRequiredWithoutMapNestedInput
  }

  export type MapsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accompanimentId?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    longitude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapsCreateManyInput = {
    id?: string
    accompanimentId: string
    latitude: string
    longitude: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MapsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    longitude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accompanimentId?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    longitude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsCreateInput = {
    id?: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date | string
    purchase: PurchaseCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemsUncheckedCreateInput = {
    id?: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date | string
    purchaseId: string
  }

  export type PurchaseItemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseItemsCreateManyInput = {
    id?: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date | string
    purchaseId: string
  }

  export type PurchaseItemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseCreateInput = {
    id?: string
    total: number
    createdAt: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsCreateNestedManyWithoutPurchaseInput
    accompaniment: AccompanimentCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    total: number
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUpdateManyWithoutPurchaseNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    total: number
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmargementCreateInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    users: UsersCreateNestedOneWithoutEmargementsInput
    member: MemberCreateNestedOneWithoutEmargementsInput
  }

  export type EmargementUncheckedCreateInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    usersId: string
    memberId: string
  }

  export type EmargementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateOneRequiredWithoutEmargementsNestedInput
    member?: MemberUpdateOneRequiredWithoutEmargementsNestedInput
  }

  export type EmargementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type EmargementCreateManyInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    usersId: string
    memberId: string
  }

  export type EmargementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
  }

  export type EmargementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type VisiteTerrainCreateInput = {
    id?: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
    visit: VisitsCreateNestedOneWithoutVisiteTerrainInput
    personnes?: PersonnesCreateNestedManyWithoutVisiteTerrainInput
    files?: FilesCreateNestedManyWithoutVisiteTerrainInput
    users: UsersCreateNestedOneWithoutVisiteTerrainsInput
  }

  export type VisiteTerrainUncheckedCreateInput = {
    id?: string
    visitId: string
    observations: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
    personnes?: PersonnesUncheckedCreateNestedManyWithoutVisiteTerrainInput
    files?: FilesUncheckedCreateNestedManyWithoutVisiteTerrainInput
  }

  export type VisiteTerrainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitsUpdateOneRequiredWithoutVisiteTerrainNestedInput
    personnes?: PersonnesUpdateManyWithoutVisiteTerrainNestedInput
    files?: FilesUpdateManyWithoutVisiteTerrainNestedInput
    users?: UsersUpdateOneRequiredWithoutVisiteTerrainsNestedInput
  }

  export type VisiteTerrainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnes?: PersonnesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
    files?: FilesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
  }

  export type VisiteTerrainCreateManyInput = {
    id?: string
    visitId: string
    observations: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type VisiteTerrainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisiteTerrainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflitCreateInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesCreateNestedManyWithoutConflitInput
    files?: FilesCreateNestedManyWithoutConflitInput
    users: UsersCreateNestedOneWithoutConflitInput
    accompaniment: AccompanimentCreateNestedOneWithoutConflitsInput
  }

  export type ConflitUncheckedCreateInput = {
    id?: string
    nature: string
    resolution: string
    usersId: string
    status?: boolean
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesUncheckedCreateNestedManyWithoutConflitInput
    files?: FilesUncheckedCreateNestedManyWithoutConflitInput
  }

  export type ConflitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUpdateManyWithoutConflitNestedInput
    files?: FilesUpdateManyWithoutConflitNestedInput
    users?: UsersUpdateOneRequiredWithoutConflitNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutConflitsNestedInput
  }

  export type ConflitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUncheckedUpdateManyWithoutConflitNestedInput
    files?: FilesUncheckedUpdateManyWithoutConflitNestedInput
  }

  export type ConflitCreateManyInput = {
    id?: string
    nature: string
    resolution: string
    usersId: string
    status?: boolean
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ConflitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RencontreCreateInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    signatures?: SignatureCreateNestedManyWithoutRencontreInput
    files?: FilesCreateNestedManyWithoutRencontreInput
    accompaniment: AccompanimentCreateNestedOneWithoutRencontreInput
    users: UsersCreateNestedOneWithoutRencontresInput
  }

  export type RencontreUncheckedCreateInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    accompanimentId: string
    usersId: string
    signatures?: SignatureUncheckedCreateNestedManyWithoutRencontreInput
    files?: FilesUncheckedCreateNestedManyWithoutRencontreInput
  }

  export type RencontreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    signatures?: SignatureUpdateManyWithoutRencontreNestedInput
    files?: FilesUpdateManyWithoutRencontreNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutRencontreNestedInput
    users?: UsersUpdateOneRequiredWithoutRencontresNestedInput
  }

  export type RencontreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    accompanimentId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    signatures?: SignatureUncheckedUpdateManyWithoutRencontreNestedInput
    files?: FilesUncheckedUpdateManyWithoutRencontreNestedInput
  }

  export type RencontreCreateManyInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    accompanimentId: string
    usersId: string
  }

  export type RencontreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
  }

  export type RencontreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    accompanimentId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
  }

  export type UploadCreateInput = {
    id?: string
    titre: string
    date: Date | string
    file: FilesCreateNestedOneWithoutUploadInput
    user: UsersCreateNestedOneWithoutUploadsInput
  }

  export type UploadUncheckedCreateInput = {
    id?: string
    titre: string
    date: Date | string
    fileId: string
    userId: string
  }

  export type UploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FilesUpdateOneRequiredWithoutUploadNestedInput
    user?: UsersUpdateOneRequiredWithoutUploadsNestedInput
  }

  export type UploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UploadCreateManyInput = {
    id?: string
    titre: string
    date: Date | string
    fileId: string
    userId: string
  }

  export type UploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ConflitNullableScalarRelationFilter = {
    is?: ConflitWhereInput | null
    isNot?: ConflitWhereInput | null
  }

  export type VisiteTerrainNullableScalarRelationFilter = {
    is?: VisiteTerrainWhereInput | null
    isNot?: VisiteTerrainWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonnesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    signature?: SortOrder
    conflitId?: SortOrder
    visiteTerrainId?: SortOrder
  }

  export type PersonnesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    signature?: SortOrder
    conflitId?: SortOrder
    visiteTerrainId?: SortOrder
  }

  export type PersonnesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    signature?: SortOrder
    conflitId?: SortOrder
    visiteTerrainId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type RencontreNullableScalarRelationFilter = {
    is?: RencontreWhereInput | null
    isNot?: RencontreWhereInput | null
  }

  export type SignatureCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    present?: SortOrder
    memberId?: SortOrder
    rencontreId?: SortOrder
  }

  export type SignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    present?: SortOrder
    memberId?: SortOrder
    rencontreId?: SortOrder
  }

  export type SignatureMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    present?: SortOrder
    memberId?: SortOrder
    rencontreId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UploadListRelationFilter = {
    every?: UploadWhereInput
    some?: UploadWhereInput
    none?: UploadWhereInput
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type AccompanimentListRelationFilter = {
    every?: AccompanimentWhereInput
    some?: AccompanimentWhereInput
    none?: AccompanimentWhereInput
  }

  export type UploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccompanimentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    visiteTerrainId?: SortOrder
    conflitId?: SortOrder
    rencontreId?: SortOrder
  }

  export type FilesAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FilesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    visiteTerrainId?: SortOrder
    conflitId?: SortOrder
    rencontreId?: SortOrder
  }

  export type FilesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    visiteTerrainId?: SortOrder
    conflitId?: SortOrder
    rencontreId?: SortOrder
  }

  export type FilesSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeFilter<$PrismaModel> | $Enums.Type
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FilesNullableScalarRelationFilter = {
    is?: FilesWhereInput | null
    isNot?: FilesWhereInput | null
  }

  export type PlanningListRelationFilter = {
    every?: PlanningWhereInput
    some?: PlanningWhereInput
    none?: PlanningWhereInput
  }

  export type EmargementListRelationFilter = {
    every?: EmargementWhereInput
    some?: EmargementWhereInput
    none?: EmargementWhereInput
  }

  export type VisiteTerrainListRelationFilter = {
    every?: VisiteTerrainWhereInput
    some?: VisiteTerrainWhereInput
    none?: VisiteTerrainWhereInput
  }

  export type RencontreListRelationFilter = {
    every?: RencontreWhereInput
    some?: RencontreWhereInput
    none?: RencontreWhereInput
  }

  export type ConflitListRelationFilter = {
    every?: ConflitWhereInput
    some?: ConflitWhereInput
    none?: ConflitWhereInput
  }

  export type ChatParticipantListRelationFilter = {
    every?: ChatParticipantWhereInput
    some?: ChatParticipantWhereInput
    none?: ChatParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageViewListRelationFilter = {
    every?: MessageViewWhereInput
    some?: MessageViewWhereInput
    none?: MessageViewWhereInput
  }

  export type ClasseListRelationFilter = {
    every?: ClasseWhereInput
    some?: ClasseWhereInput
    none?: ClasseWhereInput
  }

  export type PlanningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmargementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisiteTerrainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RencontreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConflitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClasseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    filesId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    routes?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    filesId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    filesId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeWithAggregatesFilter<$PrismaModel> | $Enums.Type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeFilter<$PrismaModel>
    _max?: NestedEnumTypeFilter<$PrismaModel>
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type ChatNullableScalarRelationFilter = {
    is?: ChatWhereInput | null
    isNot?: ChatWhereInput | null
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    local?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    local?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    local?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    projectId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    projectId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    projectId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type MapsNullableScalarRelationFilter = {
    is?: MapsWhereInput | null
    isNot?: MapsWhereInput | null
  }

  export type FilesScalarRelationFilter = {
    is?: FilesWhereInput
    isNot?: FilesWhereInput
  }

  export type FilesListRelationFilter = {
    every?: FilesWhereInput
    some?: FilesWhereInput
    none?: FilesWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PlanningNullableScalarRelationFilter = {
    is?: PlanningWhereInput | null
    isNot?: PlanningWhereInput | null
  }

  export type FilesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccompanimentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adresse?: SortOrder
    phones?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    usersid?: SortOrder
    fileId?: SortOrder
    projectId?: SortOrder
    planningId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccompanimentAvgOrderByAggregateInput = {
    phones?: SortOrder
    budget?: SortOrder
  }

  export type AccompanimentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adresse?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    usersid?: SortOrder
    fileId?: SortOrder
    projectId?: SortOrder
    planningId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccompanimentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adresse?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    usersid?: SortOrder
    fileId?: SortOrder
    projectId?: SortOrder
    planningId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccompanimentSumOrderByAggregateInput = {
    phones?: SortOrder
    budget?: SortOrder
  }

  export type ClasseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    usersId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClasseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    usersId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClasseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    usersId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignatureListRelationFilter = {
    every?: SignatureWhereInput
    some?: SignatureWhereInput
    none?: SignatureWhereInput
  }

  export type LeaveNullableScalarRelationFilter = {
    is?: LeaveWhereInput | null
    isNot?: LeaveWhereInput | null
  }

  export type AccompanimentNullableScalarRelationFilter = {
    is?: AccompanimentWhereInput | null
    isNot?: AccompanimentWhereInput | null
  }

  export type ClasseScalarRelationFilter = {
    is?: ClasseWhereInput
    isNot?: ClasseWhereInput
  }

  export type SignatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    commune?: SortOrder
    residential?: SortOrder
    disability?: SortOrder
    language?: SortOrder
    attestation?: SortOrder
    accompanimentId?: SortOrder
    classeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    commune?: SortOrder
    residential?: SortOrder
    disability?: SortOrder
    language?: SortOrder
    attestation?: SortOrder
    accompanimentId?: SortOrder
    classeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    profile?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    commune?: SortOrder
    residential?: SortOrder
    disability?: SortOrder
    language?: SortOrder
    attestation?: SortOrder
    accompanimentId?: SortOrder
    classeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatParticipantUserIdChatIdCompoundUniqueInput = {
    userId: string
    chatId: string
  }

  export type ChatParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    senderId?: SortOrder
    chatId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    senderId?: SortOrder
    chatId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    senderId?: SortOrder
    chatId?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageViewMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageViewCountOrderByAggregateInput = {
    id?: SortOrder
    view?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageViewMaxOrderByAggregateInput = {
    id?: SortOrder
    view?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageViewMinOrderByAggregateInput = {
    id?: SortOrder
    view?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningScalarRelationFilter = {
    is?: PlanningWhereInput
    isNot?: PlanningWhereInput
  }

  export type VisitsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    objetif?: SortOrder
    planningId?: SortOrder
  }

  export type VisitsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    objetif?: SortOrder
    planningId?: SortOrder
  }

  export type VisitsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    objetif?: SortOrder
    planningId?: SortOrder
  }

  export type VisitsListRelationFilter = {
    every?: VisitsWhereInput
    some?: VisitsWhereInput
    none?: VisitsWhereInput
  }

  export type VisitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanningCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type PlanningMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type PlanningMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type AccompanimentScalarRelationFilter = {
    is?: AccompanimentWhereInput
    isNot?: AccompanimentWhereInput
  }

  export type MapsCountOrderByAggregateInput = {
    id?: SortOrder
    accompanimentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapsMaxOrderByAggregateInput = {
    id?: SortOrder
    accompanimentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapsMinOrderByAggregateInput = {
    id?: SortOrder
    accompanimentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseScalarRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type PurchaseItemsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    image?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    purchaseId?: SortOrder
  }

  export type PurchaseItemsAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PurchaseItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    image?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    purchaseId?: SortOrder
  }

  export type PurchaseItemsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    image?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    purchaseId?: SortOrder
  }

  export type PurchaseItemsSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PurchaseItemsListRelationFilter = {
    every?: PurchaseItemsWhereInput
    some?: PurchaseItemsWhereInput
    none?: PurchaseItemsWhereInput
  }

  export type PurchaseItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type EmargementCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    signature?: SortOrder
    cni?: SortOrder
    PhotoCni?: SortOrder
    montant?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    memberId?: SortOrder
  }

  export type EmargementAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type EmargementMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    signature?: SortOrder
    cni?: SortOrder
    PhotoCni?: SortOrder
    montant?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    memberId?: SortOrder
  }

  export type EmargementMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    signature?: SortOrder
    cni?: SortOrder
    PhotoCni?: SortOrder
    montant?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    memberId?: SortOrder
  }

  export type EmargementSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type VisitsScalarRelationFilter = {
    is?: VisitsWhereInput
    isNot?: VisitsWhereInput
  }

  export type PersonnesListRelationFilter = {
    every?: PersonnesWhereInput
    some?: PersonnesWhereInput
    none?: PersonnesWhereInput
  }

  export type PersonnesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisiteTerrainCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisiteTerrainMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisiteTerrainMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    observations?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConflitCountOrderByAggregateInput = {
    id?: SortOrder
    nature?: SortOrder
    resolution?: SortOrder
    usersId?: SortOrder
    status?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConflitMaxOrderByAggregateInput = {
    id?: SortOrder
    nature?: SortOrder
    resolution?: SortOrder
    usersId?: SortOrder
    status?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConflitMinOrderByAggregateInput = {
    id?: SortOrder
    nature?: SortOrder
    resolution?: SortOrder
    usersId?: SortOrder
    status?: SortOrder
    accompanimentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RencontreCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    lieu?: SortOrder
    order?: SortOrder
    decisions?: SortOrder
    actions?: SortOrder
    accompanimentId?: SortOrder
    usersId?: SortOrder
  }

  export type RencontreMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    lieu?: SortOrder
    accompanimentId?: SortOrder
    usersId?: SortOrder
  }

  export type RencontreMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    lieu?: SortOrder
    accompanimentId?: SortOrder
    usersId?: SortOrder
  }

  export type UploadCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    date?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
  }

  export type UploadMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    date?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
  }

  export type UploadMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    date?: SortOrder
    fileId?: SortOrder
    userId?: SortOrder
  }

  export type ConflitCreateNestedOneWithoutPartieImpliquesInput = {
    create?: XOR<ConflitCreateWithoutPartieImpliquesInput, ConflitUncheckedCreateWithoutPartieImpliquesInput>
    connectOrCreate?: ConflitCreateOrConnectWithoutPartieImpliquesInput
    connect?: ConflitWhereUniqueInput
  }

  export type VisiteTerrainCreateNestedOneWithoutPersonnesInput = {
    create?: XOR<VisiteTerrainCreateWithoutPersonnesInput, VisiteTerrainUncheckedCreateWithoutPersonnesInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutPersonnesInput
    connect?: VisiteTerrainWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ConflitUpdateOneWithoutPartieImpliquesNestedInput = {
    create?: XOR<ConflitCreateWithoutPartieImpliquesInput, ConflitUncheckedCreateWithoutPartieImpliquesInput>
    connectOrCreate?: ConflitCreateOrConnectWithoutPartieImpliquesInput
    upsert?: ConflitUpsertWithoutPartieImpliquesInput
    disconnect?: ConflitWhereInput | boolean
    delete?: ConflitWhereInput | boolean
    connect?: ConflitWhereUniqueInput
    update?: XOR<XOR<ConflitUpdateToOneWithWhereWithoutPartieImpliquesInput, ConflitUpdateWithoutPartieImpliquesInput>, ConflitUncheckedUpdateWithoutPartieImpliquesInput>
  }

  export type VisiteTerrainUpdateOneWithoutPersonnesNestedInput = {
    create?: XOR<VisiteTerrainCreateWithoutPersonnesInput, VisiteTerrainUncheckedCreateWithoutPersonnesInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutPersonnesInput
    upsert?: VisiteTerrainUpsertWithoutPersonnesInput
    disconnect?: VisiteTerrainWhereInput | boolean
    delete?: VisiteTerrainWhereInput | boolean
    connect?: VisiteTerrainWhereUniqueInput
    update?: XOR<XOR<VisiteTerrainUpdateToOneWithWhereWithoutPersonnesInput, VisiteTerrainUpdateWithoutPersonnesInput>, VisiteTerrainUncheckedUpdateWithoutPersonnesInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MemberCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<MemberCreateWithoutSignaturesInput, MemberUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSignaturesInput
    connect?: MemberWhereUniqueInput
  }

  export type RencontreCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<RencontreCreateWithoutSignaturesInput, RencontreUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: RencontreCreateOrConnectWithoutSignaturesInput
    connect?: RencontreWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MemberUpdateOneRequiredWithoutSignaturesNestedInput = {
    create?: XOR<MemberCreateWithoutSignaturesInput, MemberUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSignaturesInput
    upsert?: MemberUpsertWithoutSignaturesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSignaturesInput, MemberUpdateWithoutSignaturesInput>, MemberUncheckedUpdateWithoutSignaturesInput>
  }

  export type RencontreUpdateOneWithoutSignaturesNestedInput = {
    create?: XOR<RencontreCreateWithoutSignaturesInput, RencontreUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: RencontreCreateOrConnectWithoutSignaturesInput
    upsert?: RencontreUpsertWithoutSignaturesInput
    disconnect?: RencontreWhereInput | boolean
    delete?: RencontreWhereInput | boolean
    connect?: RencontreWhereUniqueInput
    update?: XOR<XOR<RencontreUpdateToOneWithWhereWithoutSignaturesInput, RencontreUpdateWithoutSignaturesInput>, RencontreUncheckedUpdateWithoutSignaturesInput>
  }

  export type VisiteTerrainCreateNestedOneWithoutFilesInput = {
    create?: XOR<VisiteTerrainCreateWithoutFilesInput, VisiteTerrainUncheckedCreateWithoutFilesInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutFilesInput
    connect?: VisiteTerrainWhereUniqueInput
  }

  export type ConflitCreateNestedOneWithoutFilesInput = {
    create?: XOR<ConflitCreateWithoutFilesInput, ConflitUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ConflitCreateOrConnectWithoutFilesInput
    connect?: ConflitWhereUniqueInput
  }

  export type RencontreCreateNestedOneWithoutFilesInput = {
    create?: XOR<RencontreCreateWithoutFilesInput, RencontreUncheckedCreateWithoutFilesInput>
    connectOrCreate?: RencontreCreateOrConnectWithoutFilesInput
    connect?: RencontreWhereUniqueInput
  }

  export type UploadCreateNestedManyWithoutFileInput = {
    create?: XOR<UploadCreateWithoutFileInput, UploadUncheckedCreateWithoutFileInput> | UploadCreateWithoutFileInput[] | UploadUncheckedCreateWithoutFileInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutFileInput | UploadCreateOrConnectWithoutFileInput[]
    createMany?: UploadCreateManyFileInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type UsersCreateNestedManyWithoutCvInput = {
    create?: XOR<UsersCreateWithoutCvInput, UsersUncheckedCreateWithoutCvInput> | UsersCreateWithoutCvInput[] | UsersUncheckedCreateWithoutCvInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCvInput | UsersCreateOrConnectWithoutCvInput[]
    createMany?: UsersCreateManyCvInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type AccompanimentCreateNestedManyWithoutFileInput = {
    create?: XOR<AccompanimentCreateWithoutFileInput, AccompanimentUncheckedCreateWithoutFileInput> | AccompanimentCreateWithoutFileInput[] | AccompanimentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutFileInput | AccompanimentCreateOrConnectWithoutFileInput[]
    createMany?: AccompanimentCreateManyFileInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type AccompanimentCreateNestedManyWithoutMediaInput = {
    create?: XOR<AccompanimentCreateWithoutMediaInput, AccompanimentUncheckedCreateWithoutMediaInput> | AccompanimentCreateWithoutMediaInput[] | AccompanimentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMediaInput | AccompanimentCreateOrConnectWithoutMediaInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type UploadUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<UploadCreateWithoutFileInput, UploadUncheckedCreateWithoutFileInput> | UploadCreateWithoutFileInput[] | UploadUncheckedCreateWithoutFileInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutFileInput | UploadCreateOrConnectWithoutFileInput[]
    createMany?: UploadCreateManyFileInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutCvInput = {
    create?: XOR<UsersCreateWithoutCvInput, UsersUncheckedCreateWithoutCvInput> | UsersCreateWithoutCvInput[] | UsersUncheckedCreateWithoutCvInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCvInput | UsersCreateOrConnectWithoutCvInput[]
    createMany?: UsersCreateManyCvInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type AccompanimentUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<AccompanimentCreateWithoutFileInput, AccompanimentUncheckedCreateWithoutFileInput> | AccompanimentCreateWithoutFileInput[] | AccompanimentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutFileInput | AccompanimentCreateOrConnectWithoutFileInput[]
    createMany?: AccompanimentCreateManyFileInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type AccompanimentUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<AccompanimentCreateWithoutMediaInput, AccompanimentUncheckedCreateWithoutMediaInput> | AccompanimentCreateWithoutMediaInput[] | AccompanimentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMediaInput | AccompanimentCreateOrConnectWithoutMediaInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VisiteTerrainUpdateOneWithoutFilesNestedInput = {
    create?: XOR<VisiteTerrainCreateWithoutFilesInput, VisiteTerrainUncheckedCreateWithoutFilesInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutFilesInput
    upsert?: VisiteTerrainUpsertWithoutFilesInput
    disconnect?: VisiteTerrainWhereInput | boolean
    delete?: VisiteTerrainWhereInput | boolean
    connect?: VisiteTerrainWhereUniqueInput
    update?: XOR<XOR<VisiteTerrainUpdateToOneWithWhereWithoutFilesInput, VisiteTerrainUpdateWithoutFilesInput>, VisiteTerrainUncheckedUpdateWithoutFilesInput>
  }

  export type ConflitUpdateOneWithoutFilesNestedInput = {
    create?: XOR<ConflitCreateWithoutFilesInput, ConflitUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ConflitCreateOrConnectWithoutFilesInput
    upsert?: ConflitUpsertWithoutFilesInput
    disconnect?: ConflitWhereInput | boolean
    delete?: ConflitWhereInput | boolean
    connect?: ConflitWhereUniqueInput
    update?: XOR<XOR<ConflitUpdateToOneWithWhereWithoutFilesInput, ConflitUpdateWithoutFilesInput>, ConflitUncheckedUpdateWithoutFilesInput>
  }

  export type RencontreUpdateOneWithoutFilesNestedInput = {
    create?: XOR<RencontreCreateWithoutFilesInput, RencontreUncheckedCreateWithoutFilesInput>
    connectOrCreate?: RencontreCreateOrConnectWithoutFilesInput
    upsert?: RencontreUpsertWithoutFilesInput
    disconnect?: RencontreWhereInput | boolean
    delete?: RencontreWhereInput | boolean
    connect?: RencontreWhereUniqueInput
    update?: XOR<XOR<RencontreUpdateToOneWithWhereWithoutFilesInput, RencontreUpdateWithoutFilesInput>, RencontreUncheckedUpdateWithoutFilesInput>
  }

  export type UploadUpdateManyWithoutFileNestedInput = {
    create?: XOR<UploadCreateWithoutFileInput, UploadUncheckedCreateWithoutFileInput> | UploadCreateWithoutFileInput[] | UploadUncheckedCreateWithoutFileInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutFileInput | UploadCreateOrConnectWithoutFileInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutFileInput | UploadUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: UploadCreateManyFileInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutFileInput | UploadUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutFileInput | UploadUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type UsersUpdateManyWithoutCvNestedInput = {
    create?: XOR<UsersCreateWithoutCvInput, UsersUncheckedCreateWithoutCvInput> | UsersCreateWithoutCvInput[] | UsersUncheckedCreateWithoutCvInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCvInput | UsersCreateOrConnectWithoutCvInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutCvInput | UsersUpsertWithWhereUniqueWithoutCvInput[]
    createMany?: UsersCreateManyCvInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutCvInput | UsersUpdateWithWhereUniqueWithoutCvInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutCvInput | UsersUpdateManyWithWhereWithoutCvInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type AccompanimentUpdateManyWithoutFileNestedInput = {
    create?: XOR<AccompanimentCreateWithoutFileInput, AccompanimentUncheckedCreateWithoutFileInput> | AccompanimentCreateWithoutFileInput[] | AccompanimentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutFileInput | AccompanimentCreateOrConnectWithoutFileInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutFileInput | AccompanimentUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: AccompanimentCreateManyFileInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutFileInput | AccompanimentUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutFileInput | AccompanimentUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type AccompanimentUpdateManyWithoutMediaNestedInput = {
    create?: XOR<AccompanimentCreateWithoutMediaInput, AccompanimentUncheckedCreateWithoutMediaInput> | AccompanimentCreateWithoutMediaInput[] | AccompanimentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMediaInput | AccompanimentCreateOrConnectWithoutMediaInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutMediaInput | AccompanimentUpsertWithWhereUniqueWithoutMediaInput[]
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutMediaInput | AccompanimentUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutMediaInput | AccompanimentUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type UploadUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<UploadCreateWithoutFileInput, UploadUncheckedCreateWithoutFileInput> | UploadCreateWithoutFileInput[] | UploadUncheckedCreateWithoutFileInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutFileInput | UploadCreateOrConnectWithoutFileInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutFileInput | UploadUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: UploadCreateManyFileInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutFileInput | UploadUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutFileInput | UploadUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutCvNestedInput = {
    create?: XOR<UsersCreateWithoutCvInput, UsersUncheckedCreateWithoutCvInput> | UsersCreateWithoutCvInput[] | UsersUncheckedCreateWithoutCvInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutCvInput | UsersCreateOrConnectWithoutCvInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutCvInput | UsersUpsertWithWhereUniqueWithoutCvInput[]
    createMany?: UsersCreateManyCvInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutCvInput | UsersUpdateWithWhereUniqueWithoutCvInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutCvInput | UsersUpdateManyWithWhereWithoutCvInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type AccompanimentUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<AccompanimentCreateWithoutFileInput, AccompanimentUncheckedCreateWithoutFileInput> | AccompanimentCreateWithoutFileInput[] | AccompanimentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutFileInput | AccompanimentCreateOrConnectWithoutFileInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutFileInput | AccompanimentUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: AccompanimentCreateManyFileInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutFileInput | AccompanimentUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutFileInput | AccompanimentUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type AccompanimentUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<AccompanimentCreateWithoutMediaInput, AccompanimentUncheckedCreateWithoutMediaInput> | AccompanimentCreateWithoutMediaInput[] | AccompanimentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMediaInput | AccompanimentCreateOrConnectWithoutMediaInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutMediaInput | AccompanimentUpsertWithWhereUniqueWithoutMediaInput[]
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutMediaInput | AccompanimentUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutMediaInput | AccompanimentUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type UsersCreateroutesInput = {
    set: string[]
  }

  export type UsersCreateaccessInput = {
    set: string[]
  }

  export type FilesCreateNestedOneWithoutUsersInput = {
    create?: XOR<FilesCreateWithoutUsersInput, FilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FilesCreateOrConnectWithoutUsersInput
    connect?: FilesWhereUniqueInput
  }

  export type AccompanimentCreateNestedManyWithoutUsersInput = {
    create?: XOR<AccompanimentCreateWithoutUsersInput, AccompanimentUncheckedCreateWithoutUsersInput> | AccompanimentCreateWithoutUsersInput[] | AccompanimentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutUsersInput | AccompanimentCreateOrConnectWithoutUsersInput[]
    createMany?: AccompanimentCreateManyUsersInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type PlanningCreateNestedManyWithoutUsersInput = {
    create?: XOR<PlanningCreateWithoutUsersInput, PlanningUncheckedCreateWithoutUsersInput> | PlanningCreateWithoutUsersInput[] | PlanningUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutUsersInput | PlanningCreateOrConnectWithoutUsersInput[]
    createMany?: PlanningCreateManyUsersInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type EmargementCreateNestedManyWithoutUsersInput = {
    create?: XOR<EmargementCreateWithoutUsersInput, EmargementUncheckedCreateWithoutUsersInput> | EmargementCreateWithoutUsersInput[] | EmargementUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutUsersInput | EmargementCreateOrConnectWithoutUsersInput[]
    createMany?: EmargementCreateManyUsersInputEnvelope
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
  }

  export type VisiteTerrainCreateNestedManyWithoutUsersInput = {
    create?: XOR<VisiteTerrainCreateWithoutUsersInput, VisiteTerrainUncheckedCreateWithoutUsersInput> | VisiteTerrainCreateWithoutUsersInput[] | VisiteTerrainUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutUsersInput | VisiteTerrainCreateOrConnectWithoutUsersInput[]
    createMany?: VisiteTerrainCreateManyUsersInputEnvelope
    connect?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
  }

  export type RencontreCreateNestedManyWithoutUsersInput = {
    create?: XOR<RencontreCreateWithoutUsersInput, RencontreUncheckedCreateWithoutUsersInput> | RencontreCreateWithoutUsersInput[] | RencontreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutUsersInput | RencontreCreateOrConnectWithoutUsersInput[]
    createMany?: RencontreCreateManyUsersInputEnvelope
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
  }

  export type ConflitCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConflitCreateWithoutUsersInput, ConflitUncheckedCreateWithoutUsersInput> | ConflitCreateWithoutUsersInput[] | ConflitUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutUsersInput | ConflitCreateOrConnectWithoutUsersInput[]
    createMany?: ConflitCreateManyUsersInputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type ChatParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatParticipantCreateWithoutUserInput, ChatParticipantUncheckedCreateWithoutUserInput> | ChatParticipantCreateWithoutUserInput[] | ChatParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutUserInput | ChatParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChatParticipantCreateManyUserInputEnvelope
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UploadCreateNestedManyWithoutUserInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type MessageViewCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type ClasseCreateNestedManyWithoutUserInput = {
    create?: XOR<ClasseCreateWithoutUserInput, ClasseUncheckedCreateWithoutUserInput> | ClasseCreateWithoutUserInput[] | ClasseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutUserInput | ClasseCreateOrConnectWithoutUserInput[]
    createMany?: ClasseCreateManyUserInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type AccompanimentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<AccompanimentCreateWithoutUsersInput, AccompanimentUncheckedCreateWithoutUsersInput> | AccompanimentCreateWithoutUsersInput[] | AccompanimentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutUsersInput | AccompanimentCreateOrConnectWithoutUsersInput[]
    createMany?: AccompanimentCreateManyUsersInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type PlanningUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PlanningCreateWithoutUsersInput, PlanningUncheckedCreateWithoutUsersInput> | PlanningCreateWithoutUsersInput[] | PlanningUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutUsersInput | PlanningCreateOrConnectWithoutUsersInput[]
    createMany?: PlanningCreateManyUsersInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type EmargementUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<EmargementCreateWithoutUsersInput, EmargementUncheckedCreateWithoutUsersInput> | EmargementCreateWithoutUsersInput[] | EmargementUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutUsersInput | EmargementCreateOrConnectWithoutUsersInput[]
    createMany?: EmargementCreateManyUsersInputEnvelope
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
  }

  export type VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<VisiteTerrainCreateWithoutUsersInput, VisiteTerrainUncheckedCreateWithoutUsersInput> | VisiteTerrainCreateWithoutUsersInput[] | VisiteTerrainUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutUsersInput | VisiteTerrainCreateOrConnectWithoutUsersInput[]
    createMany?: VisiteTerrainCreateManyUsersInputEnvelope
    connect?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
  }

  export type RencontreUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RencontreCreateWithoutUsersInput, RencontreUncheckedCreateWithoutUsersInput> | RencontreCreateWithoutUsersInput[] | RencontreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutUsersInput | RencontreCreateOrConnectWithoutUsersInput[]
    createMany?: RencontreCreateManyUsersInputEnvelope
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
  }

  export type ConflitUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ConflitCreateWithoutUsersInput, ConflitUncheckedCreateWithoutUsersInput> | ConflitCreateWithoutUsersInput[] | ConflitUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutUsersInput | ConflitCreateOrConnectWithoutUsersInput[]
    createMany?: ConflitCreateManyUsersInputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type ChatParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatParticipantCreateWithoutUserInput, ChatParticipantUncheckedCreateWithoutUserInput> | ChatParticipantCreateWithoutUserInput[] | ChatParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutUserInput | ChatParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChatParticipantCreateManyUserInputEnvelope
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UploadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type MessageViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type ClasseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClasseCreateWithoutUserInput, ClasseUncheckedCreateWithoutUserInput> | ClasseCreateWithoutUserInput[] | ClasseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutUserInput | ClasseCreateOrConnectWithoutUserInput[]
    createMany?: ClasseCreateManyUserInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type EnumTypeFieldUpdateOperationsInput = {
    set?: $Enums.Type
  }

  export type UsersUpdateroutesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UsersUpdateaccessInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FilesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<FilesCreateWithoutUsersInput, FilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FilesCreateOrConnectWithoutUsersInput
    upsert?: FilesUpsertWithoutUsersInput
    disconnect?: FilesWhereInput | boolean
    delete?: FilesWhereInput | boolean
    connect?: FilesWhereUniqueInput
    update?: XOR<XOR<FilesUpdateToOneWithWhereWithoutUsersInput, FilesUpdateWithoutUsersInput>, FilesUncheckedUpdateWithoutUsersInput>
  }

  export type AccompanimentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<AccompanimentCreateWithoutUsersInput, AccompanimentUncheckedCreateWithoutUsersInput> | AccompanimentCreateWithoutUsersInput[] | AccompanimentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutUsersInput | AccompanimentCreateOrConnectWithoutUsersInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutUsersInput | AccompanimentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: AccompanimentCreateManyUsersInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutUsersInput | AccompanimentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutUsersInput | AccompanimentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type PlanningUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PlanningCreateWithoutUsersInput, PlanningUncheckedCreateWithoutUsersInput> | PlanningCreateWithoutUsersInput[] | PlanningUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutUsersInput | PlanningCreateOrConnectWithoutUsersInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutUsersInput | PlanningUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PlanningCreateManyUsersInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutUsersInput | PlanningUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutUsersInput | PlanningUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type EmargementUpdateManyWithoutUsersNestedInput = {
    create?: XOR<EmargementCreateWithoutUsersInput, EmargementUncheckedCreateWithoutUsersInput> | EmargementCreateWithoutUsersInput[] | EmargementUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutUsersInput | EmargementCreateOrConnectWithoutUsersInput[]
    upsert?: EmargementUpsertWithWhereUniqueWithoutUsersInput | EmargementUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: EmargementCreateManyUsersInputEnvelope
    set?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    disconnect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    delete?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    update?: EmargementUpdateWithWhereUniqueWithoutUsersInput | EmargementUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: EmargementUpdateManyWithWhereWithoutUsersInput | EmargementUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: EmargementScalarWhereInput | EmargementScalarWhereInput[]
  }

  export type VisiteTerrainUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VisiteTerrainCreateWithoutUsersInput, VisiteTerrainUncheckedCreateWithoutUsersInput> | VisiteTerrainCreateWithoutUsersInput[] | VisiteTerrainUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutUsersInput | VisiteTerrainCreateOrConnectWithoutUsersInput[]
    upsert?: VisiteTerrainUpsertWithWhereUniqueWithoutUsersInput | VisiteTerrainUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VisiteTerrainCreateManyUsersInputEnvelope
    set?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    disconnect?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    delete?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    connect?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    update?: VisiteTerrainUpdateWithWhereUniqueWithoutUsersInput | VisiteTerrainUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VisiteTerrainUpdateManyWithWhereWithoutUsersInput | VisiteTerrainUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VisiteTerrainScalarWhereInput | VisiteTerrainScalarWhereInput[]
  }

  export type RencontreUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RencontreCreateWithoutUsersInput, RencontreUncheckedCreateWithoutUsersInput> | RencontreCreateWithoutUsersInput[] | RencontreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutUsersInput | RencontreCreateOrConnectWithoutUsersInput[]
    upsert?: RencontreUpsertWithWhereUniqueWithoutUsersInput | RencontreUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: RencontreCreateManyUsersInputEnvelope
    set?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    disconnect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    delete?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    update?: RencontreUpdateWithWhereUniqueWithoutUsersInput | RencontreUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RencontreUpdateManyWithWhereWithoutUsersInput | RencontreUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RencontreScalarWhereInput | RencontreScalarWhereInput[]
  }

  export type ConflitUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConflitCreateWithoutUsersInput, ConflitUncheckedCreateWithoutUsersInput> | ConflitCreateWithoutUsersInput[] | ConflitUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutUsersInput | ConflitCreateOrConnectWithoutUsersInput[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutUsersInput | ConflitUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConflitCreateManyUsersInputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutUsersInput | ConflitUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConflitUpdateManyWithWhereWithoutUsersInput | ConflitUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type ChatParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatParticipantCreateWithoutUserInput, ChatParticipantUncheckedCreateWithoutUserInput> | ChatParticipantCreateWithoutUserInput[] | ChatParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutUserInput | ChatParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChatParticipantUpsertWithWhereUniqueWithoutUserInput | ChatParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatParticipantCreateManyUserInputEnvelope
    set?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    disconnect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    delete?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    update?: ChatParticipantUpdateWithWhereUniqueWithoutUserInput | ChatParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatParticipantUpdateManyWithWhereWithoutUserInput | ChatParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatParticipantScalarWhereInput | ChatParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UploadUpdateManyWithoutUserNestedInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutUserInput | UploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutUserInput | UploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutUserInput | UploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type MessageViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutUserInput | MessageViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutUserInput | MessageViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutUserInput | MessageViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type ClasseUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClasseCreateWithoutUserInput, ClasseUncheckedCreateWithoutUserInput> | ClasseCreateWithoutUserInput[] | ClasseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutUserInput | ClasseCreateOrConnectWithoutUserInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutUserInput | ClasseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClasseCreateManyUserInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutUserInput | ClasseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutUserInput | ClasseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type AccompanimentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<AccompanimentCreateWithoutUsersInput, AccompanimentUncheckedCreateWithoutUsersInput> | AccompanimentCreateWithoutUsersInput[] | AccompanimentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutUsersInput | AccompanimentCreateOrConnectWithoutUsersInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutUsersInput | AccompanimentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: AccompanimentCreateManyUsersInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutUsersInput | AccompanimentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutUsersInput | AccompanimentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type PlanningUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PlanningCreateWithoutUsersInput, PlanningUncheckedCreateWithoutUsersInput> | PlanningCreateWithoutUsersInput[] | PlanningUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutUsersInput | PlanningCreateOrConnectWithoutUsersInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutUsersInput | PlanningUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PlanningCreateManyUsersInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutUsersInput | PlanningUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutUsersInput | PlanningUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type EmargementUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<EmargementCreateWithoutUsersInput, EmargementUncheckedCreateWithoutUsersInput> | EmargementCreateWithoutUsersInput[] | EmargementUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutUsersInput | EmargementCreateOrConnectWithoutUsersInput[]
    upsert?: EmargementUpsertWithWhereUniqueWithoutUsersInput | EmargementUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: EmargementCreateManyUsersInputEnvelope
    set?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    disconnect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    delete?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    update?: EmargementUpdateWithWhereUniqueWithoutUsersInput | EmargementUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: EmargementUpdateManyWithWhereWithoutUsersInput | EmargementUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: EmargementScalarWhereInput | EmargementScalarWhereInput[]
  }

  export type VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VisiteTerrainCreateWithoutUsersInput, VisiteTerrainUncheckedCreateWithoutUsersInput> | VisiteTerrainCreateWithoutUsersInput[] | VisiteTerrainUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutUsersInput | VisiteTerrainCreateOrConnectWithoutUsersInput[]
    upsert?: VisiteTerrainUpsertWithWhereUniqueWithoutUsersInput | VisiteTerrainUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VisiteTerrainCreateManyUsersInputEnvelope
    set?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    disconnect?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    delete?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    connect?: VisiteTerrainWhereUniqueInput | VisiteTerrainWhereUniqueInput[]
    update?: VisiteTerrainUpdateWithWhereUniqueWithoutUsersInput | VisiteTerrainUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VisiteTerrainUpdateManyWithWhereWithoutUsersInput | VisiteTerrainUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VisiteTerrainScalarWhereInput | VisiteTerrainScalarWhereInput[]
  }

  export type RencontreUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RencontreCreateWithoutUsersInput, RencontreUncheckedCreateWithoutUsersInput> | RencontreCreateWithoutUsersInput[] | RencontreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutUsersInput | RencontreCreateOrConnectWithoutUsersInput[]
    upsert?: RencontreUpsertWithWhereUniqueWithoutUsersInput | RencontreUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: RencontreCreateManyUsersInputEnvelope
    set?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    disconnect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    delete?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    update?: RencontreUpdateWithWhereUniqueWithoutUsersInput | RencontreUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RencontreUpdateManyWithWhereWithoutUsersInput | RencontreUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RencontreScalarWhereInput | RencontreScalarWhereInput[]
  }

  export type ConflitUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ConflitCreateWithoutUsersInput, ConflitUncheckedCreateWithoutUsersInput> | ConflitCreateWithoutUsersInput[] | ConflitUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutUsersInput | ConflitCreateOrConnectWithoutUsersInput[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutUsersInput | ConflitUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ConflitCreateManyUsersInputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutUsersInput | ConflitUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ConflitUpdateManyWithWhereWithoutUsersInput | ConflitUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type ChatParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatParticipantCreateWithoutUserInput, ChatParticipantUncheckedCreateWithoutUserInput> | ChatParticipantCreateWithoutUserInput[] | ChatParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutUserInput | ChatParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChatParticipantUpsertWithWhereUniqueWithoutUserInput | ChatParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatParticipantCreateManyUserInputEnvelope
    set?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    disconnect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    delete?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    update?: ChatParticipantUpdateWithWhereUniqueWithoutUserInput | ChatParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatParticipantUpdateManyWithWhereWithoutUserInput | ChatParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatParticipantScalarWhereInput | ChatParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UploadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutUserInput | UploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutUserInput | UploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutUserInput | UploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type MessageViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput> | MessageViewCreateWithoutUserInput[] | MessageViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutUserInput | MessageViewCreateOrConnectWithoutUserInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutUserInput | MessageViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageViewCreateManyUserInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutUserInput | MessageViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutUserInput | MessageViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type ClasseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClasseCreateWithoutUserInput, ClasseUncheckedCreateWithoutUserInput> | ClasseCreateWithoutUserInput[] | ClasseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutUserInput | ClasseCreateOrConnectWithoutUserInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutUserInput | ClasseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClasseCreateManyUserInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutUserInput | ClasseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutUserInput | ClasseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type AccompanimentCreateNestedManyWithoutProjectInput = {
    create?: XOR<AccompanimentCreateWithoutProjectInput, AccompanimentUncheckedCreateWithoutProjectInput> | AccompanimentCreateWithoutProjectInput[] | AccompanimentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProjectInput | AccompanimentCreateOrConnectWithoutProjectInput[]
    createMany?: AccompanimentCreateManyProjectInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutProjectInput = {
    create?: XOR<LeaveCreateWithoutProjectInput, LeaveUncheckedCreateWithoutProjectInput> | LeaveCreateWithoutProjectInput[] | LeaveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutProjectInput | LeaveCreateOrConnectWithoutProjectInput[]
    createMany?: LeaveCreateManyProjectInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ClasseCreateNestedManyWithoutProjectInput = {
    create?: XOR<ClasseCreateWithoutProjectInput, ClasseUncheckedCreateWithoutProjectInput> | ClasseCreateWithoutProjectInput[] | ClasseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutProjectInput | ClasseCreateOrConnectWithoutProjectInput[]
    createMany?: ClasseCreateManyProjectInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type ChatCreateNestedOneWithoutProjectInput = {
    create?: XOR<ChatCreateWithoutProjectInput, ChatUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ChatCreateOrConnectWithoutProjectInput
    connect?: ChatWhereUniqueInput
  }

  export type AccompanimentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AccompanimentCreateWithoutProjectInput, AccompanimentUncheckedCreateWithoutProjectInput> | AccompanimentCreateWithoutProjectInput[] | AccompanimentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProjectInput | AccompanimentCreateOrConnectWithoutProjectInput[]
    createMany?: AccompanimentCreateManyProjectInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LeaveCreateWithoutProjectInput, LeaveUncheckedCreateWithoutProjectInput> | LeaveCreateWithoutProjectInput[] | LeaveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutProjectInput | LeaveCreateOrConnectWithoutProjectInput[]
    createMany?: LeaveCreateManyProjectInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ClasseUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ClasseCreateWithoutProjectInput, ClasseUncheckedCreateWithoutProjectInput> | ClasseCreateWithoutProjectInput[] | ClasseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutProjectInput | ClasseCreateOrConnectWithoutProjectInput[]
    createMany?: ClasseCreateManyProjectInputEnvelope
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ChatCreateWithoutProjectInput, ChatUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ChatCreateOrConnectWithoutProjectInput
    connect?: ChatWhereUniqueInput
  }

  export type AccompanimentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AccompanimentCreateWithoutProjectInput, AccompanimentUncheckedCreateWithoutProjectInput> | AccompanimentCreateWithoutProjectInput[] | AccompanimentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProjectInput | AccompanimentCreateOrConnectWithoutProjectInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutProjectInput | AccompanimentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AccompanimentCreateManyProjectInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutProjectInput | AccompanimentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutProjectInput | AccompanimentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LeaveCreateWithoutProjectInput, LeaveUncheckedCreateWithoutProjectInput> | LeaveCreateWithoutProjectInput[] | LeaveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutProjectInput | LeaveCreateOrConnectWithoutProjectInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutProjectInput | LeaveUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LeaveCreateManyProjectInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutProjectInput | LeaveUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutProjectInput | LeaveUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ClasseUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ClasseCreateWithoutProjectInput, ClasseUncheckedCreateWithoutProjectInput> | ClasseCreateWithoutProjectInput[] | ClasseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutProjectInput | ClasseCreateOrConnectWithoutProjectInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutProjectInput | ClasseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ClasseCreateManyProjectInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutProjectInput | ClasseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutProjectInput | ClasseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type ChatUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ChatCreateWithoutProjectInput, ChatUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ChatCreateOrConnectWithoutProjectInput
    upsert?: ChatUpsertWithoutProjectInput
    disconnect?: ChatWhereInput | boolean
    delete?: ChatWhereInput | boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutProjectInput, ChatUpdateWithoutProjectInput>, ChatUncheckedUpdateWithoutProjectInput>
  }

  export type AccompanimentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AccompanimentCreateWithoutProjectInput, AccompanimentUncheckedCreateWithoutProjectInput> | AccompanimentCreateWithoutProjectInput[] | AccompanimentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutProjectInput | AccompanimentCreateOrConnectWithoutProjectInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutProjectInput | AccompanimentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AccompanimentCreateManyProjectInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutProjectInput | AccompanimentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutProjectInput | AccompanimentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LeaveCreateWithoutProjectInput, LeaveUncheckedCreateWithoutProjectInput> | LeaveCreateWithoutProjectInput[] | LeaveUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutProjectInput | LeaveCreateOrConnectWithoutProjectInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutProjectInput | LeaveUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LeaveCreateManyProjectInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutProjectInput | LeaveUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutProjectInput | LeaveUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ClasseUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ClasseCreateWithoutProjectInput, ClasseUncheckedCreateWithoutProjectInput> | ClasseCreateWithoutProjectInput[] | ClasseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClasseCreateOrConnectWithoutProjectInput | ClasseCreateOrConnectWithoutProjectInput[]
    upsert?: ClasseUpsertWithWhereUniqueWithoutProjectInput | ClasseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ClasseCreateManyProjectInputEnvelope
    set?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    disconnect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    delete?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    connect?: ClasseWhereUniqueInput | ClasseWhereUniqueInput[]
    update?: ClasseUpdateWithWhereUniqueWithoutProjectInput | ClasseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ClasseUpdateManyWithWhereWithoutProjectInput | ClasseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
  }

  export type ChatUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ChatCreateWithoutProjectInput, ChatUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ChatCreateOrConnectWithoutProjectInput
    upsert?: ChatUpsertWithoutProjectInput
    disconnect?: ChatWhereInput | boolean
    delete?: ChatWhereInput | boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutProjectInput, ChatUpdateWithoutProjectInput>, ChatUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectCreateNestedOneWithoutLeaveInput = {
    create?: XOR<ProjectCreateWithoutLeaveInput, ProjectUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeaveInput
    connect?: ProjectWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutLeaveInput = {
    create?: XOR<MemberCreateWithoutLeaveInput, MemberUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLeaveInput
    connect?: MemberWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutLeaveNestedInput = {
    create?: XOR<ProjectCreateWithoutLeaveInput, ProjectUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeaveInput
    upsert?: ProjectUpsertWithoutLeaveInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLeaveInput, ProjectUpdateWithoutLeaveInput>, ProjectUncheckedUpdateWithoutLeaveInput>
  }

  export type MemberUpdateOneRequiredWithoutLeaveNestedInput = {
    create?: XOR<MemberCreateWithoutLeaveInput, MemberUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: MemberCreateOrConnectWithoutLeaveInput
    upsert?: MemberUpsertWithoutLeaveInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutLeaveInput, MemberUpdateWithoutLeaveInput>, MemberUncheckedUpdateWithoutLeaveInput>
  }

  export type AccompanimentCreatephonesInput = {
    set: number[]
  }

  export type UsersCreateNestedOneWithoutAccompanimentsInput = {
    create?: XOR<UsersCreateWithoutAccompanimentsInput, UsersUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAccompanimentsInput
    connect?: UsersWhereUniqueInput
  }

  export type MapsCreateNestedOneWithoutAccompanimentInput = {
    create?: XOR<MapsCreateWithoutAccompanimentInput, MapsUncheckedCreateWithoutAccompanimentInput>
    connectOrCreate?: MapsCreateOrConnectWithoutAccompanimentInput
    connect?: MapsWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<MemberCreateWithoutAccompanimentInput, MemberUncheckedCreateWithoutAccompanimentInput> | MemberCreateWithoutAccompanimentInput[] | MemberUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutAccompanimentInput | MemberCreateOrConnectWithoutAccompanimentInput[]
    createMany?: MemberCreateManyAccompanimentInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type FilesCreateNestedOneWithoutAccompanimentsInput = {
    create?: XOR<FilesCreateWithoutAccompanimentsInput, FilesUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: FilesCreateOrConnectWithoutAccompanimentsInput
    connect?: FilesWhereUniqueInput
  }

  export type FilesCreateNestedManyWithoutMediaInput = {
    create?: XOR<FilesCreateWithoutMediaInput, FilesUncheckedCreateWithoutMediaInput> | FilesCreateWithoutMediaInput[] | FilesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutMediaInput | FilesCreateOrConnectWithoutMediaInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<PurchaseCreateWithoutAccompanimentInput, PurchaseUncheckedCreateWithoutAccompanimentInput> | PurchaseCreateWithoutAccompanimentInput[] | PurchaseUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutAccompanimentInput | PurchaseCreateOrConnectWithoutAccompanimentInput[]
    createMany?: PurchaseCreateManyAccompanimentInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type ConflitCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<ConflitCreateWithoutAccompanimentInput, ConflitUncheckedCreateWithoutAccompanimentInput> | ConflitCreateWithoutAccompanimentInput[] | ConflitUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutAccompanimentInput | ConflitCreateOrConnectWithoutAccompanimentInput[]
    createMany?: ConflitCreateManyAccompanimentInputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type RencontreCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<RencontreCreateWithoutAccompanimentInput, RencontreUncheckedCreateWithoutAccompanimentInput> | RencontreCreateWithoutAccompanimentInput[] | RencontreUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutAccompanimentInput | RencontreCreateOrConnectWithoutAccompanimentInput[]
    createMany?: RencontreCreateManyAccompanimentInputEnvelope
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutAccompanimentsInput = {
    create?: XOR<ProjectCreateWithoutAccompanimentsInput, ProjectUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAccompanimentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PlanningCreateNestedOneWithoutAccompanimentsInput = {
    create?: XOR<PlanningCreateWithoutAccompanimentsInput, PlanningUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutAccompanimentsInput
    connect?: PlanningWhereUniqueInput
  }

  export type MapsUncheckedCreateNestedOneWithoutAccompanimentInput = {
    create?: XOR<MapsCreateWithoutAccompanimentInput, MapsUncheckedCreateWithoutAccompanimentInput>
    connectOrCreate?: MapsCreateOrConnectWithoutAccompanimentInput
    connect?: MapsWhereUniqueInput
  }

  export type MemberUncheckedCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<MemberCreateWithoutAccompanimentInput, MemberUncheckedCreateWithoutAccompanimentInput> | MemberCreateWithoutAccompanimentInput[] | MemberUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutAccompanimentInput | MemberCreateOrConnectWithoutAccompanimentInput[]
    createMany?: MemberCreateManyAccompanimentInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type FilesUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<FilesCreateWithoutMediaInput, FilesUncheckedCreateWithoutMediaInput> | FilesCreateWithoutMediaInput[] | FilesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutMediaInput | FilesCreateOrConnectWithoutMediaInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<PurchaseCreateWithoutAccompanimentInput, PurchaseUncheckedCreateWithoutAccompanimentInput> | PurchaseCreateWithoutAccompanimentInput[] | PurchaseUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutAccompanimentInput | PurchaseCreateOrConnectWithoutAccompanimentInput[]
    createMany?: PurchaseCreateManyAccompanimentInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type ConflitUncheckedCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<ConflitCreateWithoutAccompanimentInput, ConflitUncheckedCreateWithoutAccompanimentInput> | ConflitCreateWithoutAccompanimentInput[] | ConflitUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutAccompanimentInput | ConflitCreateOrConnectWithoutAccompanimentInput[]
    createMany?: ConflitCreateManyAccompanimentInputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type RencontreUncheckedCreateNestedManyWithoutAccompanimentInput = {
    create?: XOR<RencontreCreateWithoutAccompanimentInput, RencontreUncheckedCreateWithoutAccompanimentInput> | RencontreCreateWithoutAccompanimentInput[] | RencontreUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutAccompanimentInput | RencontreCreateOrConnectWithoutAccompanimentInput[]
    createMany?: RencontreCreateManyAccompanimentInputEnvelope
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
  }

  export type AccompanimentUpdatephonesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UsersUpdateOneRequiredWithoutAccompanimentsNestedInput = {
    create?: XOR<UsersCreateWithoutAccompanimentsInput, UsersUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAccompanimentsInput
    upsert?: UsersUpsertWithoutAccompanimentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutAccompanimentsInput, UsersUpdateWithoutAccompanimentsInput>, UsersUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type MapsUpdateOneWithoutAccompanimentNestedInput = {
    create?: XOR<MapsCreateWithoutAccompanimentInput, MapsUncheckedCreateWithoutAccompanimentInput>
    connectOrCreate?: MapsCreateOrConnectWithoutAccompanimentInput
    upsert?: MapsUpsertWithoutAccompanimentInput
    disconnect?: MapsWhereInput | boolean
    delete?: MapsWhereInput | boolean
    connect?: MapsWhereUniqueInput
    update?: XOR<XOR<MapsUpdateToOneWithWhereWithoutAccompanimentInput, MapsUpdateWithoutAccompanimentInput>, MapsUncheckedUpdateWithoutAccompanimentInput>
  }

  export type MemberUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<MemberCreateWithoutAccompanimentInput, MemberUncheckedCreateWithoutAccompanimentInput> | MemberCreateWithoutAccompanimentInput[] | MemberUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutAccompanimentInput | MemberCreateOrConnectWithoutAccompanimentInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutAccompanimentInput | MemberUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: MemberCreateManyAccompanimentInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutAccompanimentInput | MemberUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutAccompanimentInput | MemberUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type FilesUpdateOneRequiredWithoutAccompanimentsNestedInput = {
    create?: XOR<FilesCreateWithoutAccompanimentsInput, FilesUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: FilesCreateOrConnectWithoutAccompanimentsInput
    upsert?: FilesUpsertWithoutAccompanimentsInput
    connect?: FilesWhereUniqueInput
    update?: XOR<XOR<FilesUpdateToOneWithWhereWithoutAccompanimentsInput, FilesUpdateWithoutAccompanimentsInput>, FilesUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type FilesUpdateManyWithoutMediaNestedInput = {
    create?: XOR<FilesCreateWithoutMediaInput, FilesUncheckedCreateWithoutMediaInput> | FilesCreateWithoutMediaInput[] | FilesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutMediaInput | FilesCreateOrConnectWithoutMediaInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutMediaInput | FilesUpsertWithWhereUniqueWithoutMediaInput[]
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutMediaInput | FilesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutMediaInput | FilesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<PurchaseCreateWithoutAccompanimentInput, PurchaseUncheckedCreateWithoutAccompanimentInput> | PurchaseCreateWithoutAccompanimentInput[] | PurchaseUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutAccompanimentInput | PurchaseCreateOrConnectWithoutAccompanimentInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutAccompanimentInput | PurchaseUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: PurchaseCreateManyAccompanimentInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutAccompanimentInput | PurchaseUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutAccompanimentInput | PurchaseUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ConflitUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<ConflitCreateWithoutAccompanimentInput, ConflitUncheckedCreateWithoutAccompanimentInput> | ConflitCreateWithoutAccompanimentInput[] | ConflitUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutAccompanimentInput | ConflitCreateOrConnectWithoutAccompanimentInput[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutAccompanimentInput | ConflitUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: ConflitCreateManyAccompanimentInputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutAccompanimentInput | ConflitUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: ConflitUpdateManyWithWhereWithoutAccompanimentInput | ConflitUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type RencontreUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<RencontreCreateWithoutAccompanimentInput, RencontreUncheckedCreateWithoutAccompanimentInput> | RencontreCreateWithoutAccompanimentInput[] | RencontreUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutAccompanimentInput | RencontreCreateOrConnectWithoutAccompanimentInput[]
    upsert?: RencontreUpsertWithWhereUniqueWithoutAccompanimentInput | RencontreUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: RencontreCreateManyAccompanimentInputEnvelope
    set?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    disconnect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    delete?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    update?: RencontreUpdateWithWhereUniqueWithoutAccompanimentInput | RencontreUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: RencontreUpdateManyWithWhereWithoutAccompanimentInput | RencontreUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: RencontreScalarWhereInput | RencontreScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput = {
    create?: XOR<ProjectCreateWithoutAccompanimentsInput, ProjectUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAccompanimentsInput
    upsert?: ProjectUpsertWithoutAccompanimentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAccompanimentsInput, ProjectUpdateWithoutAccompanimentsInput>, ProjectUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type PlanningUpdateOneWithoutAccompanimentsNestedInput = {
    create?: XOR<PlanningCreateWithoutAccompanimentsInput, PlanningUncheckedCreateWithoutAccompanimentsInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutAccompanimentsInput
    upsert?: PlanningUpsertWithoutAccompanimentsInput
    disconnect?: PlanningWhereInput | boolean
    delete?: PlanningWhereInput | boolean
    connect?: PlanningWhereUniqueInput
    update?: XOR<XOR<PlanningUpdateToOneWithWhereWithoutAccompanimentsInput, PlanningUpdateWithoutAccompanimentsInput>, PlanningUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type MapsUncheckedUpdateOneWithoutAccompanimentNestedInput = {
    create?: XOR<MapsCreateWithoutAccompanimentInput, MapsUncheckedCreateWithoutAccompanimentInput>
    connectOrCreate?: MapsCreateOrConnectWithoutAccompanimentInput
    upsert?: MapsUpsertWithoutAccompanimentInput
    disconnect?: MapsWhereInput | boolean
    delete?: MapsWhereInput | boolean
    connect?: MapsWhereUniqueInput
    update?: XOR<XOR<MapsUpdateToOneWithWhereWithoutAccompanimentInput, MapsUpdateWithoutAccompanimentInput>, MapsUncheckedUpdateWithoutAccompanimentInput>
  }

  export type MemberUncheckedUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<MemberCreateWithoutAccompanimentInput, MemberUncheckedCreateWithoutAccompanimentInput> | MemberCreateWithoutAccompanimentInput[] | MemberUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutAccompanimentInput | MemberCreateOrConnectWithoutAccompanimentInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutAccompanimentInput | MemberUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: MemberCreateManyAccompanimentInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutAccompanimentInput | MemberUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutAccompanimentInput | MemberUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type FilesUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<FilesCreateWithoutMediaInput, FilesUncheckedCreateWithoutMediaInput> | FilesCreateWithoutMediaInput[] | FilesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutMediaInput | FilesCreateOrConnectWithoutMediaInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutMediaInput | FilesUpsertWithWhereUniqueWithoutMediaInput[]
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutMediaInput | FilesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutMediaInput | FilesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<PurchaseCreateWithoutAccompanimentInput, PurchaseUncheckedCreateWithoutAccompanimentInput> | PurchaseCreateWithoutAccompanimentInput[] | PurchaseUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutAccompanimentInput | PurchaseCreateOrConnectWithoutAccompanimentInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutAccompanimentInput | PurchaseUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: PurchaseCreateManyAccompanimentInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutAccompanimentInput | PurchaseUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutAccompanimentInput | PurchaseUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<ConflitCreateWithoutAccompanimentInput, ConflitUncheckedCreateWithoutAccompanimentInput> | ConflitCreateWithoutAccompanimentInput[] | ConflitUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: ConflitCreateOrConnectWithoutAccompanimentInput | ConflitCreateOrConnectWithoutAccompanimentInput[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutAccompanimentInput | ConflitUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: ConflitCreateManyAccompanimentInputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutAccompanimentInput | ConflitUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: ConflitUpdateManyWithWhereWithoutAccompanimentInput | ConflitUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput = {
    create?: XOR<RencontreCreateWithoutAccompanimentInput, RencontreUncheckedCreateWithoutAccompanimentInput> | RencontreCreateWithoutAccompanimentInput[] | RencontreUncheckedCreateWithoutAccompanimentInput[]
    connectOrCreate?: RencontreCreateOrConnectWithoutAccompanimentInput | RencontreCreateOrConnectWithoutAccompanimentInput[]
    upsert?: RencontreUpsertWithWhereUniqueWithoutAccompanimentInput | RencontreUpsertWithWhereUniqueWithoutAccompanimentInput[]
    createMany?: RencontreCreateManyAccompanimentInputEnvelope
    set?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    disconnect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    delete?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    connect?: RencontreWhereUniqueInput | RencontreWhereUniqueInput[]
    update?: RencontreUpdateWithWhereUniqueWithoutAccompanimentInput | RencontreUpdateWithWhereUniqueWithoutAccompanimentInput[]
    updateMany?: RencontreUpdateManyWithWhereWithoutAccompanimentInput | RencontreUpdateManyWithWhereWithoutAccompanimentInput[]
    deleteMany?: RencontreScalarWhereInput | RencontreScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutClasseInput = {
    create?: XOR<UsersCreateWithoutClasseInput, UsersUncheckedCreateWithoutClasseInput>
    connectOrCreate?: UsersCreateOrConnectWithoutClasseInput
    connect?: UsersWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutClasseInput = {
    create?: XOR<MemberCreateWithoutClasseInput, MemberUncheckedCreateWithoutClasseInput> | MemberCreateWithoutClasseInput[] | MemberUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutClasseInput | MemberCreateOrConnectWithoutClasseInput[]
    createMany?: MemberCreateManyClasseInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutClassesInput = {
    create?: XOR<ProjectCreateWithoutClassesInput, ProjectUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutClassesInput
    connect?: ProjectWhereUniqueInput
  }

  export type MemberUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<MemberCreateWithoutClasseInput, MemberUncheckedCreateWithoutClasseInput> | MemberCreateWithoutClasseInput[] | MemberUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutClasseInput | MemberCreateOrConnectWithoutClasseInput[]
    createMany?: MemberCreateManyClasseInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutClasseNestedInput = {
    create?: XOR<UsersCreateWithoutClasseInput, UsersUncheckedCreateWithoutClasseInput>
    connectOrCreate?: UsersCreateOrConnectWithoutClasseInput
    upsert?: UsersUpsertWithoutClasseInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutClasseInput, UsersUpdateWithoutClasseInput>, UsersUncheckedUpdateWithoutClasseInput>
  }

  export type MemberUpdateManyWithoutClasseNestedInput = {
    create?: XOR<MemberCreateWithoutClasseInput, MemberUncheckedCreateWithoutClasseInput> | MemberCreateWithoutClasseInput[] | MemberUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutClasseInput | MemberCreateOrConnectWithoutClasseInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutClasseInput | MemberUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: MemberCreateManyClasseInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutClasseInput | MemberUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutClasseInput | MemberUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<ProjectCreateWithoutClassesInput, ProjectUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutClassesInput
    upsert?: ProjectUpsertWithoutClassesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutClassesInput, ProjectUpdateWithoutClassesInput>, ProjectUncheckedUpdateWithoutClassesInput>
  }

  export type MemberUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<MemberCreateWithoutClasseInput, MemberUncheckedCreateWithoutClasseInput> | MemberCreateWithoutClasseInput[] | MemberUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutClasseInput | MemberCreateOrConnectWithoutClasseInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutClasseInput | MemberUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: MemberCreateManyClasseInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutClasseInput | MemberUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutClasseInput | MemberUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type SignatureCreateNestedManyWithoutMemberInput = {
    create?: XOR<SignatureCreateWithoutMemberInput, SignatureUncheckedCreateWithoutMemberInput> | SignatureCreateWithoutMemberInput[] | SignatureUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutMemberInput | SignatureCreateOrConnectWithoutMemberInput[]
    createMany?: SignatureCreateManyMemberInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type EmargementCreateNestedManyWithoutMemberInput = {
    create?: XOR<EmargementCreateWithoutMemberInput, EmargementUncheckedCreateWithoutMemberInput> | EmargementCreateWithoutMemberInput[] | EmargementUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutMemberInput | EmargementCreateOrConnectWithoutMemberInput[]
    createMany?: EmargementCreateManyMemberInputEnvelope
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
  }

  export type LeaveCreateNestedOneWithoutMemberInput = {
    create?: XOR<LeaveCreateWithoutMemberInput, LeaveUncheckedCreateWithoutMemberInput>
    connectOrCreate?: LeaveCreateOrConnectWithoutMemberInput
    connect?: LeaveWhereUniqueInput
  }

  export type AccompanimentCreateNestedOneWithoutMembersInput = {
    create?: XOR<AccompanimentCreateWithoutMembersInput, AccompanimentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMembersInput
    connect?: AccompanimentWhereUniqueInput
  }

  export type ClasseCreateNestedOneWithoutMembersInput = {
    create?: XOR<ClasseCreateWithoutMembersInput, ClasseUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutMembersInput
    connect?: ClasseWhereUniqueInput
  }

  export type SignatureUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<SignatureCreateWithoutMemberInput, SignatureUncheckedCreateWithoutMemberInput> | SignatureCreateWithoutMemberInput[] | SignatureUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutMemberInput | SignatureCreateOrConnectWithoutMemberInput[]
    createMany?: SignatureCreateManyMemberInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type EmargementUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<EmargementCreateWithoutMemberInput, EmargementUncheckedCreateWithoutMemberInput> | EmargementCreateWithoutMemberInput[] | EmargementUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutMemberInput | EmargementCreateOrConnectWithoutMemberInput[]
    createMany?: EmargementCreateManyMemberInputEnvelope
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<LeaveCreateWithoutMemberInput, LeaveUncheckedCreateWithoutMemberInput>
    connectOrCreate?: LeaveCreateOrConnectWithoutMemberInput
    connect?: LeaveWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type SignatureUpdateManyWithoutMemberNestedInput = {
    create?: XOR<SignatureCreateWithoutMemberInput, SignatureUncheckedCreateWithoutMemberInput> | SignatureCreateWithoutMemberInput[] | SignatureUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutMemberInput | SignatureCreateOrConnectWithoutMemberInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutMemberInput | SignatureUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: SignatureCreateManyMemberInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutMemberInput | SignatureUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutMemberInput | SignatureUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type EmargementUpdateManyWithoutMemberNestedInput = {
    create?: XOR<EmargementCreateWithoutMemberInput, EmargementUncheckedCreateWithoutMemberInput> | EmargementCreateWithoutMemberInput[] | EmargementUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutMemberInput | EmargementCreateOrConnectWithoutMemberInput[]
    upsert?: EmargementUpsertWithWhereUniqueWithoutMemberInput | EmargementUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: EmargementCreateManyMemberInputEnvelope
    set?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    disconnect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    delete?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    update?: EmargementUpdateWithWhereUniqueWithoutMemberInput | EmargementUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: EmargementUpdateManyWithWhereWithoutMemberInput | EmargementUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: EmargementScalarWhereInput | EmargementScalarWhereInput[]
  }

  export type LeaveUpdateOneWithoutMemberNestedInput = {
    create?: XOR<LeaveCreateWithoutMemberInput, LeaveUncheckedCreateWithoutMemberInput>
    connectOrCreate?: LeaveCreateOrConnectWithoutMemberInput
    upsert?: LeaveUpsertWithoutMemberInput
    disconnect?: LeaveWhereInput | boolean
    delete?: LeaveWhereInput | boolean
    connect?: LeaveWhereUniqueInput
    update?: XOR<XOR<LeaveUpdateToOneWithWhereWithoutMemberInput, LeaveUpdateWithoutMemberInput>, LeaveUncheckedUpdateWithoutMemberInput>
  }

  export type AccompanimentUpdateOneWithoutMembersNestedInput = {
    create?: XOR<AccompanimentCreateWithoutMembersInput, AccompanimentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMembersInput
    upsert?: AccompanimentUpsertWithoutMembersInput
    disconnect?: AccompanimentWhereInput | boolean
    delete?: AccompanimentWhereInput | boolean
    connect?: AccompanimentWhereUniqueInput
    update?: XOR<XOR<AccompanimentUpdateToOneWithWhereWithoutMembersInput, AccompanimentUpdateWithoutMembersInput>, AccompanimentUncheckedUpdateWithoutMembersInput>
  }

  export type ClasseUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ClasseCreateWithoutMembersInput, ClasseUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutMembersInput
    upsert?: ClasseUpsertWithoutMembersInput
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutMembersInput, ClasseUpdateWithoutMembersInput>, ClasseUncheckedUpdateWithoutMembersInput>
  }

  export type SignatureUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<SignatureCreateWithoutMemberInput, SignatureUncheckedCreateWithoutMemberInput> | SignatureCreateWithoutMemberInput[] | SignatureUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutMemberInput | SignatureCreateOrConnectWithoutMemberInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutMemberInput | SignatureUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: SignatureCreateManyMemberInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutMemberInput | SignatureUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutMemberInput | SignatureUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type EmargementUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<EmargementCreateWithoutMemberInput, EmargementUncheckedCreateWithoutMemberInput> | EmargementCreateWithoutMemberInput[] | EmargementUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: EmargementCreateOrConnectWithoutMemberInput | EmargementCreateOrConnectWithoutMemberInput[]
    upsert?: EmargementUpsertWithWhereUniqueWithoutMemberInput | EmargementUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: EmargementCreateManyMemberInputEnvelope
    set?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    disconnect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    delete?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    connect?: EmargementWhereUniqueInput | EmargementWhereUniqueInput[]
    update?: EmargementUpdateWithWhereUniqueWithoutMemberInput | EmargementUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: EmargementUpdateManyWithWhereWithoutMemberInput | EmargementUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: EmargementScalarWhereInput | EmargementScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<LeaveCreateWithoutMemberInput, LeaveUncheckedCreateWithoutMemberInput>
    connectOrCreate?: LeaveCreateOrConnectWithoutMemberInput
    upsert?: LeaveUpsertWithoutMemberInput
    disconnect?: LeaveWhereInput | boolean
    delete?: LeaveWhereInput | boolean
    connect?: LeaveWhereUniqueInput
    update?: XOR<XOR<LeaveUpdateToOneWithWhereWithoutMemberInput, LeaveUpdateWithoutMemberInput>, LeaveUncheckedUpdateWithoutMemberInput>
  }

  export type ProjectCreateNestedOneWithoutChatInput = {
    create?: XOR<ProjectCreateWithoutChatInput, ProjectUncheckedCreateWithoutChatInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutChatInput
    connect?: ProjectWhereUniqueInput
  }

  export type ChatParticipantCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatParticipantCreateWithoutChatInput, ChatParticipantUncheckedCreateWithoutChatInput> | ChatParticipantCreateWithoutChatInput[] | ChatParticipantUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutChatInput | ChatParticipantCreateOrConnectWithoutChatInput[]
    createMany?: ChatParticipantCreateManyChatInputEnvelope
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatParticipantUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatParticipantCreateWithoutChatInput, ChatParticipantUncheckedCreateWithoutChatInput> | ChatParticipantCreateWithoutChatInput[] | ChatParticipantUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutChatInput | ChatParticipantCreateOrConnectWithoutChatInput[]
    createMany?: ChatParticipantCreateManyChatInputEnvelope
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<ProjectCreateWithoutChatInput, ProjectUncheckedCreateWithoutChatInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutChatInput
    upsert?: ProjectUpsertWithoutChatInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutChatInput, ProjectUpdateWithoutChatInput>, ProjectUncheckedUpdateWithoutChatInput>
  }

  export type ChatParticipantUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatParticipantCreateWithoutChatInput, ChatParticipantUncheckedCreateWithoutChatInput> | ChatParticipantCreateWithoutChatInput[] | ChatParticipantUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutChatInput | ChatParticipantCreateOrConnectWithoutChatInput[]
    upsert?: ChatParticipantUpsertWithWhereUniqueWithoutChatInput | ChatParticipantUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatParticipantCreateManyChatInputEnvelope
    set?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    disconnect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    delete?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    update?: ChatParticipantUpdateWithWhereUniqueWithoutChatInput | ChatParticipantUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatParticipantUpdateManyWithWhereWithoutChatInput | ChatParticipantUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatParticipantScalarWhereInput | ChatParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatParticipantUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatParticipantCreateWithoutChatInput, ChatParticipantUncheckedCreateWithoutChatInput> | ChatParticipantCreateWithoutChatInput[] | ChatParticipantUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatParticipantCreateOrConnectWithoutChatInput | ChatParticipantCreateOrConnectWithoutChatInput[]
    upsert?: ChatParticipantUpsertWithWhereUniqueWithoutChatInput | ChatParticipantUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatParticipantCreateManyChatInputEnvelope
    set?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    disconnect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    delete?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    connect?: ChatParticipantWhereUniqueInput | ChatParticipantWhereUniqueInput[]
    update?: ChatParticipantUpdateWithWhereUniqueWithoutChatInput | ChatParticipantUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatParticipantUpdateManyWithWhereWithoutChatInput | ChatParticipantUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatParticipantScalarWhereInput | ChatParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutChatParticipantInput = {
    create?: XOR<UsersCreateWithoutChatParticipantInput, UsersUncheckedCreateWithoutChatParticipantInput>
    connectOrCreate?: UsersCreateOrConnectWithoutChatParticipantInput
    connect?: UsersWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ChatCreateWithoutParticipantsInput, ChatUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ChatCreateOrConnectWithoutParticipantsInput
    connect?: ChatWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutChatParticipantNestedInput = {
    create?: XOR<UsersCreateWithoutChatParticipantInput, UsersUncheckedCreateWithoutChatParticipantInput>
    connectOrCreate?: UsersCreateOrConnectWithoutChatParticipantInput
    upsert?: UsersUpsertWithoutChatParticipantInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutChatParticipantInput, UsersUpdateWithoutChatParticipantInput>, UsersUncheckedUpdateWithoutChatParticipantInput>
  }

  export type ChatUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ChatCreateWithoutParticipantsInput, ChatUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ChatCreateOrConnectWithoutParticipantsInput
    upsert?: ChatUpsertWithoutParticipantsInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutParticipantsInput, ChatUpdateWithoutParticipantsInput>, ChatUncheckedUpdateWithoutParticipantsInput>
  }

  export type MessageViewCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutMessageInput = {
    create?: XOR<UsersCreateWithoutMessageInput, UsersUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessageInput
    connect?: UsersWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type MessageViewUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
  }

  export type MessageViewUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutMessageInput | MessageViewUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutMessageInput | MessageViewUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutMessageInput | MessageViewUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<UsersCreateWithoutMessageInput, UsersUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessageInput
    upsert?: UsersUpsertWithoutMessageInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessageInput, UsersUpdateWithoutMessageInput>, UsersUncheckedUpdateWithoutMessageInput>
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageViewUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput> | MessageViewCreateWithoutMessageInput[] | MessageViewUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageViewCreateOrConnectWithoutMessageInput | MessageViewCreateOrConnectWithoutMessageInput[]
    upsert?: MessageViewUpsertWithWhereUniqueWithoutMessageInput | MessageViewUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageViewCreateManyMessageInputEnvelope
    set?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    disconnect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    delete?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    connect?: MessageViewWhereUniqueInput | MessageViewWhereUniqueInput[]
    update?: MessageViewUpdateWithWhereUniqueWithoutMessageInput | MessageViewUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageViewUpdateManyWithWhereWithoutMessageInput | MessageViewUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutMessageViewInput = {
    create?: XOR<MessageCreateWithoutMessageViewInput, MessageUncheckedCreateWithoutMessageViewInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessageViewInput
    connect?: MessageWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutMessageViewInput = {
    create?: XOR<UsersCreateWithoutMessageViewInput, UsersUncheckedCreateWithoutMessageViewInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessageViewInput
    connect?: UsersWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutMessageViewNestedInput = {
    create?: XOR<MessageCreateWithoutMessageViewInput, MessageUncheckedCreateWithoutMessageViewInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessageViewInput
    upsert?: MessageUpsertWithoutMessageViewInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutMessageViewInput, MessageUpdateWithoutMessageViewInput>, MessageUncheckedUpdateWithoutMessageViewInput>
  }

  export type UsersUpdateOneRequiredWithoutMessageViewNestedInput = {
    create?: XOR<UsersCreateWithoutMessageViewInput, UsersUncheckedCreateWithoutMessageViewInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessageViewInput
    upsert?: UsersUpsertWithoutMessageViewInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessageViewInput, UsersUpdateWithoutMessageViewInput>, UsersUncheckedUpdateWithoutMessageViewInput>
  }

  export type PlanningCreateNestedOneWithoutVisitInput = {
    create?: XOR<PlanningCreateWithoutVisitInput, PlanningUncheckedCreateWithoutVisitInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutVisitInput
    connect?: PlanningWhereUniqueInput
  }

  export type VisiteTerrainCreateNestedOneWithoutVisitInput = {
    create?: XOR<VisiteTerrainCreateWithoutVisitInput, VisiteTerrainUncheckedCreateWithoutVisitInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutVisitInput
    connect?: VisiteTerrainWhereUniqueInput
  }

  export type VisiteTerrainUncheckedCreateNestedOneWithoutVisitInput = {
    create?: XOR<VisiteTerrainCreateWithoutVisitInput, VisiteTerrainUncheckedCreateWithoutVisitInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutVisitInput
    connect?: VisiteTerrainWhereUniqueInput
  }

  export type PlanningUpdateOneRequiredWithoutVisitNestedInput = {
    create?: XOR<PlanningCreateWithoutVisitInput, PlanningUncheckedCreateWithoutVisitInput>
    connectOrCreate?: PlanningCreateOrConnectWithoutVisitInput
    upsert?: PlanningUpsertWithoutVisitInput
    connect?: PlanningWhereUniqueInput
    update?: XOR<XOR<PlanningUpdateToOneWithWhereWithoutVisitInput, PlanningUpdateWithoutVisitInput>, PlanningUncheckedUpdateWithoutVisitInput>
  }

  export type VisiteTerrainUpdateOneWithoutVisitNestedInput = {
    create?: XOR<VisiteTerrainCreateWithoutVisitInput, VisiteTerrainUncheckedCreateWithoutVisitInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutVisitInput
    upsert?: VisiteTerrainUpsertWithoutVisitInput
    disconnect?: VisiteTerrainWhereInput | boolean
    delete?: VisiteTerrainWhereInput | boolean
    connect?: VisiteTerrainWhereUniqueInput
    update?: XOR<XOR<VisiteTerrainUpdateToOneWithWhereWithoutVisitInput, VisiteTerrainUpdateWithoutVisitInput>, VisiteTerrainUncheckedUpdateWithoutVisitInput>
  }

  export type VisiteTerrainUncheckedUpdateOneWithoutVisitNestedInput = {
    create?: XOR<VisiteTerrainCreateWithoutVisitInput, VisiteTerrainUncheckedCreateWithoutVisitInput>
    connectOrCreate?: VisiteTerrainCreateOrConnectWithoutVisitInput
    upsert?: VisiteTerrainUpsertWithoutVisitInput
    disconnect?: VisiteTerrainWhereInput | boolean
    delete?: VisiteTerrainWhereInput | boolean
    connect?: VisiteTerrainWhereUniqueInput
    update?: XOR<XOR<VisiteTerrainUpdateToOneWithWhereWithoutVisitInput, VisiteTerrainUpdateWithoutVisitInput>, VisiteTerrainUncheckedUpdateWithoutVisitInput>
  }

  export type AccompanimentCreateNestedManyWithoutPlanningInput = {
    create?: XOR<AccompanimentCreateWithoutPlanningInput, AccompanimentUncheckedCreateWithoutPlanningInput> | AccompanimentCreateWithoutPlanningInput[] | AccompanimentUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutPlanningInput | AccompanimentCreateOrConnectWithoutPlanningInput[]
    createMany?: AccompanimentCreateManyPlanningInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type VisitsCreateNestedManyWithoutPlanningInput = {
    create?: XOR<VisitsCreateWithoutPlanningInput, VisitsUncheckedCreateWithoutPlanningInput> | VisitsCreateWithoutPlanningInput[] | VisitsUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: VisitsCreateOrConnectWithoutPlanningInput | VisitsCreateOrConnectWithoutPlanningInput[]
    createMany?: VisitsCreateManyPlanningInputEnvelope
    connect?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutPlanningsInput = {
    create?: XOR<UsersCreateWithoutPlanningsInput, UsersUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPlanningsInput
    connect?: UsersWhereUniqueInput
  }

  export type AccompanimentUncheckedCreateNestedManyWithoutPlanningInput = {
    create?: XOR<AccompanimentCreateWithoutPlanningInput, AccompanimentUncheckedCreateWithoutPlanningInput> | AccompanimentCreateWithoutPlanningInput[] | AccompanimentUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutPlanningInput | AccompanimentCreateOrConnectWithoutPlanningInput[]
    createMany?: AccompanimentCreateManyPlanningInputEnvelope
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
  }

  export type VisitsUncheckedCreateNestedManyWithoutPlanningInput = {
    create?: XOR<VisitsCreateWithoutPlanningInput, VisitsUncheckedCreateWithoutPlanningInput> | VisitsCreateWithoutPlanningInput[] | VisitsUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: VisitsCreateOrConnectWithoutPlanningInput | VisitsCreateOrConnectWithoutPlanningInput[]
    createMany?: VisitsCreateManyPlanningInputEnvelope
    connect?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
  }

  export type AccompanimentUpdateManyWithoutPlanningNestedInput = {
    create?: XOR<AccompanimentCreateWithoutPlanningInput, AccompanimentUncheckedCreateWithoutPlanningInput> | AccompanimentCreateWithoutPlanningInput[] | AccompanimentUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutPlanningInput | AccompanimentCreateOrConnectWithoutPlanningInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutPlanningInput | AccompanimentUpsertWithWhereUniqueWithoutPlanningInput[]
    createMany?: AccompanimentCreateManyPlanningInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutPlanningInput | AccompanimentUpdateWithWhereUniqueWithoutPlanningInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutPlanningInput | AccompanimentUpdateManyWithWhereWithoutPlanningInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type VisitsUpdateManyWithoutPlanningNestedInput = {
    create?: XOR<VisitsCreateWithoutPlanningInput, VisitsUncheckedCreateWithoutPlanningInput> | VisitsCreateWithoutPlanningInput[] | VisitsUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: VisitsCreateOrConnectWithoutPlanningInput | VisitsCreateOrConnectWithoutPlanningInput[]
    upsert?: VisitsUpsertWithWhereUniqueWithoutPlanningInput | VisitsUpsertWithWhereUniqueWithoutPlanningInput[]
    createMany?: VisitsCreateManyPlanningInputEnvelope
    set?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    disconnect?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    delete?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    connect?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    update?: VisitsUpdateWithWhereUniqueWithoutPlanningInput | VisitsUpdateWithWhereUniqueWithoutPlanningInput[]
    updateMany?: VisitsUpdateManyWithWhereWithoutPlanningInput | VisitsUpdateManyWithWhereWithoutPlanningInput[]
    deleteMany?: VisitsScalarWhereInput | VisitsScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutPlanningsNestedInput = {
    create?: XOR<UsersCreateWithoutPlanningsInput, UsersUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPlanningsInput
    upsert?: UsersUpsertWithoutPlanningsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPlanningsInput, UsersUpdateWithoutPlanningsInput>, UsersUncheckedUpdateWithoutPlanningsInput>
  }

  export type AccompanimentUncheckedUpdateManyWithoutPlanningNestedInput = {
    create?: XOR<AccompanimentCreateWithoutPlanningInput, AccompanimentUncheckedCreateWithoutPlanningInput> | AccompanimentCreateWithoutPlanningInput[] | AccompanimentUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: AccompanimentCreateOrConnectWithoutPlanningInput | AccompanimentCreateOrConnectWithoutPlanningInput[]
    upsert?: AccompanimentUpsertWithWhereUniqueWithoutPlanningInput | AccompanimentUpsertWithWhereUniqueWithoutPlanningInput[]
    createMany?: AccompanimentCreateManyPlanningInputEnvelope
    set?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    disconnect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    delete?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    connect?: AccompanimentWhereUniqueInput | AccompanimentWhereUniqueInput[]
    update?: AccompanimentUpdateWithWhereUniqueWithoutPlanningInput | AccompanimentUpdateWithWhereUniqueWithoutPlanningInput[]
    updateMany?: AccompanimentUpdateManyWithWhereWithoutPlanningInput | AccompanimentUpdateManyWithWhereWithoutPlanningInput[]
    deleteMany?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
  }

  export type VisitsUncheckedUpdateManyWithoutPlanningNestedInput = {
    create?: XOR<VisitsCreateWithoutPlanningInput, VisitsUncheckedCreateWithoutPlanningInput> | VisitsCreateWithoutPlanningInput[] | VisitsUncheckedCreateWithoutPlanningInput[]
    connectOrCreate?: VisitsCreateOrConnectWithoutPlanningInput | VisitsCreateOrConnectWithoutPlanningInput[]
    upsert?: VisitsUpsertWithWhereUniqueWithoutPlanningInput | VisitsUpsertWithWhereUniqueWithoutPlanningInput[]
    createMany?: VisitsCreateManyPlanningInputEnvelope
    set?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    disconnect?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    delete?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    connect?: VisitsWhereUniqueInput | VisitsWhereUniqueInput[]
    update?: VisitsUpdateWithWhereUniqueWithoutPlanningInput | VisitsUpdateWithWhereUniqueWithoutPlanningInput[]
    updateMany?: VisitsUpdateManyWithWhereWithoutPlanningInput | VisitsUpdateManyWithWhereWithoutPlanningInput[]
    deleteMany?: VisitsScalarWhereInput | VisitsScalarWhereInput[]
  }

  export type AccompanimentCreateNestedOneWithoutMapInput = {
    create?: XOR<AccompanimentCreateWithoutMapInput, AccompanimentUncheckedCreateWithoutMapInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMapInput
    connect?: AccompanimentWhereUniqueInput
  }

  export type AccompanimentUpdateOneRequiredWithoutMapNestedInput = {
    create?: XOR<AccompanimentCreateWithoutMapInput, AccompanimentUncheckedCreateWithoutMapInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutMapInput
    upsert?: AccompanimentUpsertWithoutMapInput
    connect?: AccompanimentWhereUniqueInput
    update?: XOR<XOR<AccompanimentUpdateToOneWithWhereWithoutMapInput, AccompanimentUpdateWithoutMapInput>, AccompanimentUncheckedUpdateWithoutMapInput>
  }

  export type PurchaseCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<PurchaseCreateWithoutPurchaseItemsInput, PurchaseUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchaseItemsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<PurchaseCreateWithoutPurchaseItemsInput, PurchaseUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchaseItemsInput
    upsert?: PurchaseUpsertWithoutPurchaseItemsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutPurchaseItemsInput, PurchaseUpdateWithoutPurchaseItemsInput>, PurchaseUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type PurchaseItemsCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemsCreateWithoutPurchaseInput, PurchaseItemsUncheckedCreateWithoutPurchaseInput> | PurchaseItemsCreateWithoutPurchaseInput[] | PurchaseItemsUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemsCreateOrConnectWithoutPurchaseInput | PurchaseItemsCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemsCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
  }

  export type AccompanimentCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<AccompanimentCreateWithoutPurchasesInput, AccompanimentUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutPurchasesInput
    connect?: AccompanimentWhereUniqueInput
  }

  export type PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemsCreateWithoutPurchaseInput, PurchaseItemsUncheckedCreateWithoutPurchaseInput> | PurchaseItemsCreateWithoutPurchaseInput[] | PurchaseItemsUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemsCreateOrConnectWithoutPurchaseInput | PurchaseItemsCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemsCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
  }

  export type PurchaseItemsUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemsCreateWithoutPurchaseInput, PurchaseItemsUncheckedCreateWithoutPurchaseInput> | PurchaseItemsCreateWithoutPurchaseInput[] | PurchaseItemsUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemsCreateOrConnectWithoutPurchaseInput | PurchaseItemsCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemsCreateManyPurchaseInputEnvelope
    set?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    disconnect?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    delete?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    connect?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    update?: PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemsUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemsUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemsScalarWhereInput | PurchaseItemsScalarWhereInput[]
  }

  export type AccompanimentUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<AccompanimentCreateWithoutPurchasesInput, AccompanimentUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutPurchasesInput
    upsert?: AccompanimentUpsertWithoutPurchasesInput
    connect?: AccompanimentWhereUniqueInput
    update?: XOR<XOR<AccompanimentUpdateToOneWithWhereWithoutPurchasesInput, AccompanimentUpdateWithoutPurchasesInput>, AccompanimentUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseItemsUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemsCreateWithoutPurchaseInput, PurchaseItemsUncheckedCreateWithoutPurchaseInput> | PurchaseItemsCreateWithoutPurchaseInput[] | PurchaseItemsUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemsCreateOrConnectWithoutPurchaseInput | PurchaseItemsCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemsCreateManyPurchaseInputEnvelope
    set?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    disconnect?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    delete?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    connect?: PurchaseItemsWhereUniqueInput | PurchaseItemsWhereUniqueInput[]
    update?: PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemsUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemsUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemsScalarWhereInput | PurchaseItemsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutEmargementsInput = {
    create?: XOR<UsersCreateWithoutEmargementsInput, UsersUncheckedCreateWithoutEmargementsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutEmargementsInput
    connect?: UsersWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutEmargementsInput = {
    create?: XOR<MemberCreateWithoutEmargementsInput, MemberUncheckedCreateWithoutEmargementsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutEmargementsInput
    connect?: MemberWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutEmargementsNestedInput = {
    create?: XOR<UsersCreateWithoutEmargementsInput, UsersUncheckedCreateWithoutEmargementsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutEmargementsInput
    upsert?: UsersUpsertWithoutEmargementsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutEmargementsInput, UsersUpdateWithoutEmargementsInput>, UsersUncheckedUpdateWithoutEmargementsInput>
  }

  export type MemberUpdateOneRequiredWithoutEmargementsNestedInput = {
    create?: XOR<MemberCreateWithoutEmargementsInput, MemberUncheckedCreateWithoutEmargementsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutEmargementsInput
    upsert?: MemberUpsertWithoutEmargementsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutEmargementsInput, MemberUpdateWithoutEmargementsInput>, MemberUncheckedUpdateWithoutEmargementsInput>
  }

  export type VisitsCreateNestedOneWithoutVisiteTerrainInput = {
    create?: XOR<VisitsCreateWithoutVisiteTerrainInput, VisitsUncheckedCreateWithoutVisiteTerrainInput>
    connectOrCreate?: VisitsCreateOrConnectWithoutVisiteTerrainInput
    connect?: VisitsWhereUniqueInput
  }

  export type PersonnesCreateNestedManyWithoutVisiteTerrainInput = {
    create?: XOR<PersonnesCreateWithoutVisiteTerrainInput, PersonnesUncheckedCreateWithoutVisiteTerrainInput> | PersonnesCreateWithoutVisiteTerrainInput[] | PersonnesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutVisiteTerrainInput | PersonnesCreateOrConnectWithoutVisiteTerrainInput[]
    createMany?: PersonnesCreateManyVisiteTerrainInputEnvelope
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
  }

  export type FilesCreateNestedManyWithoutVisiteTerrainInput = {
    create?: XOR<FilesCreateWithoutVisiteTerrainInput, FilesUncheckedCreateWithoutVisiteTerrainInput> | FilesCreateWithoutVisiteTerrainInput[] | FilesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutVisiteTerrainInput | FilesCreateOrConnectWithoutVisiteTerrainInput[]
    createMany?: FilesCreateManyVisiteTerrainInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutVisiteTerrainsInput = {
    create?: XOR<UsersCreateWithoutVisiteTerrainsInput, UsersUncheckedCreateWithoutVisiteTerrainsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutVisiteTerrainsInput
    connect?: UsersWhereUniqueInput
  }

  export type PersonnesUncheckedCreateNestedManyWithoutVisiteTerrainInput = {
    create?: XOR<PersonnesCreateWithoutVisiteTerrainInput, PersonnesUncheckedCreateWithoutVisiteTerrainInput> | PersonnesCreateWithoutVisiteTerrainInput[] | PersonnesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutVisiteTerrainInput | PersonnesCreateOrConnectWithoutVisiteTerrainInput[]
    createMany?: PersonnesCreateManyVisiteTerrainInputEnvelope
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
  }

  export type FilesUncheckedCreateNestedManyWithoutVisiteTerrainInput = {
    create?: XOR<FilesCreateWithoutVisiteTerrainInput, FilesUncheckedCreateWithoutVisiteTerrainInput> | FilesCreateWithoutVisiteTerrainInput[] | FilesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutVisiteTerrainInput | FilesCreateOrConnectWithoutVisiteTerrainInput[]
    createMany?: FilesCreateManyVisiteTerrainInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type VisitsUpdateOneRequiredWithoutVisiteTerrainNestedInput = {
    create?: XOR<VisitsCreateWithoutVisiteTerrainInput, VisitsUncheckedCreateWithoutVisiteTerrainInput>
    connectOrCreate?: VisitsCreateOrConnectWithoutVisiteTerrainInput
    upsert?: VisitsUpsertWithoutVisiteTerrainInput
    connect?: VisitsWhereUniqueInput
    update?: XOR<XOR<VisitsUpdateToOneWithWhereWithoutVisiteTerrainInput, VisitsUpdateWithoutVisiteTerrainInput>, VisitsUncheckedUpdateWithoutVisiteTerrainInput>
  }

  export type PersonnesUpdateManyWithoutVisiteTerrainNestedInput = {
    create?: XOR<PersonnesCreateWithoutVisiteTerrainInput, PersonnesUncheckedCreateWithoutVisiteTerrainInput> | PersonnesCreateWithoutVisiteTerrainInput[] | PersonnesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutVisiteTerrainInput | PersonnesCreateOrConnectWithoutVisiteTerrainInput[]
    upsert?: PersonnesUpsertWithWhereUniqueWithoutVisiteTerrainInput | PersonnesUpsertWithWhereUniqueWithoutVisiteTerrainInput[]
    createMany?: PersonnesCreateManyVisiteTerrainInputEnvelope
    set?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    disconnect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    delete?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    update?: PersonnesUpdateWithWhereUniqueWithoutVisiteTerrainInput | PersonnesUpdateWithWhereUniqueWithoutVisiteTerrainInput[]
    updateMany?: PersonnesUpdateManyWithWhereWithoutVisiteTerrainInput | PersonnesUpdateManyWithWhereWithoutVisiteTerrainInput[]
    deleteMany?: PersonnesScalarWhereInput | PersonnesScalarWhereInput[]
  }

  export type FilesUpdateManyWithoutVisiteTerrainNestedInput = {
    create?: XOR<FilesCreateWithoutVisiteTerrainInput, FilesUncheckedCreateWithoutVisiteTerrainInput> | FilesCreateWithoutVisiteTerrainInput[] | FilesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutVisiteTerrainInput | FilesCreateOrConnectWithoutVisiteTerrainInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutVisiteTerrainInput | FilesUpsertWithWhereUniqueWithoutVisiteTerrainInput[]
    createMany?: FilesCreateManyVisiteTerrainInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutVisiteTerrainInput | FilesUpdateWithWhereUniqueWithoutVisiteTerrainInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutVisiteTerrainInput | FilesUpdateManyWithWhereWithoutVisiteTerrainInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutVisiteTerrainsNestedInput = {
    create?: XOR<UsersCreateWithoutVisiteTerrainsInput, UsersUncheckedCreateWithoutVisiteTerrainsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutVisiteTerrainsInput
    upsert?: UsersUpsertWithoutVisiteTerrainsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutVisiteTerrainsInput, UsersUpdateWithoutVisiteTerrainsInput>, UsersUncheckedUpdateWithoutVisiteTerrainsInput>
  }

  export type PersonnesUncheckedUpdateManyWithoutVisiteTerrainNestedInput = {
    create?: XOR<PersonnesCreateWithoutVisiteTerrainInput, PersonnesUncheckedCreateWithoutVisiteTerrainInput> | PersonnesCreateWithoutVisiteTerrainInput[] | PersonnesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutVisiteTerrainInput | PersonnesCreateOrConnectWithoutVisiteTerrainInput[]
    upsert?: PersonnesUpsertWithWhereUniqueWithoutVisiteTerrainInput | PersonnesUpsertWithWhereUniqueWithoutVisiteTerrainInput[]
    createMany?: PersonnesCreateManyVisiteTerrainInputEnvelope
    set?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    disconnect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    delete?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    update?: PersonnesUpdateWithWhereUniqueWithoutVisiteTerrainInput | PersonnesUpdateWithWhereUniqueWithoutVisiteTerrainInput[]
    updateMany?: PersonnesUpdateManyWithWhereWithoutVisiteTerrainInput | PersonnesUpdateManyWithWhereWithoutVisiteTerrainInput[]
    deleteMany?: PersonnesScalarWhereInput | PersonnesScalarWhereInput[]
  }

  export type FilesUncheckedUpdateManyWithoutVisiteTerrainNestedInput = {
    create?: XOR<FilesCreateWithoutVisiteTerrainInput, FilesUncheckedCreateWithoutVisiteTerrainInput> | FilesCreateWithoutVisiteTerrainInput[] | FilesUncheckedCreateWithoutVisiteTerrainInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutVisiteTerrainInput | FilesCreateOrConnectWithoutVisiteTerrainInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutVisiteTerrainInput | FilesUpsertWithWhereUniqueWithoutVisiteTerrainInput[]
    createMany?: FilesCreateManyVisiteTerrainInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutVisiteTerrainInput | FilesUpdateWithWhereUniqueWithoutVisiteTerrainInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutVisiteTerrainInput | FilesUpdateManyWithWhereWithoutVisiteTerrainInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type PersonnesCreateNestedManyWithoutConflitInput = {
    create?: XOR<PersonnesCreateWithoutConflitInput, PersonnesUncheckedCreateWithoutConflitInput> | PersonnesCreateWithoutConflitInput[] | PersonnesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutConflitInput | PersonnesCreateOrConnectWithoutConflitInput[]
    createMany?: PersonnesCreateManyConflitInputEnvelope
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
  }

  export type FilesCreateNestedManyWithoutConflitInput = {
    create?: XOR<FilesCreateWithoutConflitInput, FilesUncheckedCreateWithoutConflitInput> | FilesCreateWithoutConflitInput[] | FilesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutConflitInput | FilesCreateOrConnectWithoutConflitInput[]
    createMany?: FilesCreateManyConflitInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutConflitInput = {
    create?: XOR<UsersCreateWithoutConflitInput, UsersUncheckedCreateWithoutConflitInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConflitInput
    connect?: UsersWhereUniqueInput
  }

  export type AccompanimentCreateNestedOneWithoutConflitsInput = {
    create?: XOR<AccompanimentCreateWithoutConflitsInput, AccompanimentUncheckedCreateWithoutConflitsInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutConflitsInput
    connect?: AccompanimentWhereUniqueInput
  }

  export type PersonnesUncheckedCreateNestedManyWithoutConflitInput = {
    create?: XOR<PersonnesCreateWithoutConflitInput, PersonnesUncheckedCreateWithoutConflitInput> | PersonnesCreateWithoutConflitInput[] | PersonnesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutConflitInput | PersonnesCreateOrConnectWithoutConflitInput[]
    createMany?: PersonnesCreateManyConflitInputEnvelope
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
  }

  export type FilesUncheckedCreateNestedManyWithoutConflitInput = {
    create?: XOR<FilesCreateWithoutConflitInput, FilesUncheckedCreateWithoutConflitInput> | FilesCreateWithoutConflitInput[] | FilesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutConflitInput | FilesCreateOrConnectWithoutConflitInput[]
    createMany?: FilesCreateManyConflitInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type PersonnesUpdateManyWithoutConflitNestedInput = {
    create?: XOR<PersonnesCreateWithoutConflitInput, PersonnesUncheckedCreateWithoutConflitInput> | PersonnesCreateWithoutConflitInput[] | PersonnesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutConflitInput | PersonnesCreateOrConnectWithoutConflitInput[]
    upsert?: PersonnesUpsertWithWhereUniqueWithoutConflitInput | PersonnesUpsertWithWhereUniqueWithoutConflitInput[]
    createMany?: PersonnesCreateManyConflitInputEnvelope
    set?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    disconnect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    delete?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    update?: PersonnesUpdateWithWhereUniqueWithoutConflitInput | PersonnesUpdateWithWhereUniqueWithoutConflitInput[]
    updateMany?: PersonnesUpdateManyWithWhereWithoutConflitInput | PersonnesUpdateManyWithWhereWithoutConflitInput[]
    deleteMany?: PersonnesScalarWhereInput | PersonnesScalarWhereInput[]
  }

  export type FilesUpdateManyWithoutConflitNestedInput = {
    create?: XOR<FilesCreateWithoutConflitInput, FilesUncheckedCreateWithoutConflitInput> | FilesCreateWithoutConflitInput[] | FilesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutConflitInput | FilesCreateOrConnectWithoutConflitInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutConflitInput | FilesUpsertWithWhereUniqueWithoutConflitInput[]
    createMany?: FilesCreateManyConflitInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutConflitInput | FilesUpdateWithWhereUniqueWithoutConflitInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutConflitInput | FilesUpdateManyWithWhereWithoutConflitInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutConflitNestedInput = {
    create?: XOR<UsersCreateWithoutConflitInput, UsersUncheckedCreateWithoutConflitInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConflitInput
    upsert?: UsersUpsertWithoutConflitInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConflitInput, UsersUpdateWithoutConflitInput>, UsersUncheckedUpdateWithoutConflitInput>
  }

  export type AccompanimentUpdateOneRequiredWithoutConflitsNestedInput = {
    create?: XOR<AccompanimentCreateWithoutConflitsInput, AccompanimentUncheckedCreateWithoutConflitsInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutConflitsInput
    upsert?: AccompanimentUpsertWithoutConflitsInput
    connect?: AccompanimentWhereUniqueInput
    update?: XOR<XOR<AccompanimentUpdateToOneWithWhereWithoutConflitsInput, AccompanimentUpdateWithoutConflitsInput>, AccompanimentUncheckedUpdateWithoutConflitsInput>
  }

  export type PersonnesUncheckedUpdateManyWithoutConflitNestedInput = {
    create?: XOR<PersonnesCreateWithoutConflitInput, PersonnesUncheckedCreateWithoutConflitInput> | PersonnesCreateWithoutConflitInput[] | PersonnesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: PersonnesCreateOrConnectWithoutConflitInput | PersonnesCreateOrConnectWithoutConflitInput[]
    upsert?: PersonnesUpsertWithWhereUniqueWithoutConflitInput | PersonnesUpsertWithWhereUniqueWithoutConflitInput[]
    createMany?: PersonnesCreateManyConflitInputEnvelope
    set?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    disconnect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    delete?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    connect?: PersonnesWhereUniqueInput | PersonnesWhereUniqueInput[]
    update?: PersonnesUpdateWithWhereUniqueWithoutConflitInput | PersonnesUpdateWithWhereUniqueWithoutConflitInput[]
    updateMany?: PersonnesUpdateManyWithWhereWithoutConflitInput | PersonnesUpdateManyWithWhereWithoutConflitInput[]
    deleteMany?: PersonnesScalarWhereInput | PersonnesScalarWhereInput[]
  }

  export type FilesUncheckedUpdateManyWithoutConflitNestedInput = {
    create?: XOR<FilesCreateWithoutConflitInput, FilesUncheckedCreateWithoutConflitInput> | FilesCreateWithoutConflitInput[] | FilesUncheckedCreateWithoutConflitInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutConflitInput | FilesCreateOrConnectWithoutConflitInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutConflitInput | FilesUpsertWithWhereUniqueWithoutConflitInput[]
    createMany?: FilesCreateManyConflitInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutConflitInput | FilesUpdateWithWhereUniqueWithoutConflitInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutConflitInput | FilesUpdateManyWithWhereWithoutConflitInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type RencontreCreateorderInput = {
    set: string[]
  }

  export type RencontreCreatedecisionsInput = {
    set: string[]
  }

  export type RencontreCreateactionsInput = {
    set: string[]
  }

  export type SignatureCreateNestedManyWithoutRencontreInput = {
    create?: XOR<SignatureCreateWithoutRencontreInput, SignatureUncheckedCreateWithoutRencontreInput> | SignatureCreateWithoutRencontreInput[] | SignatureUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutRencontreInput | SignatureCreateOrConnectWithoutRencontreInput[]
    createMany?: SignatureCreateManyRencontreInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type FilesCreateNestedManyWithoutRencontreInput = {
    create?: XOR<FilesCreateWithoutRencontreInput, FilesUncheckedCreateWithoutRencontreInput> | FilesCreateWithoutRencontreInput[] | FilesUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutRencontreInput | FilesCreateOrConnectWithoutRencontreInput[]
    createMany?: FilesCreateManyRencontreInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type AccompanimentCreateNestedOneWithoutRencontreInput = {
    create?: XOR<AccompanimentCreateWithoutRencontreInput, AccompanimentUncheckedCreateWithoutRencontreInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutRencontreInput
    connect?: AccompanimentWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutRencontresInput = {
    create?: XOR<UsersCreateWithoutRencontresInput, UsersUncheckedCreateWithoutRencontresInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRencontresInput
    connect?: UsersWhereUniqueInput
  }

  export type SignatureUncheckedCreateNestedManyWithoutRencontreInput = {
    create?: XOR<SignatureCreateWithoutRencontreInput, SignatureUncheckedCreateWithoutRencontreInput> | SignatureCreateWithoutRencontreInput[] | SignatureUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutRencontreInput | SignatureCreateOrConnectWithoutRencontreInput[]
    createMany?: SignatureCreateManyRencontreInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type FilesUncheckedCreateNestedManyWithoutRencontreInput = {
    create?: XOR<FilesCreateWithoutRencontreInput, FilesUncheckedCreateWithoutRencontreInput> | FilesCreateWithoutRencontreInput[] | FilesUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutRencontreInput | FilesCreateOrConnectWithoutRencontreInput[]
    createMany?: FilesCreateManyRencontreInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type RencontreUpdateorderInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RencontreUpdatedecisionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RencontreUpdateactionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SignatureUpdateManyWithoutRencontreNestedInput = {
    create?: XOR<SignatureCreateWithoutRencontreInput, SignatureUncheckedCreateWithoutRencontreInput> | SignatureCreateWithoutRencontreInput[] | SignatureUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutRencontreInput | SignatureCreateOrConnectWithoutRencontreInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutRencontreInput | SignatureUpsertWithWhereUniqueWithoutRencontreInput[]
    createMany?: SignatureCreateManyRencontreInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutRencontreInput | SignatureUpdateWithWhereUniqueWithoutRencontreInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutRencontreInput | SignatureUpdateManyWithWhereWithoutRencontreInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type FilesUpdateManyWithoutRencontreNestedInput = {
    create?: XOR<FilesCreateWithoutRencontreInput, FilesUncheckedCreateWithoutRencontreInput> | FilesCreateWithoutRencontreInput[] | FilesUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutRencontreInput | FilesCreateOrConnectWithoutRencontreInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutRencontreInput | FilesUpsertWithWhereUniqueWithoutRencontreInput[]
    createMany?: FilesCreateManyRencontreInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutRencontreInput | FilesUpdateWithWhereUniqueWithoutRencontreInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutRencontreInput | FilesUpdateManyWithWhereWithoutRencontreInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type AccompanimentUpdateOneRequiredWithoutRencontreNestedInput = {
    create?: XOR<AccompanimentCreateWithoutRencontreInput, AccompanimentUncheckedCreateWithoutRencontreInput>
    connectOrCreate?: AccompanimentCreateOrConnectWithoutRencontreInput
    upsert?: AccompanimentUpsertWithoutRencontreInput
    connect?: AccompanimentWhereUniqueInput
    update?: XOR<XOR<AccompanimentUpdateToOneWithWhereWithoutRencontreInput, AccompanimentUpdateWithoutRencontreInput>, AccompanimentUncheckedUpdateWithoutRencontreInput>
  }

  export type UsersUpdateOneRequiredWithoutRencontresNestedInput = {
    create?: XOR<UsersCreateWithoutRencontresInput, UsersUncheckedCreateWithoutRencontresInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRencontresInput
    upsert?: UsersUpsertWithoutRencontresInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutRencontresInput, UsersUpdateWithoutRencontresInput>, UsersUncheckedUpdateWithoutRencontresInput>
  }

  export type SignatureUncheckedUpdateManyWithoutRencontreNestedInput = {
    create?: XOR<SignatureCreateWithoutRencontreInput, SignatureUncheckedCreateWithoutRencontreInput> | SignatureCreateWithoutRencontreInput[] | SignatureUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutRencontreInput | SignatureCreateOrConnectWithoutRencontreInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutRencontreInput | SignatureUpsertWithWhereUniqueWithoutRencontreInput[]
    createMany?: SignatureCreateManyRencontreInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutRencontreInput | SignatureUpdateWithWhereUniqueWithoutRencontreInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutRencontreInput | SignatureUpdateManyWithWhereWithoutRencontreInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type FilesUncheckedUpdateManyWithoutRencontreNestedInput = {
    create?: XOR<FilesCreateWithoutRencontreInput, FilesUncheckedCreateWithoutRencontreInput> | FilesCreateWithoutRencontreInput[] | FilesUncheckedCreateWithoutRencontreInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutRencontreInput | FilesCreateOrConnectWithoutRencontreInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutRencontreInput | FilesUpsertWithWhereUniqueWithoutRencontreInput[]
    createMany?: FilesCreateManyRencontreInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutRencontreInput | FilesUpdateWithWhereUniqueWithoutRencontreInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutRencontreInput | FilesUpdateManyWithWhereWithoutRencontreInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type FilesCreateNestedOneWithoutUploadInput = {
    create?: XOR<FilesCreateWithoutUploadInput, FilesUncheckedCreateWithoutUploadInput>
    connectOrCreate?: FilesCreateOrConnectWithoutUploadInput
    connect?: FilesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUploadsInput = {
    create?: XOR<UsersCreateWithoutUploadsInput, UsersUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUploadsInput
    connect?: UsersWhereUniqueInput
  }

  export type FilesUpdateOneRequiredWithoutUploadNestedInput = {
    create?: XOR<FilesCreateWithoutUploadInput, FilesUncheckedCreateWithoutUploadInput>
    connectOrCreate?: FilesCreateOrConnectWithoutUploadInput
    upsert?: FilesUpsertWithoutUploadInput
    connect?: FilesWhereUniqueInput
    update?: XOR<XOR<FilesUpdateToOneWithWhereWithoutUploadInput, FilesUpdateWithoutUploadInput>, FilesUncheckedUpdateWithoutUploadInput>
  }

  export type UsersUpdateOneRequiredWithoutUploadsNestedInput = {
    create?: XOR<UsersCreateWithoutUploadsInput, UsersUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUploadsInput
    upsert?: UsersUpsertWithoutUploadsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUploadsInput, UsersUpdateWithoutUploadsInput>, UsersUncheckedUpdateWithoutUploadsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeFilter<$PrismaModel> | $Enums.Type
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeWithAggregatesFilter<$PrismaModel> | $Enums.Type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeFilter<$PrismaModel>
    _max?: NestedEnumTypeFilter<$PrismaModel>
  }

  export type ConflitCreateWithoutPartieImpliquesInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    files?: FilesCreateNestedManyWithoutConflitInput
    users: UsersCreateNestedOneWithoutConflitInput
    accompaniment: AccompanimentCreateNestedOneWithoutConflitsInput
  }

  export type ConflitUncheckedCreateWithoutPartieImpliquesInput = {
    id?: string
    nature: string
    resolution: string
    usersId: string
    status?: boolean
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
    files?: FilesUncheckedCreateNestedManyWithoutConflitInput
  }

  export type ConflitCreateOrConnectWithoutPartieImpliquesInput = {
    where: ConflitWhereUniqueInput
    create: XOR<ConflitCreateWithoutPartieImpliquesInput, ConflitUncheckedCreateWithoutPartieImpliquesInput>
  }

  export type VisiteTerrainCreateWithoutPersonnesInput = {
    id?: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
    visit: VisitsCreateNestedOneWithoutVisiteTerrainInput
    files?: FilesCreateNestedManyWithoutVisiteTerrainInput
    users: UsersCreateNestedOneWithoutVisiteTerrainsInput
  }

  export type VisiteTerrainUncheckedCreateWithoutPersonnesInput = {
    id?: string
    visitId: string
    observations: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
    files?: FilesUncheckedCreateNestedManyWithoutVisiteTerrainInput
  }

  export type VisiteTerrainCreateOrConnectWithoutPersonnesInput = {
    where: VisiteTerrainWhereUniqueInput
    create: XOR<VisiteTerrainCreateWithoutPersonnesInput, VisiteTerrainUncheckedCreateWithoutPersonnesInput>
  }

  export type ConflitUpsertWithoutPartieImpliquesInput = {
    update: XOR<ConflitUpdateWithoutPartieImpliquesInput, ConflitUncheckedUpdateWithoutPartieImpliquesInput>
    create: XOR<ConflitCreateWithoutPartieImpliquesInput, ConflitUncheckedCreateWithoutPartieImpliquesInput>
    where?: ConflitWhereInput
  }

  export type ConflitUpdateToOneWithWhereWithoutPartieImpliquesInput = {
    where?: ConflitWhereInput
    data: XOR<ConflitUpdateWithoutPartieImpliquesInput, ConflitUncheckedUpdateWithoutPartieImpliquesInput>
  }

  export type ConflitUpdateWithoutPartieImpliquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FilesUpdateManyWithoutConflitNestedInput
    users?: UsersUpdateOneRequiredWithoutConflitNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutConflitsNestedInput
  }

  export type ConflitUncheckedUpdateWithoutPartieImpliquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FilesUncheckedUpdateManyWithoutConflitNestedInput
  }

  export type VisiteTerrainUpsertWithoutPersonnesInput = {
    update: XOR<VisiteTerrainUpdateWithoutPersonnesInput, VisiteTerrainUncheckedUpdateWithoutPersonnesInput>
    create: XOR<VisiteTerrainCreateWithoutPersonnesInput, VisiteTerrainUncheckedCreateWithoutPersonnesInput>
    where?: VisiteTerrainWhereInput
  }

  export type VisiteTerrainUpdateToOneWithWhereWithoutPersonnesInput = {
    where?: VisiteTerrainWhereInput
    data: XOR<VisiteTerrainUpdateWithoutPersonnesInput, VisiteTerrainUncheckedUpdateWithoutPersonnesInput>
  }

  export type VisiteTerrainUpdateWithoutPersonnesInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitsUpdateOneRequiredWithoutVisiteTerrainNestedInput
    files?: FilesUpdateManyWithoutVisiteTerrainNestedInput
    users?: UsersUpdateOneRequiredWithoutVisiteTerrainsNestedInput
  }

  export type VisiteTerrainUncheckedUpdateWithoutPersonnesInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FilesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
  }

  export type MemberCreateWithoutSignaturesInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    emargements?: EmargementCreateNestedManyWithoutMemberInput
    leave?: LeaveCreateNestedOneWithoutMemberInput
    accompaniment?: AccompanimentCreateNestedOneWithoutMembersInput
    classe: ClasseCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutSignaturesInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
    emargements?: EmargementUncheckedCreateNestedManyWithoutMemberInput
    leave?: LeaveUncheckedCreateNestedOneWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutSignaturesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSignaturesInput, MemberUncheckedCreateWithoutSignaturesInput>
  }

  export type RencontreCreateWithoutSignaturesInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    files?: FilesCreateNestedManyWithoutRencontreInput
    accompaniment: AccompanimentCreateNestedOneWithoutRencontreInput
    users: UsersCreateNestedOneWithoutRencontresInput
  }

  export type RencontreUncheckedCreateWithoutSignaturesInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    accompanimentId: string
    usersId: string
    files?: FilesUncheckedCreateNestedManyWithoutRencontreInput
  }

  export type RencontreCreateOrConnectWithoutSignaturesInput = {
    where: RencontreWhereUniqueInput
    create: XOR<RencontreCreateWithoutSignaturesInput, RencontreUncheckedCreateWithoutSignaturesInput>
  }

  export type MemberUpsertWithoutSignaturesInput = {
    update: XOR<MemberUpdateWithoutSignaturesInput, MemberUncheckedUpdateWithoutSignaturesInput>
    create: XOR<MemberCreateWithoutSignaturesInput, MemberUncheckedCreateWithoutSignaturesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSignaturesInput, MemberUncheckedUpdateWithoutSignaturesInput>
  }

  export type MemberUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    emargements?: EmargementUpdateManyWithoutMemberNestedInput
    leave?: LeaveUpdateOneWithoutMemberNestedInput
    accompaniment?: AccompanimentUpdateOneWithoutMembersNestedInput
    classe?: ClasseUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emargements?: EmargementUncheckedUpdateManyWithoutMemberNestedInput
    leave?: LeaveUncheckedUpdateOneWithoutMemberNestedInput
  }

  export type RencontreUpsertWithoutSignaturesInput = {
    update: XOR<RencontreUpdateWithoutSignaturesInput, RencontreUncheckedUpdateWithoutSignaturesInput>
    create: XOR<RencontreCreateWithoutSignaturesInput, RencontreUncheckedCreateWithoutSignaturesInput>
    where?: RencontreWhereInput
  }

  export type RencontreUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: RencontreWhereInput
    data: XOR<RencontreUpdateWithoutSignaturesInput, RencontreUncheckedUpdateWithoutSignaturesInput>
  }

  export type RencontreUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    files?: FilesUpdateManyWithoutRencontreNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutRencontreNestedInput
    users?: UsersUpdateOneRequiredWithoutRencontresNestedInput
  }

  export type RencontreUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    accompanimentId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    files?: FilesUncheckedUpdateManyWithoutRencontreNestedInput
  }

  export type VisiteTerrainCreateWithoutFilesInput = {
    id?: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
    visit: VisitsCreateNestedOneWithoutVisiteTerrainInput
    personnes?: PersonnesCreateNestedManyWithoutVisiteTerrainInput
    users: UsersCreateNestedOneWithoutVisiteTerrainsInput
  }

  export type VisiteTerrainUncheckedCreateWithoutFilesInput = {
    id?: string
    visitId: string
    observations: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
    personnes?: PersonnesUncheckedCreateNestedManyWithoutVisiteTerrainInput
  }

  export type VisiteTerrainCreateOrConnectWithoutFilesInput = {
    where: VisiteTerrainWhereUniqueInput
    create: XOR<VisiteTerrainCreateWithoutFilesInput, VisiteTerrainUncheckedCreateWithoutFilesInput>
  }

  export type ConflitCreateWithoutFilesInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesCreateNestedManyWithoutConflitInput
    users: UsersCreateNestedOneWithoutConflitInput
    accompaniment: AccompanimentCreateNestedOneWithoutConflitsInput
  }

  export type ConflitUncheckedCreateWithoutFilesInput = {
    id?: string
    nature: string
    resolution: string
    usersId: string
    status?: boolean
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesUncheckedCreateNestedManyWithoutConflitInput
  }

  export type ConflitCreateOrConnectWithoutFilesInput = {
    where: ConflitWhereUniqueInput
    create: XOR<ConflitCreateWithoutFilesInput, ConflitUncheckedCreateWithoutFilesInput>
  }

  export type RencontreCreateWithoutFilesInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    signatures?: SignatureCreateNestedManyWithoutRencontreInput
    accompaniment: AccompanimentCreateNestedOneWithoutRencontreInput
    users: UsersCreateNestedOneWithoutRencontresInput
  }

  export type RencontreUncheckedCreateWithoutFilesInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    accompanimentId: string
    usersId: string
    signatures?: SignatureUncheckedCreateNestedManyWithoutRencontreInput
  }

  export type RencontreCreateOrConnectWithoutFilesInput = {
    where: RencontreWhereUniqueInput
    create: XOR<RencontreCreateWithoutFilesInput, RencontreUncheckedCreateWithoutFilesInput>
  }

  export type UploadCreateWithoutFileInput = {
    id?: string
    titre: string
    date: Date | string
    user: UsersCreateNestedOneWithoutUploadsInput
  }

  export type UploadUncheckedCreateWithoutFileInput = {
    id?: string
    titre: string
    date: Date | string
    userId: string
  }

  export type UploadCreateOrConnectWithoutFileInput = {
    where: UploadWhereUniqueInput
    create: XOR<UploadCreateWithoutFileInput, UploadUncheckedCreateWithoutFileInput>
  }

  export type UploadCreateManyFileInputEnvelope = {
    data: UploadCreateManyFileInput | UploadCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutCvInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutCvInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutCvInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCvInput, UsersUncheckedCreateWithoutCvInput>
  }

  export type UsersCreateManyCvInputEnvelope = {
    data: UsersCreateManyCvInput | UsersCreateManyCvInput[]
    skipDuplicates?: boolean
  }

  export type AccompanimentCreateWithoutFileInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutFileInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutFileInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutFileInput, AccompanimentUncheckedCreateWithoutFileInput>
  }

  export type AccompanimentCreateManyFileInputEnvelope = {
    data: AccompanimentCreateManyFileInput | AccompanimentCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type AccompanimentCreateWithoutMediaInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutMediaInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutMediaInput, AccompanimentUncheckedCreateWithoutMediaInput>
  }

  export type VisiteTerrainUpsertWithoutFilesInput = {
    update: XOR<VisiteTerrainUpdateWithoutFilesInput, VisiteTerrainUncheckedUpdateWithoutFilesInput>
    create: XOR<VisiteTerrainCreateWithoutFilesInput, VisiteTerrainUncheckedCreateWithoutFilesInput>
    where?: VisiteTerrainWhereInput
  }

  export type VisiteTerrainUpdateToOneWithWhereWithoutFilesInput = {
    where?: VisiteTerrainWhereInput
    data: XOR<VisiteTerrainUpdateWithoutFilesInput, VisiteTerrainUncheckedUpdateWithoutFilesInput>
  }

  export type VisiteTerrainUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitsUpdateOneRequiredWithoutVisiteTerrainNestedInput
    personnes?: PersonnesUpdateManyWithoutVisiteTerrainNestedInput
    users?: UsersUpdateOneRequiredWithoutVisiteTerrainsNestedInput
  }

  export type VisiteTerrainUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnes?: PersonnesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
  }

  export type ConflitUpsertWithoutFilesInput = {
    update: XOR<ConflitUpdateWithoutFilesInput, ConflitUncheckedUpdateWithoutFilesInput>
    create: XOR<ConflitCreateWithoutFilesInput, ConflitUncheckedCreateWithoutFilesInput>
    where?: ConflitWhereInput
  }

  export type ConflitUpdateToOneWithWhereWithoutFilesInput = {
    where?: ConflitWhereInput
    data: XOR<ConflitUpdateWithoutFilesInput, ConflitUncheckedUpdateWithoutFilesInput>
  }

  export type ConflitUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUpdateManyWithoutConflitNestedInput
    users?: UsersUpdateOneRequiredWithoutConflitNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutConflitsNestedInput
  }

  export type ConflitUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUncheckedUpdateManyWithoutConflitNestedInput
  }

  export type RencontreUpsertWithoutFilesInput = {
    update: XOR<RencontreUpdateWithoutFilesInput, RencontreUncheckedUpdateWithoutFilesInput>
    create: XOR<RencontreCreateWithoutFilesInput, RencontreUncheckedCreateWithoutFilesInput>
    where?: RencontreWhereInput
  }

  export type RencontreUpdateToOneWithWhereWithoutFilesInput = {
    where?: RencontreWhereInput
    data: XOR<RencontreUpdateWithoutFilesInput, RencontreUncheckedUpdateWithoutFilesInput>
  }

  export type RencontreUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    signatures?: SignatureUpdateManyWithoutRencontreNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutRencontreNestedInput
    users?: UsersUpdateOneRequiredWithoutRencontresNestedInput
  }

  export type RencontreUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    accompanimentId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    signatures?: SignatureUncheckedUpdateManyWithoutRencontreNestedInput
  }

  export type UploadUpsertWithWhereUniqueWithoutFileInput = {
    where: UploadWhereUniqueInput
    update: XOR<UploadUpdateWithoutFileInput, UploadUncheckedUpdateWithoutFileInput>
    create: XOR<UploadCreateWithoutFileInput, UploadUncheckedCreateWithoutFileInput>
  }

  export type UploadUpdateWithWhereUniqueWithoutFileInput = {
    where: UploadWhereUniqueInput
    data: XOR<UploadUpdateWithoutFileInput, UploadUncheckedUpdateWithoutFileInput>
  }

  export type UploadUpdateManyWithWhereWithoutFileInput = {
    where: UploadScalarWhereInput
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyWithoutFileInput>
  }

  export type UploadScalarWhereInput = {
    AND?: UploadScalarWhereInput | UploadScalarWhereInput[]
    OR?: UploadScalarWhereInput[]
    NOT?: UploadScalarWhereInput | UploadScalarWhereInput[]
    id?: UuidFilter<"Upload"> | string
    titre?: StringFilter<"Upload"> | string
    date?: DateTimeFilter<"Upload"> | Date | string
    fileId?: UuidFilter<"Upload"> | string
    userId?: UuidFilter<"Upload"> | string
  }

  export type UsersUpsertWithWhereUniqueWithoutCvInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutCvInput, UsersUncheckedUpdateWithoutCvInput>
    create: XOR<UsersCreateWithoutCvInput, UsersUncheckedCreateWithoutCvInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutCvInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutCvInput, UsersUncheckedUpdateWithoutCvInput>
  }

  export type UsersUpdateManyWithWhereWithoutCvInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutCvInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: UuidFilter<"Users"> | string
    authId?: StringFilter<"Users"> | string
    profile?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone?: StringFilter<"Users"> | string
    address?: StringFilter<"Users"> | string
    gender?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    filesId?: UuidNullableFilter<"Users"> | string | null
    status?: EnumStatusFilter<"Users"> | $Enums.Status
    type?: EnumTypeFilter<"Users"> | $Enums.Type
    routes?: StringNullableListFilter<"Users">
    access?: StringNullableListFilter<"Users">
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
  }

  export type AccompanimentUpsertWithWhereUniqueWithoutFileInput = {
    where: AccompanimentWhereUniqueInput
    update: XOR<AccompanimentUpdateWithoutFileInput, AccompanimentUncheckedUpdateWithoutFileInput>
    create: XOR<AccompanimentCreateWithoutFileInput, AccompanimentUncheckedCreateWithoutFileInput>
  }

  export type AccompanimentUpdateWithWhereUniqueWithoutFileInput = {
    where: AccompanimentWhereUniqueInput
    data: XOR<AccompanimentUpdateWithoutFileInput, AccompanimentUncheckedUpdateWithoutFileInput>
  }

  export type AccompanimentUpdateManyWithWhereWithoutFileInput = {
    where: AccompanimentScalarWhereInput
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyWithoutFileInput>
  }

  export type AccompanimentScalarWhereInput = {
    AND?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
    OR?: AccompanimentScalarWhereInput[]
    NOT?: AccompanimentScalarWhereInput | AccompanimentScalarWhereInput[]
    id?: UuidFilter<"Accompaniment"> | string
    name?: StringFilter<"Accompaniment"> | string
    adresse?: StringFilter<"Accompaniment"> | string
    phones?: IntNullableListFilter<"Accompaniment">
    budget?: IntFilter<"Accompaniment"> | number
    status?: BoolFilter<"Accompaniment"> | boolean
    usersid?: UuidFilter<"Accompaniment"> | string
    fileId?: UuidFilter<"Accompaniment"> | string
    projectId?: UuidFilter<"Accompaniment"> | string
    planningId?: UuidNullableFilter<"Accompaniment"> | string | null
    createdAt?: DateTimeFilter<"Accompaniment"> | Date | string
    updatedAt?: DateTimeFilter<"Accompaniment"> | Date | string
  }

  export type AccompanimentUpsertWithWhereUniqueWithoutMediaInput = {
    where: AccompanimentWhereUniqueInput
    update: XOR<AccompanimentUpdateWithoutMediaInput, AccompanimentUncheckedUpdateWithoutMediaInput>
    create: XOR<AccompanimentCreateWithoutMediaInput, AccompanimentUncheckedCreateWithoutMediaInput>
  }

  export type AccompanimentUpdateWithWhereUniqueWithoutMediaInput = {
    where: AccompanimentWhereUniqueInput
    data: XOR<AccompanimentUpdateWithoutMediaInput, AccompanimentUncheckedUpdateWithoutMediaInput>
  }

  export type AccompanimentUpdateManyWithWhereWithoutMediaInput = {
    where: AccompanimentScalarWhereInput
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyWithoutMediaInput>
  }

  export type FilesCreateWithoutUsersInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    rencontreId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesCreateOrConnectWithoutUsersInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutUsersInput, FilesUncheckedCreateWithoutUsersInput>
  }

  export type AccompanimentCreateWithoutUsersInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutUsersInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutUsersInput, AccompanimentUncheckedCreateWithoutUsersInput>
  }

  export type AccompanimentCreateManyUsersInputEnvelope = {
    data: AccompanimentCreateManyUsersInput | AccompanimentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PlanningCreateWithoutUsersInput = {
    id?: string
    accompaniments?: AccompanimentCreateNestedManyWithoutPlanningInput
    visit?: VisitsCreateNestedManyWithoutPlanningInput
  }

  export type PlanningUncheckedCreateWithoutUsersInput = {
    id?: string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutPlanningInput
    visit?: VisitsUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutUsersInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutUsersInput, PlanningUncheckedCreateWithoutUsersInput>
  }

  export type PlanningCreateManyUsersInputEnvelope = {
    data: PlanningCreateManyUsersInput | PlanningCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type EmargementCreateWithoutUsersInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    member: MemberCreateNestedOneWithoutEmargementsInput
  }

  export type EmargementUncheckedCreateWithoutUsersInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    memberId: string
  }

  export type EmargementCreateOrConnectWithoutUsersInput = {
    where: EmargementWhereUniqueInput
    create: XOR<EmargementCreateWithoutUsersInput, EmargementUncheckedCreateWithoutUsersInput>
  }

  export type EmargementCreateManyUsersInputEnvelope = {
    data: EmargementCreateManyUsersInput | EmargementCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type VisiteTerrainCreateWithoutUsersInput = {
    id?: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
    visit: VisitsCreateNestedOneWithoutVisiteTerrainInput
    personnes?: PersonnesCreateNestedManyWithoutVisiteTerrainInput
    files?: FilesCreateNestedManyWithoutVisiteTerrainInput
  }

  export type VisiteTerrainUncheckedCreateWithoutUsersInput = {
    id?: string
    visitId: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
    personnes?: PersonnesUncheckedCreateNestedManyWithoutVisiteTerrainInput
    files?: FilesUncheckedCreateNestedManyWithoutVisiteTerrainInput
  }

  export type VisiteTerrainCreateOrConnectWithoutUsersInput = {
    where: VisiteTerrainWhereUniqueInput
    create: XOR<VisiteTerrainCreateWithoutUsersInput, VisiteTerrainUncheckedCreateWithoutUsersInput>
  }

  export type VisiteTerrainCreateManyUsersInputEnvelope = {
    data: VisiteTerrainCreateManyUsersInput | VisiteTerrainCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type RencontreCreateWithoutUsersInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    signatures?: SignatureCreateNestedManyWithoutRencontreInput
    files?: FilesCreateNestedManyWithoutRencontreInput
    accompaniment: AccompanimentCreateNestedOneWithoutRencontreInput
  }

  export type RencontreUncheckedCreateWithoutUsersInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    accompanimentId: string
    signatures?: SignatureUncheckedCreateNestedManyWithoutRencontreInput
    files?: FilesUncheckedCreateNestedManyWithoutRencontreInput
  }

  export type RencontreCreateOrConnectWithoutUsersInput = {
    where: RencontreWhereUniqueInput
    create: XOR<RencontreCreateWithoutUsersInput, RencontreUncheckedCreateWithoutUsersInput>
  }

  export type RencontreCreateManyUsersInputEnvelope = {
    data: RencontreCreateManyUsersInput | RencontreCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ConflitCreateWithoutUsersInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesCreateNestedManyWithoutConflitInput
    files?: FilesCreateNestedManyWithoutConflitInput
    accompaniment: AccompanimentCreateNestedOneWithoutConflitsInput
  }

  export type ConflitUncheckedCreateWithoutUsersInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesUncheckedCreateNestedManyWithoutConflitInput
    files?: FilesUncheckedCreateNestedManyWithoutConflitInput
  }

  export type ConflitCreateOrConnectWithoutUsersInput = {
    where: ConflitWhereUniqueInput
    create: XOR<ConflitCreateWithoutUsersInput, ConflitUncheckedCreateWithoutUsersInput>
  }

  export type ConflitCreateManyUsersInputEnvelope = {
    data: ConflitCreateManyUsersInput | ConflitCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ChatParticipantCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    chat: ChatCreateNestedOneWithoutParticipantsInput
  }

  export type ChatParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    chatId: string
    joinedAt?: Date | string
  }

  export type ChatParticipantCreateOrConnectWithoutUserInput = {
    where: ChatParticipantWhereUniqueInput
    create: XOR<ChatParticipantCreateWithoutUserInput, ChatParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChatParticipantCreateManyUserInputEnvelope = {
    data: ChatParticipantCreateManyUserInput | ChatParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    sentAt?: Date | string
    messageView?: MessageViewCreateNestedManyWithoutMessageInput
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    sentAt?: Date | string
    chatId: string
    messageView?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type UploadCreateWithoutUserInput = {
    id?: string
    titre: string
    date: Date | string
    file: FilesCreateNestedOneWithoutUploadInput
  }

  export type UploadUncheckedCreateWithoutUserInput = {
    id?: string
    titre: string
    date: Date | string
    fileId: string
  }

  export type UploadCreateOrConnectWithoutUserInput = {
    where: UploadWhereUniqueInput
    create: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput>
  }

  export type UploadCreateManyUserInputEnvelope = {
    data: UploadCreateManyUserInput | UploadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageViewCreateWithoutUserInput = {
    id?: string
    view?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    message: MessageCreateNestedOneWithoutMessageViewInput
  }

  export type MessageViewUncheckedCreateWithoutUserInput = {
    id?: string
    view?: boolean
    messageId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MessageViewCreateOrConnectWithoutUserInput = {
    where: MessageViewWhereUniqueInput
    create: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput>
  }

  export type MessageViewCreateManyUserInputEnvelope = {
    data: MessageViewCreateManyUserInput | MessageViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClasseCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutClasseInput
    project: ProjectCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutUserInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutUserInput, ClasseUncheckedCreateWithoutUserInput>
  }

  export type ClasseCreateManyUserInputEnvelope = {
    data: ClasseCreateManyUserInput | ClasseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FilesUpsertWithoutUsersInput = {
    update: XOR<FilesUpdateWithoutUsersInput, FilesUncheckedUpdateWithoutUsersInput>
    create: XOR<FilesCreateWithoutUsersInput, FilesUncheckedCreateWithoutUsersInput>
    where?: FilesWhereInput
  }

  export type FilesUpdateToOneWithWhereWithoutUsersInput = {
    where?: FilesWhereInput
    data: XOR<FilesUpdateWithoutUsersInput, FilesUncheckedUpdateWithoutUsersInput>
  }

  export type FilesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type AccompanimentUpsertWithWhereUniqueWithoutUsersInput = {
    where: AccompanimentWhereUniqueInput
    update: XOR<AccompanimentUpdateWithoutUsersInput, AccompanimentUncheckedUpdateWithoutUsersInput>
    create: XOR<AccompanimentCreateWithoutUsersInput, AccompanimentUncheckedCreateWithoutUsersInput>
  }

  export type AccompanimentUpdateWithWhereUniqueWithoutUsersInput = {
    where: AccompanimentWhereUniqueInput
    data: XOR<AccompanimentUpdateWithoutUsersInput, AccompanimentUncheckedUpdateWithoutUsersInput>
  }

  export type AccompanimentUpdateManyWithWhereWithoutUsersInput = {
    where: AccompanimentScalarWhereInput
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyWithoutUsersInput>
  }

  export type PlanningUpsertWithWhereUniqueWithoutUsersInput = {
    where: PlanningWhereUniqueInput
    update: XOR<PlanningUpdateWithoutUsersInput, PlanningUncheckedUpdateWithoutUsersInput>
    create: XOR<PlanningCreateWithoutUsersInput, PlanningUncheckedCreateWithoutUsersInput>
  }

  export type PlanningUpdateWithWhereUniqueWithoutUsersInput = {
    where: PlanningWhereUniqueInput
    data: XOR<PlanningUpdateWithoutUsersInput, PlanningUncheckedUpdateWithoutUsersInput>
  }

  export type PlanningUpdateManyWithWhereWithoutUsersInput = {
    where: PlanningScalarWhereInput
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyWithoutUsersInput>
  }

  export type PlanningScalarWhereInput = {
    AND?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
    OR?: PlanningScalarWhereInput[]
    NOT?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
    id?: UuidFilter<"Planning"> | string
    usersId?: UuidFilter<"Planning"> | string
  }

  export type EmargementUpsertWithWhereUniqueWithoutUsersInput = {
    where: EmargementWhereUniqueInput
    update: XOR<EmargementUpdateWithoutUsersInput, EmargementUncheckedUpdateWithoutUsersInput>
    create: XOR<EmargementCreateWithoutUsersInput, EmargementUncheckedCreateWithoutUsersInput>
  }

  export type EmargementUpdateWithWhereUniqueWithoutUsersInput = {
    where: EmargementWhereUniqueInput
    data: XOR<EmargementUpdateWithoutUsersInput, EmargementUncheckedUpdateWithoutUsersInput>
  }

  export type EmargementUpdateManyWithWhereWithoutUsersInput = {
    where: EmargementScalarWhereInput
    data: XOR<EmargementUpdateManyMutationInput, EmargementUncheckedUpdateManyWithoutUsersInput>
  }

  export type EmargementScalarWhereInput = {
    AND?: EmargementScalarWhereInput | EmargementScalarWhereInput[]
    OR?: EmargementScalarWhereInput[]
    NOT?: EmargementScalarWhereInput | EmargementScalarWhereInput[]
    id?: UuidFilter<"Emargement"> | string
    date?: DateTimeFilter<"Emargement"> | Date | string
    signature?: BoolFilter<"Emargement"> | boolean
    cni?: StringFilter<"Emargement"> | string
    PhotoCni?: StringFilter<"Emargement"> | string
    montant?: IntFilter<"Emargement"> | number
    observations?: StringFilter<"Emargement"> | string
    usersId?: UuidFilter<"Emargement"> | string
    memberId?: UuidFilter<"Emargement"> | string
  }

  export type VisiteTerrainUpsertWithWhereUniqueWithoutUsersInput = {
    where: VisiteTerrainWhereUniqueInput
    update: XOR<VisiteTerrainUpdateWithoutUsersInput, VisiteTerrainUncheckedUpdateWithoutUsersInput>
    create: XOR<VisiteTerrainCreateWithoutUsersInput, VisiteTerrainUncheckedCreateWithoutUsersInput>
  }

  export type VisiteTerrainUpdateWithWhereUniqueWithoutUsersInput = {
    where: VisiteTerrainWhereUniqueInput
    data: XOR<VisiteTerrainUpdateWithoutUsersInput, VisiteTerrainUncheckedUpdateWithoutUsersInput>
  }

  export type VisiteTerrainUpdateManyWithWhereWithoutUsersInput = {
    where: VisiteTerrainScalarWhereInput
    data: XOR<VisiteTerrainUpdateManyMutationInput, VisiteTerrainUncheckedUpdateManyWithoutUsersInput>
  }

  export type VisiteTerrainScalarWhereInput = {
    AND?: VisiteTerrainScalarWhereInput | VisiteTerrainScalarWhereInput[]
    OR?: VisiteTerrainScalarWhereInput[]
    NOT?: VisiteTerrainScalarWhereInput | VisiteTerrainScalarWhereInput[]
    id?: UuidFilter<"VisiteTerrain"> | string
    visitId?: UuidFilter<"VisiteTerrain"> | string
    observations?: StringFilter<"VisiteTerrain"> | string
    usersId?: UuidFilter<"VisiteTerrain"> | string
    createdAt?: DateTimeFilter<"VisiteTerrain"> | Date | string
    updatedAt?: DateTimeFilter<"VisiteTerrain"> | Date | string
  }

  export type RencontreUpsertWithWhereUniqueWithoutUsersInput = {
    where: RencontreWhereUniqueInput
    update: XOR<RencontreUpdateWithoutUsersInput, RencontreUncheckedUpdateWithoutUsersInput>
    create: XOR<RencontreCreateWithoutUsersInput, RencontreUncheckedCreateWithoutUsersInput>
  }

  export type RencontreUpdateWithWhereUniqueWithoutUsersInput = {
    where: RencontreWhereUniqueInput
    data: XOR<RencontreUpdateWithoutUsersInput, RencontreUncheckedUpdateWithoutUsersInput>
  }

  export type RencontreUpdateManyWithWhereWithoutUsersInput = {
    where: RencontreScalarWhereInput
    data: XOR<RencontreUpdateManyMutationInput, RencontreUncheckedUpdateManyWithoutUsersInput>
  }

  export type RencontreScalarWhereInput = {
    AND?: RencontreScalarWhereInput | RencontreScalarWhereInput[]
    OR?: RencontreScalarWhereInput[]
    NOT?: RencontreScalarWhereInput | RencontreScalarWhereInput[]
    id?: UuidFilter<"Rencontre"> | string
    date?: DateTimeFilter<"Rencontre"> | Date | string
    lieu?: StringFilter<"Rencontre"> | string
    order?: StringNullableListFilter<"Rencontre">
    decisions?: StringNullableListFilter<"Rencontre">
    actions?: StringNullableListFilter<"Rencontre">
    accompanimentId?: UuidFilter<"Rencontre"> | string
    usersId?: UuidFilter<"Rencontre"> | string
  }

  export type ConflitUpsertWithWhereUniqueWithoutUsersInput = {
    where: ConflitWhereUniqueInput
    update: XOR<ConflitUpdateWithoutUsersInput, ConflitUncheckedUpdateWithoutUsersInput>
    create: XOR<ConflitCreateWithoutUsersInput, ConflitUncheckedCreateWithoutUsersInput>
  }

  export type ConflitUpdateWithWhereUniqueWithoutUsersInput = {
    where: ConflitWhereUniqueInput
    data: XOR<ConflitUpdateWithoutUsersInput, ConflitUncheckedUpdateWithoutUsersInput>
  }

  export type ConflitUpdateManyWithWhereWithoutUsersInput = {
    where: ConflitScalarWhereInput
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyWithoutUsersInput>
  }

  export type ConflitScalarWhereInput = {
    AND?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
    OR?: ConflitScalarWhereInput[]
    NOT?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
    id?: UuidFilter<"Conflit"> | string
    nature?: StringFilter<"Conflit"> | string
    resolution?: StringFilter<"Conflit"> | string
    usersId?: UuidFilter<"Conflit"> | string
    status?: BoolFilter<"Conflit"> | boolean
    accompanimentId?: UuidFilter<"Conflit"> | string
    createdAt?: DateTimeFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeFilter<"Conflit"> | Date | string
  }

  export type ChatParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatParticipantWhereUniqueInput
    update: XOR<ChatParticipantUpdateWithoutUserInput, ChatParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ChatParticipantCreateWithoutUserInput, ChatParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChatParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatParticipantWhereUniqueInput
    data: XOR<ChatParticipantUpdateWithoutUserInput, ChatParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ChatParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ChatParticipantScalarWhereInput
    data: XOR<ChatParticipantUpdateManyMutationInput, ChatParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatParticipantScalarWhereInput = {
    AND?: ChatParticipantScalarWhereInput | ChatParticipantScalarWhereInput[]
    OR?: ChatParticipantScalarWhereInput[]
    NOT?: ChatParticipantScalarWhereInput | ChatParticipantScalarWhereInput[]
    id?: UuidFilter<"ChatParticipant"> | string
    userId?: UuidFilter<"ChatParticipant"> | string
    chatId?: UuidFilter<"ChatParticipant"> | string
    joinedAt?: DateTimeFilter<"ChatParticipant"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    sentAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: UuidFilter<"Message"> | string
    chatId?: UuidFilter<"Message"> | string
  }

  export type UploadUpsertWithWhereUniqueWithoutUserInput = {
    where: UploadWhereUniqueInput
    update: XOR<UploadUpdateWithoutUserInput, UploadUncheckedUpdateWithoutUserInput>
    create: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput>
  }

  export type UploadUpdateWithWhereUniqueWithoutUserInput = {
    where: UploadWhereUniqueInput
    data: XOR<UploadUpdateWithoutUserInput, UploadUncheckedUpdateWithoutUserInput>
  }

  export type UploadUpdateManyWithWhereWithoutUserInput = {
    where: UploadScalarWhereInput
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageViewUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageViewWhereUniqueInput
    update: XOR<MessageViewUpdateWithoutUserInput, MessageViewUncheckedUpdateWithoutUserInput>
    create: XOR<MessageViewCreateWithoutUserInput, MessageViewUncheckedCreateWithoutUserInput>
  }

  export type MessageViewUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageViewWhereUniqueInput
    data: XOR<MessageViewUpdateWithoutUserInput, MessageViewUncheckedUpdateWithoutUserInput>
  }

  export type MessageViewUpdateManyWithWhereWithoutUserInput = {
    where: MessageViewScalarWhereInput
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageViewScalarWhereInput = {
    AND?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
    OR?: MessageViewScalarWhereInput[]
    NOT?: MessageViewScalarWhereInput | MessageViewScalarWhereInput[]
    id?: UuidFilter<"MessageView"> | string
    view?: BoolFilter<"MessageView"> | boolean
    messageId?: UuidFilter<"MessageView"> | string
    userId?: UuidFilter<"MessageView"> | string
    createdAt?: DateTimeFilter<"MessageView"> | Date | string
    updatedAt?: DateTimeFilter<"MessageView"> | Date | string
  }

  export type ClasseUpsertWithWhereUniqueWithoutUserInput = {
    where: ClasseWhereUniqueInput
    update: XOR<ClasseUpdateWithoutUserInput, ClasseUncheckedUpdateWithoutUserInput>
    create: XOR<ClasseCreateWithoutUserInput, ClasseUncheckedCreateWithoutUserInput>
  }

  export type ClasseUpdateWithWhereUniqueWithoutUserInput = {
    where: ClasseWhereUniqueInput
    data: XOR<ClasseUpdateWithoutUserInput, ClasseUncheckedUpdateWithoutUserInput>
  }

  export type ClasseUpdateManyWithWhereWithoutUserInput = {
    where: ClasseScalarWhereInput
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyWithoutUserInput>
  }

  export type ClasseScalarWhereInput = {
    AND?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
    OR?: ClasseScalarWhereInput[]
    NOT?: ClasseScalarWhereInput | ClasseScalarWhereInput[]
    id?: UuidFilter<"Classe"> | string
    name?: StringFilter<"Classe"> | string
    usersId?: UuidFilter<"Classe"> | string
    projectId?: UuidFilter<"Classe"> | string
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
  }

  export type AccompanimentCreateWithoutProjectInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutProjectInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutProjectInput, AccompanimentUncheckedCreateWithoutProjectInput>
  }

  export type AccompanimentCreateManyProjectInputEnvelope = {
    data: AccompanimentCreateManyProjectInput | AccompanimentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutProjectInput = {
    id?: string
    date: Date | string
    reason: string
    createdAt: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateWithoutProjectInput = {
    id?: string
    date: Date | string
    reason: string
    memberId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutProjectInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutProjectInput, LeaveUncheckedCreateWithoutProjectInput>
  }

  export type LeaveCreateManyProjectInputEnvelope = {
    data: LeaveCreateManyProjectInput | LeaveCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutProjectInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureCreateNestedManyWithoutMemberInput
    emargements?: EmargementCreateNestedManyWithoutMemberInput
    leave?: LeaveCreateNestedOneWithoutMemberInput
    accompaniment?: AccompanimentCreateNestedOneWithoutMembersInput
    classe: ClasseCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutProjectInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutMemberInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutMemberInput
    leave?: LeaveUncheckedCreateNestedOneWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutProjectInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberCreateManyProjectInputEnvelope = {
    data: MemberCreateManyProjectInput | MemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ClasseCreateWithoutProjectInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutClasseInput
    members?: MemberCreateNestedManyWithoutClasseInput
  }

  export type ClasseUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutProjectInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutProjectInput, ClasseUncheckedCreateWithoutProjectInput>
  }

  export type ClasseCreateManyProjectInputEnvelope = {
    data: ClasseCreateManyProjectInput | ClasseCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChatParticipantCreateNestedManyWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChatParticipantUncheckedCreateNestedManyWithoutChatInput
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutProjectInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutProjectInput, ChatUncheckedCreateWithoutProjectInput>
  }

  export type AccompanimentUpsertWithWhereUniqueWithoutProjectInput = {
    where: AccompanimentWhereUniqueInput
    update: XOR<AccompanimentUpdateWithoutProjectInput, AccompanimentUncheckedUpdateWithoutProjectInput>
    create: XOR<AccompanimentCreateWithoutProjectInput, AccompanimentUncheckedCreateWithoutProjectInput>
  }

  export type AccompanimentUpdateWithWhereUniqueWithoutProjectInput = {
    where: AccompanimentWhereUniqueInput
    data: XOR<AccompanimentUpdateWithoutProjectInput, AccompanimentUncheckedUpdateWithoutProjectInput>
  }

  export type AccompanimentUpdateManyWithWhereWithoutProjectInput = {
    where: AccompanimentScalarWhereInput
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyWithoutProjectInput>
  }

  export type LeaveUpsertWithWhereUniqueWithoutProjectInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutProjectInput, LeaveUncheckedUpdateWithoutProjectInput>
    create: XOR<LeaveCreateWithoutProjectInput, LeaveUncheckedCreateWithoutProjectInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutProjectInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutProjectInput, LeaveUncheckedUpdateWithoutProjectInput>
  }

  export type LeaveUpdateManyWithWhereWithoutProjectInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutProjectInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: UuidFilter<"Leave"> | string
    date?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringFilter<"Leave"> | string
    projectId?: UuidFilter<"Leave"> | string
    memberId?: UuidFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
  }

  export type MemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
  }

  export type MemberUpdateManyWithWhereWithoutProjectInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: UuidFilter<"Member"> | string
    projectId?: UuidFilter<"Member"> | string
    profile?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    phone?: StringFilter<"Member"> | string
    gender?: StringFilter<"Member"> | string
    dob?: DateTimeFilter<"Member"> | Date | string
    commune?: StringFilter<"Member"> | string
    residential?: StringFilter<"Member"> | string
    disability?: StringFilter<"Member"> | string
    language?: StringFilter<"Member"> | string
    attestation?: StringFilter<"Member"> | string
    accompanimentId?: UuidNullableFilter<"Member"> | string | null
    classeId?: UuidFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
  }

  export type ClasseUpsertWithWhereUniqueWithoutProjectInput = {
    where: ClasseWhereUniqueInput
    update: XOR<ClasseUpdateWithoutProjectInput, ClasseUncheckedUpdateWithoutProjectInput>
    create: XOR<ClasseCreateWithoutProjectInput, ClasseUncheckedCreateWithoutProjectInput>
  }

  export type ClasseUpdateWithWhereUniqueWithoutProjectInput = {
    where: ClasseWhereUniqueInput
    data: XOR<ClasseUpdateWithoutProjectInput, ClasseUncheckedUpdateWithoutProjectInput>
  }

  export type ClasseUpdateManyWithWhereWithoutProjectInput = {
    where: ClasseScalarWhereInput
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyWithoutProjectInput>
  }

  export type ChatUpsertWithoutProjectInput = {
    update: XOR<ChatUpdateWithoutProjectInput, ChatUncheckedUpdateWithoutProjectInput>
    create: XOR<ChatCreateWithoutProjectInput, ChatUncheckedCreateWithoutProjectInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutProjectInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutProjectInput, ChatUncheckedUpdateWithoutProjectInput>
  }

  export type ChatUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChatParticipantUpdateManyWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChatParticipantUncheckedUpdateManyWithoutChatNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ProjectCreateWithoutLeaveInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    classes?: ClasseCreateNestedManyWithoutProjectInput
    chat?: ChatCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLeaveInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    classes?: ClasseUncheckedCreateNestedManyWithoutProjectInput
    chat?: ChatUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLeaveInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLeaveInput, ProjectUncheckedCreateWithoutLeaveInput>
  }

  export type MemberCreateWithoutLeaveInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    signatures?: SignatureCreateNestedManyWithoutMemberInput
    emargements?: EmargementCreateNestedManyWithoutMemberInput
    accompaniment?: AccompanimentCreateNestedOneWithoutMembersInput
    classe: ClasseCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutLeaveInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutMemberInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutLeaveInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutLeaveInput, MemberUncheckedCreateWithoutLeaveInput>
  }

  export type ProjectUpsertWithoutLeaveInput = {
    update: XOR<ProjectUpdateWithoutLeaveInput, ProjectUncheckedUpdateWithoutLeaveInput>
    create: XOR<ProjectCreateWithoutLeaveInput, ProjectUncheckedCreateWithoutLeaveInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLeaveInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLeaveInput, ProjectUncheckedUpdateWithoutLeaveInput>
  }

  export type ProjectUpdateWithoutLeaveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    classes?: ClasseUpdateManyWithoutProjectNestedInput
    chat?: ChatUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLeaveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutProjectNestedInput
    chat?: ChatUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type MemberUpsertWithoutLeaveInput = {
    update: XOR<MemberUpdateWithoutLeaveInput, MemberUncheckedUpdateWithoutLeaveInput>
    create: XOR<MemberCreateWithoutLeaveInput, MemberUncheckedCreateWithoutLeaveInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutLeaveInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutLeaveInput, MemberUncheckedUpdateWithoutLeaveInput>
  }

  export type MemberUpdateWithoutLeaveInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    signatures?: SignatureUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUpdateManyWithoutMemberNestedInput
    accompaniment?: AccompanimentUpdateOneWithoutMembersNestedInput
    classe?: ClasseUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutLeaveInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type UsersCreateWithoutAccompanimentsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutAccompanimentsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutAccompanimentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAccompanimentsInput, UsersUncheckedCreateWithoutAccompanimentsInput>
  }

  export type MapsCreateWithoutAccompanimentInput = {
    id?: string
    latitude: string
    longitude: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MapsUncheckedCreateWithoutAccompanimentInput = {
    id?: string
    latitude: string
    longitude: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MapsCreateOrConnectWithoutAccompanimentInput = {
    where: MapsWhereUniqueInput
    create: XOR<MapsCreateWithoutAccompanimentInput, MapsUncheckedCreateWithoutAccompanimentInput>
  }

  export type MemberCreateWithoutAccompanimentInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    signatures?: SignatureCreateNestedManyWithoutMemberInput
    emargements?: EmargementCreateNestedManyWithoutMemberInput
    leave?: LeaveCreateNestedOneWithoutMemberInput
    classe: ClasseCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutAccompanimentInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutMemberInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutMemberInput
    leave?: LeaveUncheckedCreateNestedOneWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutAccompanimentInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAccompanimentInput, MemberUncheckedCreateWithoutAccompanimentInput>
  }

  export type MemberCreateManyAccompanimentInputEnvelope = {
    data: MemberCreateManyAccompanimentInput | MemberCreateManyAccompanimentInput[]
    skipDuplicates?: boolean
  }

  export type FilesCreateWithoutAccompanimentsInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    Users?: UsersCreateNestedManyWithoutCvInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateWithoutAccompanimentsInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    rencontreId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesCreateOrConnectWithoutAccompanimentsInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutAccompanimentsInput, FilesUncheckedCreateWithoutAccompanimentsInput>
  }

  export type FilesCreateWithoutMediaInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    Users?: UsersCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
  }

  export type FilesUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    rencontreId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
  }

  export type FilesCreateOrConnectWithoutMediaInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutMediaInput, FilesUncheckedCreateWithoutMediaInput>
  }

  export type PurchaseCreateWithoutAccompanimentInput = {
    id?: string
    total: number
    createdAt: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutAccompanimentInput = {
    id?: string
    total: number
    createdAt: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutAccompanimentInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutAccompanimentInput, PurchaseUncheckedCreateWithoutAccompanimentInput>
  }

  export type PurchaseCreateManyAccompanimentInputEnvelope = {
    data: PurchaseCreateManyAccompanimentInput | PurchaseCreateManyAccompanimentInput[]
    skipDuplicates?: boolean
  }

  export type ConflitCreateWithoutAccompanimentInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesCreateNestedManyWithoutConflitInput
    files?: FilesCreateNestedManyWithoutConflitInput
    users: UsersCreateNestedOneWithoutConflitInput
  }

  export type ConflitUncheckedCreateWithoutAccompanimentInput = {
    id?: string
    nature: string
    resolution: string
    usersId: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    partieImpliques?: PersonnesUncheckedCreateNestedManyWithoutConflitInput
    files?: FilesUncheckedCreateNestedManyWithoutConflitInput
  }

  export type ConflitCreateOrConnectWithoutAccompanimentInput = {
    where: ConflitWhereUniqueInput
    create: XOR<ConflitCreateWithoutAccompanimentInput, ConflitUncheckedCreateWithoutAccompanimentInput>
  }

  export type ConflitCreateManyAccompanimentInputEnvelope = {
    data: ConflitCreateManyAccompanimentInput | ConflitCreateManyAccompanimentInput[]
    skipDuplicates?: boolean
  }

  export type RencontreCreateWithoutAccompanimentInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    signatures?: SignatureCreateNestedManyWithoutRencontreInput
    files?: FilesCreateNestedManyWithoutRencontreInput
    users: UsersCreateNestedOneWithoutRencontresInput
  }

  export type RencontreUncheckedCreateWithoutAccompanimentInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    usersId: string
    signatures?: SignatureUncheckedCreateNestedManyWithoutRencontreInput
    files?: FilesUncheckedCreateNestedManyWithoutRencontreInput
  }

  export type RencontreCreateOrConnectWithoutAccompanimentInput = {
    where: RencontreWhereUniqueInput
    create: XOR<RencontreCreateWithoutAccompanimentInput, RencontreUncheckedCreateWithoutAccompanimentInput>
  }

  export type RencontreCreateManyAccompanimentInputEnvelope = {
    data: RencontreCreateManyAccompanimentInput | RencontreCreateManyAccompanimentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutAccompanimentsInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    leave?: LeaveCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    classes?: ClasseCreateNestedManyWithoutProjectInput
    chat?: ChatCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAccompanimentsInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    leave?: LeaveUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    classes?: ClasseUncheckedCreateNestedManyWithoutProjectInput
    chat?: ChatUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAccompanimentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAccompanimentsInput, ProjectUncheckedCreateWithoutAccompanimentsInput>
  }

  export type PlanningCreateWithoutAccompanimentsInput = {
    id?: string
    visit?: VisitsCreateNestedManyWithoutPlanningInput
    users: UsersCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutAccompanimentsInput = {
    id?: string
    usersId: string
    visit?: VisitsUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutAccompanimentsInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutAccompanimentsInput, PlanningUncheckedCreateWithoutAccompanimentsInput>
  }

  export type UsersUpsertWithoutAccompanimentsInput = {
    update: XOR<UsersUpdateWithoutAccompanimentsInput, UsersUncheckedUpdateWithoutAccompanimentsInput>
    create: XOR<UsersCreateWithoutAccompanimentsInput, UsersUncheckedCreateWithoutAccompanimentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutAccompanimentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutAccompanimentsInput, UsersUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type UsersUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MapsUpsertWithoutAccompanimentInput = {
    update: XOR<MapsUpdateWithoutAccompanimentInput, MapsUncheckedUpdateWithoutAccompanimentInput>
    create: XOR<MapsCreateWithoutAccompanimentInput, MapsUncheckedCreateWithoutAccompanimentInput>
    where?: MapsWhereInput
  }

  export type MapsUpdateToOneWithWhereWithoutAccompanimentInput = {
    where?: MapsWhereInput
    data: XOR<MapsUpdateWithoutAccompanimentInput, MapsUncheckedUpdateWithoutAccompanimentInput>
  }

  export type MapsUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    longitude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapsUncheckedUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    longitude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpsertWithWhereUniqueWithoutAccompanimentInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutAccompanimentInput, MemberUncheckedUpdateWithoutAccompanimentInput>
    create: XOR<MemberCreateWithoutAccompanimentInput, MemberUncheckedCreateWithoutAccompanimentInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutAccompanimentInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutAccompanimentInput, MemberUncheckedUpdateWithoutAccompanimentInput>
  }

  export type MemberUpdateManyWithWhereWithoutAccompanimentInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutAccompanimentInput>
  }

  export type FilesUpsertWithoutAccompanimentsInput = {
    update: XOR<FilesUpdateWithoutAccompanimentsInput, FilesUncheckedUpdateWithoutAccompanimentsInput>
    create: XOR<FilesCreateWithoutAccompanimentsInput, FilesUncheckedCreateWithoutAccompanimentsInput>
    where?: FilesWhereInput
  }

  export type FilesUpdateToOneWithWhereWithoutAccompanimentsInput = {
    where?: FilesWhereInput
    data: XOR<FilesUpdateWithoutAccompanimentsInput, FilesUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type FilesUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FilesUpsertWithWhereUniqueWithoutMediaInput = {
    where: FilesWhereUniqueInput
    update: XOR<FilesUpdateWithoutMediaInput, FilesUncheckedUpdateWithoutMediaInput>
    create: XOR<FilesCreateWithoutMediaInput, FilesUncheckedCreateWithoutMediaInput>
  }

  export type FilesUpdateWithWhereUniqueWithoutMediaInput = {
    where: FilesWhereUniqueInput
    data: XOR<FilesUpdateWithoutMediaInput, FilesUncheckedUpdateWithoutMediaInput>
  }

  export type FilesUpdateManyWithWhereWithoutMediaInput = {
    where: FilesScalarWhereInput
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyWithoutMediaInput>
  }

  export type FilesScalarWhereInput = {
    AND?: FilesScalarWhereInput | FilesScalarWhereInput[]
    OR?: FilesScalarWhereInput[]
    NOT?: FilesScalarWhereInput | FilesScalarWhereInput[]
    id?: UuidFilter<"Files"> | string
    name?: StringFilter<"Files"> | string
    type?: StringFilter<"Files"> | string
    url?: StringFilter<"Files"> | string
    size?: IntFilter<"Files"> | number
    visiteTerrainId?: UuidNullableFilter<"Files"> | string | null
    conflitId?: UuidNullableFilter<"Files"> | string | null
    rencontreId?: UuidNullableFilter<"Files"> | string | null
  }

  export type PurchaseUpsertWithWhereUniqueWithoutAccompanimentInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutAccompanimentInput, PurchaseUncheckedUpdateWithoutAccompanimentInput>
    create: XOR<PurchaseCreateWithoutAccompanimentInput, PurchaseUncheckedCreateWithoutAccompanimentInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutAccompanimentInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutAccompanimentInput, PurchaseUncheckedUpdateWithoutAccompanimentInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutAccompanimentInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutAccompanimentInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: UuidFilter<"Purchase"> | string
    total?: IntFilter<"Purchase"> | number
    accompanimentId?: UuidFilter<"Purchase"> | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type ConflitUpsertWithWhereUniqueWithoutAccompanimentInput = {
    where: ConflitWhereUniqueInput
    update: XOR<ConflitUpdateWithoutAccompanimentInput, ConflitUncheckedUpdateWithoutAccompanimentInput>
    create: XOR<ConflitCreateWithoutAccompanimentInput, ConflitUncheckedCreateWithoutAccompanimentInput>
  }

  export type ConflitUpdateWithWhereUniqueWithoutAccompanimentInput = {
    where: ConflitWhereUniqueInput
    data: XOR<ConflitUpdateWithoutAccompanimentInput, ConflitUncheckedUpdateWithoutAccompanimentInput>
  }

  export type ConflitUpdateManyWithWhereWithoutAccompanimentInput = {
    where: ConflitScalarWhereInput
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyWithoutAccompanimentInput>
  }

  export type RencontreUpsertWithWhereUniqueWithoutAccompanimentInput = {
    where: RencontreWhereUniqueInput
    update: XOR<RencontreUpdateWithoutAccompanimentInput, RencontreUncheckedUpdateWithoutAccompanimentInput>
    create: XOR<RencontreCreateWithoutAccompanimentInput, RencontreUncheckedCreateWithoutAccompanimentInput>
  }

  export type RencontreUpdateWithWhereUniqueWithoutAccompanimentInput = {
    where: RencontreWhereUniqueInput
    data: XOR<RencontreUpdateWithoutAccompanimentInput, RencontreUncheckedUpdateWithoutAccompanimentInput>
  }

  export type RencontreUpdateManyWithWhereWithoutAccompanimentInput = {
    where: RencontreScalarWhereInput
    data: XOR<RencontreUpdateManyMutationInput, RencontreUncheckedUpdateManyWithoutAccompanimentInput>
  }

  export type ProjectUpsertWithoutAccompanimentsInput = {
    update: XOR<ProjectUpdateWithoutAccompanimentsInput, ProjectUncheckedUpdateWithoutAccompanimentsInput>
    create: XOR<ProjectCreateWithoutAccompanimentsInput, ProjectUncheckedCreateWithoutAccompanimentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAccompanimentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAccompanimentsInput, ProjectUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type ProjectUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leave?: LeaveUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    classes?: ClasseUpdateManyWithoutProjectNestedInput
    chat?: ChatUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leave?: LeaveUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutProjectNestedInput
    chat?: ChatUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type PlanningUpsertWithoutAccompanimentsInput = {
    update: XOR<PlanningUpdateWithoutAccompanimentsInput, PlanningUncheckedUpdateWithoutAccompanimentsInput>
    create: XOR<PlanningCreateWithoutAccompanimentsInput, PlanningUncheckedCreateWithoutAccompanimentsInput>
    where?: PlanningWhereInput
  }

  export type PlanningUpdateToOneWithWhereWithoutAccompanimentsInput = {
    where?: PlanningWhereInput
    data: XOR<PlanningUpdateWithoutAccompanimentsInput, PlanningUncheckedUpdateWithoutAccompanimentsInput>
  }

  export type PlanningUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    visit?: VisitsUpdateManyWithoutPlanningNestedInput
    users?: UsersUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutAccompanimentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    visit?: VisitsUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type UsersCreateWithoutClasseInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutClasseInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutClasseInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutClasseInput, UsersUncheckedCreateWithoutClasseInput>
  }

  export type MemberCreateWithoutClasseInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    signatures?: SignatureCreateNestedManyWithoutMemberInput
    emargements?: EmargementCreateNestedManyWithoutMemberInput
    leave?: LeaveCreateNestedOneWithoutMemberInput
    accompaniment?: AccompanimentCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutClasseInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutMemberInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutMemberInput
    leave?: LeaveUncheckedCreateNestedOneWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutClasseInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutClasseInput, MemberUncheckedCreateWithoutClasseInput>
  }

  export type MemberCreateManyClasseInputEnvelope = {
    data: MemberCreateManyClasseInput | MemberCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutClassesInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentCreateNestedManyWithoutProjectInput
    leave?: LeaveCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    chat?: ChatCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProjectInput
    leave?: LeaveUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    chat?: ChatUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClassesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClassesInput, ProjectUncheckedCreateWithoutClassesInput>
  }

  export type UsersUpsertWithoutClasseInput = {
    update: XOR<UsersUpdateWithoutClasseInput, UsersUncheckedUpdateWithoutClasseInput>
    create: XOR<UsersCreateWithoutClasseInput, UsersUncheckedCreateWithoutClasseInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutClasseInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutClasseInput, UsersUncheckedUpdateWithoutClasseInput>
  }

  export type UsersUpdateWithoutClasseInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutClasseInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MemberUpsertWithWhereUniqueWithoutClasseInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutClasseInput, MemberUncheckedUpdateWithoutClasseInput>
    create: XOR<MemberCreateWithoutClasseInput, MemberUncheckedCreateWithoutClasseInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutClasseInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutClasseInput, MemberUncheckedUpdateWithoutClasseInput>
  }

  export type MemberUpdateManyWithWhereWithoutClasseInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutClasseInput>
  }

  export type ProjectUpsertWithoutClassesInput = {
    update: XOR<ProjectUpdateWithoutClassesInput, ProjectUncheckedUpdateWithoutClassesInput>
    create: XOR<ProjectCreateWithoutClassesInput, ProjectUncheckedCreateWithoutClassesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutClassesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutClassesInput, ProjectUncheckedUpdateWithoutClassesInput>
  }

  export type ProjectUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUpdateManyWithoutProjectNestedInput
    leave?: LeaveUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    chat?: ChatUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProjectNestedInput
    leave?: LeaveUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    chat?: ChatUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentCreateNestedManyWithoutProjectInput
    leave?: LeaveCreateNestedManyWithoutProjectInput
    classes?: ClasseCreateNestedManyWithoutProjectInput
    chat?: ChatCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProjectInput
    leave?: LeaveUncheckedCreateNestedManyWithoutProjectInput
    classes?: ClasseUncheckedCreateNestedManyWithoutProjectInput
    chat?: ChatUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type SignatureCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    present?: boolean
    Rencontre?: RencontreCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    present?: boolean
    rencontreId?: string | null
  }

  export type SignatureCreateOrConnectWithoutMemberInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutMemberInput, SignatureUncheckedCreateWithoutMemberInput>
  }

  export type SignatureCreateManyMemberInputEnvelope = {
    data: SignatureCreateManyMemberInput | SignatureCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type EmargementCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    users: UsersCreateNestedOneWithoutEmargementsInput
  }

  export type EmargementUncheckedCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    usersId: string
  }

  export type EmargementCreateOrConnectWithoutMemberInput = {
    where: EmargementWhereUniqueInput
    create: XOR<EmargementCreateWithoutMemberInput, EmargementUncheckedCreateWithoutMemberInput>
  }

  export type EmargementCreateManyMemberInputEnvelope = {
    data: EmargementCreateManyMemberInput | EmargementCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    reason: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    reason: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutMemberInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutMemberInput, LeaveUncheckedCreateWithoutMemberInput>
  }

  export type AccompanimentCreateWithoutMembersInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutMembersInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutMembersInput, AccompanimentUncheckedCreateWithoutMembersInput>
  }

  export type ClasseCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutClasseInput
    project: ProjectCreateNestedOneWithoutClassesInput
  }

  export type ClasseUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    usersId: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ClasseCreateOrConnectWithoutMembersInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutMembersInput, ClasseUncheckedCreateWithoutMembersInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUpdateManyWithoutProjectNestedInput
    leave?: LeaveUpdateManyWithoutProjectNestedInput
    classes?: ClasseUpdateManyWithoutProjectNestedInput
    chat?: ChatUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProjectNestedInput
    leave?: LeaveUncheckedUpdateManyWithoutProjectNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutProjectNestedInput
    chat?: ChatUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type SignatureUpsertWithWhereUniqueWithoutMemberInput = {
    where: SignatureWhereUniqueInput
    update: XOR<SignatureUpdateWithoutMemberInput, SignatureUncheckedUpdateWithoutMemberInput>
    create: XOR<SignatureCreateWithoutMemberInput, SignatureUncheckedCreateWithoutMemberInput>
  }

  export type SignatureUpdateWithWhereUniqueWithoutMemberInput = {
    where: SignatureWhereUniqueInput
    data: XOR<SignatureUpdateWithoutMemberInput, SignatureUncheckedUpdateWithoutMemberInput>
  }

  export type SignatureUpdateManyWithWhereWithoutMemberInput = {
    where: SignatureScalarWhereInput
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyWithoutMemberInput>
  }

  export type SignatureScalarWhereInput = {
    AND?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
    OR?: SignatureScalarWhereInput[]
    NOT?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
    id?: UuidFilter<"Signature"> | string
    date?: DateTimeFilter<"Signature"> | Date | string
    present?: BoolFilter<"Signature"> | boolean
    memberId?: UuidFilter<"Signature"> | string
    rencontreId?: UuidNullableFilter<"Signature"> | string | null
  }

  export type EmargementUpsertWithWhereUniqueWithoutMemberInput = {
    where: EmargementWhereUniqueInput
    update: XOR<EmargementUpdateWithoutMemberInput, EmargementUncheckedUpdateWithoutMemberInput>
    create: XOR<EmargementCreateWithoutMemberInput, EmargementUncheckedCreateWithoutMemberInput>
  }

  export type EmargementUpdateWithWhereUniqueWithoutMemberInput = {
    where: EmargementWhereUniqueInput
    data: XOR<EmargementUpdateWithoutMemberInput, EmargementUncheckedUpdateWithoutMemberInput>
  }

  export type EmargementUpdateManyWithWhereWithoutMemberInput = {
    where: EmargementScalarWhereInput
    data: XOR<EmargementUpdateManyMutationInput, EmargementUncheckedUpdateManyWithoutMemberInput>
  }

  export type LeaveUpsertWithoutMemberInput = {
    update: XOR<LeaveUpdateWithoutMemberInput, LeaveUncheckedUpdateWithoutMemberInput>
    create: XOR<LeaveCreateWithoutMemberInput, LeaveUncheckedCreateWithoutMemberInput>
    where?: LeaveWhereInput
  }

  export type LeaveUpdateToOneWithWhereWithoutMemberInput = {
    where?: LeaveWhereInput
    data: XOR<LeaveUpdateWithoutMemberInput, LeaveUncheckedUpdateWithoutMemberInput>
  }

  export type LeaveUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentUpsertWithoutMembersInput = {
    update: XOR<AccompanimentUpdateWithoutMembersInput, AccompanimentUncheckedUpdateWithoutMembersInput>
    create: XOR<AccompanimentCreateWithoutMembersInput, AccompanimentUncheckedCreateWithoutMembersInput>
    where?: AccompanimentWhereInput
  }

  export type AccompanimentUpdateToOneWithWhereWithoutMembersInput = {
    where?: AccompanimentWhereInput
    data: XOR<AccompanimentUpdateWithoutMembersInput, AccompanimentUncheckedUpdateWithoutMembersInput>
  }

  export type AccompanimentUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type ClasseUpsertWithoutMembersInput = {
    update: XOR<ClasseUpdateWithoutMembersInput, ClasseUncheckedUpdateWithoutMembersInput>
    create: XOR<ClasseCreateWithoutMembersInput, ClasseUncheckedCreateWithoutMembersInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutMembersInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutMembersInput, ClasseUncheckedUpdateWithoutMembersInput>
  }

  export type ClasseUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutClasseNestedInput
    project?: ProjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutChatInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentCreateNestedManyWithoutProjectInput
    leave?: LeaveCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    classes?: ClasseCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutChatInput = {
    id?: string
    name: string
    status?: boolean
    local: string
    startDate: Date | string
    endDate: Date | string
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutProjectInput
    leave?: LeaveUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    classes?: ClasseUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutChatInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutChatInput, ProjectUncheckedCreateWithoutChatInput>
  }

  export type ChatParticipantCreateWithoutChatInput = {
    id?: string
    joinedAt?: Date | string
    user: UsersCreateNestedOneWithoutChatParticipantInput
  }

  export type ChatParticipantUncheckedCreateWithoutChatInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type ChatParticipantCreateOrConnectWithoutChatInput = {
    where: ChatParticipantWhereUniqueInput
    create: XOR<ChatParticipantCreateWithoutChatInput, ChatParticipantUncheckedCreateWithoutChatInput>
  }

  export type ChatParticipantCreateManyChatInputEnvelope = {
    data: ChatParticipantCreateManyChatInput | ChatParticipantCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content: string
    sentAt?: Date | string
    messageView?: MessageViewCreateNestedManyWithoutMessageInput
    sender: UsersCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    content: string
    sentAt?: Date | string
    senderId: string
    messageView?: MessageViewUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutChatInput = {
    update: XOR<ProjectUpdateWithoutChatInput, ProjectUncheckedUpdateWithoutChatInput>
    create: XOR<ProjectCreateWithoutChatInput, ProjectUncheckedCreateWithoutChatInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutChatInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutChatInput, ProjectUncheckedUpdateWithoutChatInput>
  }

  export type ProjectUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUpdateManyWithoutProjectNestedInput
    leave?: LeaveUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    classes?: ClasseUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    local?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutProjectNestedInput
    leave?: LeaveUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    classes?: ClasseUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ChatParticipantUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatParticipantWhereUniqueInput
    update: XOR<ChatParticipantUpdateWithoutChatInput, ChatParticipantUncheckedUpdateWithoutChatInput>
    create: XOR<ChatParticipantCreateWithoutChatInput, ChatParticipantUncheckedCreateWithoutChatInput>
  }

  export type ChatParticipantUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatParticipantWhereUniqueInput
    data: XOR<ChatParticipantUpdateWithoutChatInput, ChatParticipantUncheckedUpdateWithoutChatInput>
  }

  export type ChatParticipantUpdateManyWithWhereWithoutChatInput = {
    where: ChatParticipantScalarWhereInput
    data: XOR<ChatParticipantUpdateManyMutationInput, ChatParticipantUncheckedUpdateManyWithoutChatInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type UsersCreateWithoutChatParticipantInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutChatParticipantInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutChatParticipantInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutChatParticipantInput, UsersUncheckedCreateWithoutChatParticipantInput>
  }

  export type ChatCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutParticipantsInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutParticipantsInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutParticipantsInput, ChatUncheckedCreateWithoutParticipantsInput>
  }

  export type UsersUpsertWithoutChatParticipantInput = {
    update: XOR<UsersUpdateWithoutChatParticipantInput, UsersUncheckedUpdateWithoutChatParticipantInput>
    create: XOR<UsersCreateWithoutChatParticipantInput, UsersUncheckedCreateWithoutChatParticipantInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutChatParticipantInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutChatParticipantInput, UsersUncheckedUpdateWithoutChatParticipantInput>
  }

  export type UsersUpdateWithoutChatParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutChatParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatUpsertWithoutParticipantsInput = {
    update: XOR<ChatUpdateWithoutParticipantsInput, ChatUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ChatCreateWithoutParticipantsInput, ChatUncheckedCreateWithoutParticipantsInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutParticipantsInput, ChatUncheckedUpdateWithoutParticipantsInput>
  }

  export type ChatUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type MessageViewCreateWithoutMessageInput = {
    id?: string
    view?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutMessageViewInput
  }

  export type MessageViewUncheckedCreateWithoutMessageInput = {
    id?: string
    view?: boolean
    userId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MessageViewCreateOrConnectWithoutMessageInput = {
    where: MessageViewWhereUniqueInput
    create: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput>
  }

  export type MessageViewCreateManyMessageInputEnvelope = {
    data: MessageViewCreateManyMessageInput | MessageViewCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutMessageInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutMessageInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutMessageInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessageInput, UsersUncheckedCreateWithoutMessageInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChatInput
    participants?: ChatParticipantCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChatParticipantUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type MessageViewUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageViewWhereUniqueInput
    update: XOR<MessageViewUpdateWithoutMessageInput, MessageViewUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageViewCreateWithoutMessageInput, MessageViewUncheckedCreateWithoutMessageInput>
  }

  export type MessageViewUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageViewWhereUniqueInput
    data: XOR<MessageViewUpdateWithoutMessageInput, MessageViewUncheckedUpdateWithoutMessageInput>
  }

  export type MessageViewUpdateManyWithWhereWithoutMessageInput = {
    where: MessageViewScalarWhereInput
    data: XOR<MessageViewUpdateManyMutationInput, MessageViewUncheckedUpdateManyWithoutMessageInput>
  }

  export type UsersUpsertWithoutMessageInput = {
    update: XOR<UsersUpdateWithoutMessageInput, UsersUncheckedUpdateWithoutMessageInput>
    create: XOR<UsersCreateWithoutMessageInput, UsersUncheckedCreateWithoutMessageInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessageInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessageInput, UsersUncheckedUpdateWithoutMessageInput>
  }

  export type UsersUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChatNestedInput
    participants?: ChatParticipantUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChatParticipantUncheckedUpdateManyWithoutChatNestedInput
  }

  export type MessageCreateWithoutMessageViewInput = {
    id?: string
    content: string
    sentAt?: Date | string
    sender: UsersCreateNestedOneWithoutMessageInput
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutMessageViewInput = {
    id?: string
    content: string
    sentAt?: Date | string
    senderId: string
    chatId: string
  }

  export type MessageCreateOrConnectWithoutMessageViewInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMessageViewInput, MessageUncheckedCreateWithoutMessageViewInput>
  }

  export type UsersCreateWithoutMessageViewInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutMessageViewInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutMessageViewInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessageViewInput, UsersUncheckedCreateWithoutMessageViewInput>
  }

  export type MessageUpsertWithoutMessageViewInput = {
    update: XOR<MessageUpdateWithoutMessageViewInput, MessageUncheckedUpdateWithoutMessageViewInput>
    create: XOR<MessageCreateWithoutMessageViewInput, MessageUncheckedCreateWithoutMessageViewInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutMessageViewInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutMessageViewInput, MessageUncheckedUpdateWithoutMessageViewInput>
  }

  export type MessageUpdateWithoutMessageViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutMessageNestedInput
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutMessageViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUpsertWithoutMessageViewInput = {
    update: XOR<UsersUpdateWithoutMessageViewInput, UsersUncheckedUpdateWithoutMessageViewInput>
    create: XOR<UsersCreateWithoutMessageViewInput, UsersUncheckedCreateWithoutMessageViewInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessageViewInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessageViewInput, UsersUncheckedUpdateWithoutMessageViewInput>
  }

  export type UsersUpdateWithoutMessageViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessageViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanningCreateWithoutVisitInput = {
    id?: string
    accompaniments?: AccompanimentCreateNestedManyWithoutPlanningInput
    users: UsersCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateWithoutVisitInput = {
    id?: string
    usersId: string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutPlanningInput
  }

  export type PlanningCreateOrConnectWithoutVisitInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutVisitInput, PlanningUncheckedCreateWithoutVisitInput>
  }

  export type VisiteTerrainCreateWithoutVisitInput = {
    id?: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
    personnes?: PersonnesCreateNestedManyWithoutVisiteTerrainInput
    files?: FilesCreateNestedManyWithoutVisiteTerrainInput
    users: UsersCreateNestedOneWithoutVisiteTerrainsInput
  }

  export type VisiteTerrainUncheckedCreateWithoutVisitInput = {
    id?: string
    observations: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
    personnes?: PersonnesUncheckedCreateNestedManyWithoutVisiteTerrainInput
    files?: FilesUncheckedCreateNestedManyWithoutVisiteTerrainInput
  }

  export type VisiteTerrainCreateOrConnectWithoutVisitInput = {
    where: VisiteTerrainWhereUniqueInput
    create: XOR<VisiteTerrainCreateWithoutVisitInput, VisiteTerrainUncheckedCreateWithoutVisitInput>
  }

  export type PlanningUpsertWithoutVisitInput = {
    update: XOR<PlanningUpdateWithoutVisitInput, PlanningUncheckedUpdateWithoutVisitInput>
    create: XOR<PlanningCreateWithoutVisitInput, PlanningUncheckedCreateWithoutVisitInput>
    where?: PlanningWhereInput
  }

  export type PlanningUpdateToOneWithWhereWithoutVisitInput = {
    where?: PlanningWhereInput
    data: XOR<PlanningUpdateWithoutVisitInput, PlanningUncheckedUpdateWithoutVisitInput>
  }

  export type PlanningUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    accompaniments?: AccompanimentUpdateManyWithoutPlanningNestedInput
    users?: UsersUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type VisiteTerrainUpsertWithoutVisitInput = {
    update: XOR<VisiteTerrainUpdateWithoutVisitInput, VisiteTerrainUncheckedUpdateWithoutVisitInput>
    create: XOR<VisiteTerrainCreateWithoutVisitInput, VisiteTerrainUncheckedCreateWithoutVisitInput>
    where?: VisiteTerrainWhereInput
  }

  export type VisiteTerrainUpdateToOneWithWhereWithoutVisitInput = {
    where?: VisiteTerrainWhereInput
    data: XOR<VisiteTerrainUpdateWithoutVisitInput, VisiteTerrainUncheckedUpdateWithoutVisitInput>
  }

  export type VisiteTerrainUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnes?: PersonnesUpdateManyWithoutVisiteTerrainNestedInput
    files?: FilesUpdateManyWithoutVisiteTerrainNestedInput
    users?: UsersUpdateOneRequiredWithoutVisiteTerrainsNestedInput
  }

  export type VisiteTerrainUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnes?: PersonnesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
    files?: FilesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
  }

  export type AccompanimentCreateWithoutPlanningInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutPlanningInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutPlanningInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutPlanningInput, AccompanimentUncheckedCreateWithoutPlanningInput>
  }

  export type AccompanimentCreateManyPlanningInputEnvelope = {
    data: AccompanimentCreateManyPlanningInput | AccompanimentCreateManyPlanningInput[]
    skipDuplicates?: boolean
  }

  export type VisitsCreateWithoutPlanningInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    VisiteTerrain?: VisiteTerrainCreateNestedOneWithoutVisitInput
  }

  export type VisitsUncheckedCreateWithoutPlanningInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    VisiteTerrain?: VisiteTerrainUncheckedCreateNestedOneWithoutVisitInput
  }

  export type VisitsCreateOrConnectWithoutPlanningInput = {
    where: VisitsWhereUniqueInput
    create: XOR<VisitsCreateWithoutPlanningInput, VisitsUncheckedCreateWithoutPlanningInput>
  }

  export type VisitsCreateManyPlanningInputEnvelope = {
    data: VisitsCreateManyPlanningInput | VisitsCreateManyPlanningInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutPlanningsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutPlanningsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutPlanningsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPlanningsInput, UsersUncheckedCreateWithoutPlanningsInput>
  }

  export type AccompanimentUpsertWithWhereUniqueWithoutPlanningInput = {
    where: AccompanimentWhereUniqueInput
    update: XOR<AccompanimentUpdateWithoutPlanningInput, AccompanimentUncheckedUpdateWithoutPlanningInput>
    create: XOR<AccompanimentCreateWithoutPlanningInput, AccompanimentUncheckedCreateWithoutPlanningInput>
  }

  export type AccompanimentUpdateWithWhereUniqueWithoutPlanningInput = {
    where: AccompanimentWhereUniqueInput
    data: XOR<AccompanimentUpdateWithoutPlanningInput, AccompanimentUncheckedUpdateWithoutPlanningInput>
  }

  export type AccompanimentUpdateManyWithWhereWithoutPlanningInput = {
    where: AccompanimentScalarWhereInput
    data: XOR<AccompanimentUpdateManyMutationInput, AccompanimentUncheckedUpdateManyWithoutPlanningInput>
  }

  export type VisitsUpsertWithWhereUniqueWithoutPlanningInput = {
    where: VisitsWhereUniqueInput
    update: XOR<VisitsUpdateWithoutPlanningInput, VisitsUncheckedUpdateWithoutPlanningInput>
    create: XOR<VisitsCreateWithoutPlanningInput, VisitsUncheckedCreateWithoutPlanningInput>
  }

  export type VisitsUpdateWithWhereUniqueWithoutPlanningInput = {
    where: VisitsWhereUniqueInput
    data: XOR<VisitsUpdateWithoutPlanningInput, VisitsUncheckedUpdateWithoutPlanningInput>
  }

  export type VisitsUpdateManyWithWhereWithoutPlanningInput = {
    where: VisitsScalarWhereInput
    data: XOR<VisitsUpdateManyMutationInput, VisitsUncheckedUpdateManyWithoutPlanningInput>
  }

  export type VisitsScalarWhereInput = {
    AND?: VisitsScalarWhereInput | VisitsScalarWhereInput[]
    OR?: VisitsScalarWhereInput[]
    NOT?: VisitsScalarWhereInput | VisitsScalarWhereInput[]
    id?: UuidFilter<"Visits"> | string
    date?: DateTimeFilter<"Visits"> | Date | string
    startTime?: StringFilter<"Visits"> | string
    endTime?: StringFilter<"Visits"> | string
    status?: BoolFilter<"Visits"> | boolean
    location?: StringFilter<"Visits"> | string
    objetif?: StringFilter<"Visits"> | string
    planningId?: UuidFilter<"Visits"> | string
  }

  export type UsersUpsertWithoutPlanningsInput = {
    update: XOR<UsersUpdateWithoutPlanningsInput, UsersUncheckedUpdateWithoutPlanningsInput>
    create: XOR<UsersCreateWithoutPlanningsInput, UsersUncheckedCreateWithoutPlanningsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPlanningsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPlanningsInput, UsersUncheckedUpdateWithoutPlanningsInput>
  }

  export type UsersUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccompanimentCreateWithoutMapInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutMapInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutMapInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutMapInput, AccompanimentUncheckedCreateWithoutMapInput>
  }

  export type AccompanimentUpsertWithoutMapInput = {
    update: XOR<AccompanimentUpdateWithoutMapInput, AccompanimentUncheckedUpdateWithoutMapInput>
    create: XOR<AccompanimentCreateWithoutMapInput, AccompanimentUncheckedCreateWithoutMapInput>
    where?: AccompanimentWhereInput
  }

  export type AccompanimentUpdateToOneWithWhereWithoutMapInput = {
    where?: AccompanimentWhereInput
    data: XOR<AccompanimentUpdateWithoutMapInput, AccompanimentUncheckedUpdateWithoutMapInput>
  }

  export type AccompanimentUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type PurchaseCreateWithoutPurchaseItemsInput = {
    id?: string
    total: number
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniment: AccompanimentCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutPurchaseItemsInput = {
    id?: string
    total: number
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutPurchaseItemsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutPurchaseItemsInput, PurchaseUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type PurchaseUpsertWithoutPurchaseItemsInput = {
    update: XOR<PurchaseUpdateWithoutPurchaseItemsInput, PurchaseUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<PurchaseCreateWithoutPurchaseItemsInput, PurchaseUncheckedCreateWithoutPurchaseItemsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutPurchaseItemsInput, PurchaseUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type PurchaseUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniment?: AccompanimentUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsCreateWithoutPurchaseInput = {
    id?: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date | string
  }

  export type PurchaseItemsUncheckedCreateWithoutPurchaseInput = {
    id?: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date | string
  }

  export type PurchaseItemsCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseItemsWhereUniqueInput
    create: XOR<PurchaseItemsCreateWithoutPurchaseInput, PurchaseItemsUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemsCreateManyPurchaseInputEnvelope = {
    data: PurchaseItemsCreateManyPurchaseInput | PurchaseItemsCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type AccompanimentCreateWithoutPurchasesInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutPurchasesInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutPurchasesInput, AccompanimentUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemsWhereUniqueInput
    update: XOR<PurchaseItemsUpdateWithoutPurchaseInput, PurchaseItemsUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseItemsCreateWithoutPurchaseInput, PurchaseItemsUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemsWhereUniqueInput
    data: XOR<PurchaseItemsUpdateWithoutPurchaseInput, PurchaseItemsUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemsUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseItemsScalarWhereInput
    data: XOR<PurchaseItemsUpdateManyMutationInput, PurchaseItemsUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseItemsScalarWhereInput = {
    AND?: PurchaseItemsScalarWhereInput | PurchaseItemsScalarWhereInput[]
    OR?: PurchaseItemsScalarWhereInput[]
    NOT?: PurchaseItemsScalarWhereInput | PurchaseItemsScalarWhereInput[]
    id?: UuidFilter<"PurchaseItems"> | string
    name?: StringFilter<"PurchaseItems"> | string
    price?: StringFilter<"PurchaseItems"> | string
    image?: StringFilter<"PurchaseItems"> | string
    quantity?: IntFilter<"PurchaseItems"> | number
    date?: DateTimeFilter<"PurchaseItems"> | Date | string
    purchaseId?: UuidFilter<"PurchaseItems"> | string
  }

  export type AccompanimentUpsertWithoutPurchasesInput = {
    update: XOR<AccompanimentUpdateWithoutPurchasesInput, AccompanimentUncheckedUpdateWithoutPurchasesInput>
    create: XOR<AccompanimentCreateWithoutPurchasesInput, AccompanimentUncheckedCreateWithoutPurchasesInput>
    where?: AccompanimentWhereInput
  }

  export type AccompanimentUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: AccompanimentWhereInput
    data: XOR<AccompanimentUpdateWithoutPurchasesInput, AccompanimentUncheckedUpdateWithoutPurchasesInput>
  }

  export type AccompanimentUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type UsersCreateWithoutEmargementsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutEmargementsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutEmargementsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutEmargementsInput, UsersUncheckedCreateWithoutEmargementsInput>
  }

  export type MemberCreateWithoutEmargementsInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    createdAt: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    signatures?: SignatureCreateNestedManyWithoutMemberInput
    leave?: LeaveCreateNestedOneWithoutMemberInput
    accompaniment?: AccompanimentCreateNestedOneWithoutMembersInput
    classe: ClasseCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutEmargementsInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutMemberInput
    leave?: LeaveUncheckedCreateNestedOneWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutEmargementsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutEmargementsInput, MemberUncheckedCreateWithoutEmargementsInput>
  }

  export type UsersUpsertWithoutEmargementsInput = {
    update: XOR<UsersUpdateWithoutEmargementsInput, UsersUncheckedUpdateWithoutEmargementsInput>
    create: XOR<UsersCreateWithoutEmargementsInput, UsersUncheckedCreateWithoutEmargementsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutEmargementsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutEmargementsInput, UsersUncheckedUpdateWithoutEmargementsInput>
  }

  export type UsersUpdateWithoutEmargementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutEmargementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MemberUpsertWithoutEmargementsInput = {
    update: XOR<MemberUpdateWithoutEmargementsInput, MemberUncheckedUpdateWithoutEmargementsInput>
    create: XOR<MemberCreateWithoutEmargementsInput, MemberUncheckedCreateWithoutEmargementsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutEmargementsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutEmargementsInput, MemberUncheckedUpdateWithoutEmargementsInput>
  }

  export type MemberUpdateWithoutEmargementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    signatures?: SignatureUpdateManyWithoutMemberNestedInput
    leave?: LeaveUpdateOneWithoutMemberNestedInput
    accompaniment?: AccompanimentUpdateOneWithoutMembersNestedInput
    classe?: ClasseUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutEmargementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutMemberNestedInput
    leave?: LeaveUncheckedUpdateOneWithoutMemberNestedInput
  }

  export type VisitsCreateWithoutVisiteTerrainInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    Planning: PlanningCreateNestedOneWithoutVisitInput
  }

  export type VisitsUncheckedCreateWithoutVisiteTerrainInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
    planningId: string
  }

  export type VisitsCreateOrConnectWithoutVisiteTerrainInput = {
    where: VisitsWhereUniqueInput
    create: XOR<VisitsCreateWithoutVisiteTerrainInput, VisitsUncheckedCreateWithoutVisiteTerrainInput>
  }

  export type PersonnesCreateWithoutVisiteTerrainInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    Conflit?: ConflitCreateNestedOneWithoutPartieImpliquesInput
  }

  export type PersonnesUncheckedCreateWithoutVisiteTerrainInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    conflitId?: string | null
  }

  export type PersonnesCreateOrConnectWithoutVisiteTerrainInput = {
    where: PersonnesWhereUniqueInput
    create: XOR<PersonnesCreateWithoutVisiteTerrainInput, PersonnesUncheckedCreateWithoutVisiteTerrainInput>
  }

  export type PersonnesCreateManyVisiteTerrainInputEnvelope = {
    data: PersonnesCreateManyVisiteTerrainInput | PersonnesCreateManyVisiteTerrainInput[]
    skipDuplicates?: boolean
  }

  export type FilesCreateWithoutVisiteTerrainInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    Users?: UsersCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateWithoutVisiteTerrainInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    conflitId?: string | null
    rencontreId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesCreateOrConnectWithoutVisiteTerrainInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutVisiteTerrainInput, FilesUncheckedCreateWithoutVisiteTerrainInput>
  }

  export type FilesCreateManyVisiteTerrainInputEnvelope = {
    data: FilesCreateManyVisiteTerrainInput | FilesCreateManyVisiteTerrainInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutVisiteTerrainsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutVisiteTerrainsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutVisiteTerrainsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutVisiteTerrainsInput, UsersUncheckedCreateWithoutVisiteTerrainsInput>
  }

  export type VisitsUpsertWithoutVisiteTerrainInput = {
    update: XOR<VisitsUpdateWithoutVisiteTerrainInput, VisitsUncheckedUpdateWithoutVisiteTerrainInput>
    create: XOR<VisitsCreateWithoutVisiteTerrainInput, VisitsUncheckedCreateWithoutVisiteTerrainInput>
    where?: VisitsWhereInput
  }

  export type VisitsUpdateToOneWithWhereWithoutVisiteTerrainInput = {
    where?: VisitsWhereInput
    data: XOR<VisitsUpdateWithoutVisiteTerrainInput, VisitsUncheckedUpdateWithoutVisiteTerrainInput>
  }

  export type VisitsUpdateWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    Planning?: PlanningUpdateOneRequiredWithoutVisitNestedInput
  }

  export type VisitsUncheckedUpdateWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    planningId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonnesUpsertWithWhereUniqueWithoutVisiteTerrainInput = {
    where: PersonnesWhereUniqueInput
    update: XOR<PersonnesUpdateWithoutVisiteTerrainInput, PersonnesUncheckedUpdateWithoutVisiteTerrainInput>
    create: XOR<PersonnesCreateWithoutVisiteTerrainInput, PersonnesUncheckedCreateWithoutVisiteTerrainInput>
  }

  export type PersonnesUpdateWithWhereUniqueWithoutVisiteTerrainInput = {
    where: PersonnesWhereUniqueInput
    data: XOR<PersonnesUpdateWithoutVisiteTerrainInput, PersonnesUncheckedUpdateWithoutVisiteTerrainInput>
  }

  export type PersonnesUpdateManyWithWhereWithoutVisiteTerrainInput = {
    where: PersonnesScalarWhereInput
    data: XOR<PersonnesUpdateManyMutationInput, PersonnesUncheckedUpdateManyWithoutVisiteTerrainInput>
  }

  export type PersonnesScalarWhereInput = {
    AND?: PersonnesScalarWhereInput | PersonnesScalarWhereInput[]
    OR?: PersonnesScalarWhereInput[]
    NOT?: PersonnesScalarWhereInput | PersonnesScalarWhereInput[]
    id?: UuidFilter<"Personnes"> | string
    name?: StringFilter<"Personnes"> | string
    role?: StringFilter<"Personnes"> | string
    signature?: BoolFilter<"Personnes"> | boolean
    conflitId?: UuidNullableFilter<"Personnes"> | string | null
    visiteTerrainId?: UuidNullableFilter<"Personnes"> | string | null
  }

  export type FilesUpsertWithWhereUniqueWithoutVisiteTerrainInput = {
    where: FilesWhereUniqueInput
    update: XOR<FilesUpdateWithoutVisiteTerrainInput, FilesUncheckedUpdateWithoutVisiteTerrainInput>
    create: XOR<FilesCreateWithoutVisiteTerrainInput, FilesUncheckedCreateWithoutVisiteTerrainInput>
  }

  export type FilesUpdateWithWhereUniqueWithoutVisiteTerrainInput = {
    where: FilesWhereUniqueInput
    data: XOR<FilesUpdateWithoutVisiteTerrainInput, FilesUncheckedUpdateWithoutVisiteTerrainInput>
  }

  export type FilesUpdateManyWithWhereWithoutVisiteTerrainInput = {
    where: FilesScalarWhereInput
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyWithoutVisiteTerrainInput>
  }

  export type UsersUpsertWithoutVisiteTerrainsInput = {
    update: XOR<UsersUpdateWithoutVisiteTerrainsInput, UsersUncheckedUpdateWithoutVisiteTerrainsInput>
    create: XOR<UsersCreateWithoutVisiteTerrainsInput, UsersUncheckedCreateWithoutVisiteTerrainsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutVisiteTerrainsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutVisiteTerrainsInput, UsersUncheckedUpdateWithoutVisiteTerrainsInput>
  }

  export type UsersUpdateWithoutVisiteTerrainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutVisiteTerrainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PersonnesCreateWithoutConflitInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    VisiteTerrain?: VisiteTerrainCreateNestedOneWithoutPersonnesInput
  }

  export type PersonnesUncheckedCreateWithoutConflitInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    visiteTerrainId?: string | null
  }

  export type PersonnesCreateOrConnectWithoutConflitInput = {
    where: PersonnesWhereUniqueInput
    create: XOR<PersonnesCreateWithoutConflitInput, PersonnesUncheckedCreateWithoutConflitInput>
  }

  export type PersonnesCreateManyConflitInputEnvelope = {
    data: PersonnesCreateManyConflitInput | PersonnesCreateManyConflitInput[]
    skipDuplicates?: boolean
  }

  export type FilesCreateWithoutConflitInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    Users?: UsersCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateWithoutConflitInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    rencontreId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesCreateOrConnectWithoutConflitInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutConflitInput, FilesUncheckedCreateWithoutConflitInput>
  }

  export type FilesCreateManyConflitInputEnvelope = {
    data: FilesCreateManyConflitInput | FilesCreateManyConflitInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutConflitInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutConflitInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutConflitInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConflitInput, UsersUncheckedCreateWithoutConflitInput>
  }

  export type AccompanimentCreateWithoutConflitsInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutConflitsInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    rencontre?: RencontreUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutConflitsInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutConflitsInput, AccompanimentUncheckedCreateWithoutConflitsInput>
  }

  export type PersonnesUpsertWithWhereUniqueWithoutConflitInput = {
    where: PersonnesWhereUniqueInput
    update: XOR<PersonnesUpdateWithoutConflitInput, PersonnesUncheckedUpdateWithoutConflitInput>
    create: XOR<PersonnesCreateWithoutConflitInput, PersonnesUncheckedCreateWithoutConflitInput>
  }

  export type PersonnesUpdateWithWhereUniqueWithoutConflitInput = {
    where: PersonnesWhereUniqueInput
    data: XOR<PersonnesUpdateWithoutConflitInput, PersonnesUncheckedUpdateWithoutConflitInput>
  }

  export type PersonnesUpdateManyWithWhereWithoutConflitInput = {
    where: PersonnesScalarWhereInput
    data: XOR<PersonnesUpdateManyMutationInput, PersonnesUncheckedUpdateManyWithoutConflitInput>
  }

  export type FilesUpsertWithWhereUniqueWithoutConflitInput = {
    where: FilesWhereUniqueInput
    update: XOR<FilesUpdateWithoutConflitInput, FilesUncheckedUpdateWithoutConflitInput>
    create: XOR<FilesCreateWithoutConflitInput, FilesUncheckedCreateWithoutConflitInput>
  }

  export type FilesUpdateWithWhereUniqueWithoutConflitInput = {
    where: FilesWhereUniqueInput
    data: XOR<FilesUpdateWithoutConflitInput, FilesUncheckedUpdateWithoutConflitInput>
  }

  export type FilesUpdateManyWithWhereWithoutConflitInput = {
    where: FilesScalarWhereInput
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyWithoutConflitInput>
  }

  export type UsersUpsertWithoutConflitInput = {
    update: XOR<UsersUpdateWithoutConflitInput, UsersUncheckedUpdateWithoutConflitInput>
    create: XOR<UsersCreateWithoutConflitInput, UsersUncheckedCreateWithoutConflitInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConflitInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConflitInput, UsersUncheckedUpdateWithoutConflitInput>
  }

  export type UsersUpdateWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccompanimentUpsertWithoutConflitsInput = {
    update: XOR<AccompanimentUpdateWithoutConflitsInput, AccompanimentUncheckedUpdateWithoutConflitsInput>
    create: XOR<AccompanimentCreateWithoutConflitsInput, AccompanimentUncheckedCreateWithoutConflitsInput>
    where?: AccompanimentWhereInput
  }

  export type AccompanimentUpdateToOneWithWhereWithoutConflitsInput = {
    where?: AccompanimentWhereInput
    data: XOR<AccompanimentUpdateWithoutConflitsInput, AccompanimentUncheckedUpdateWithoutConflitsInput>
  }

  export type AccompanimentUpdateWithoutConflitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutConflitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type SignatureCreateWithoutRencontreInput = {
    id?: string
    date: Date | string
    present?: boolean
    member: MemberCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateWithoutRencontreInput = {
    id?: string
    date: Date | string
    present?: boolean
    memberId: string
  }

  export type SignatureCreateOrConnectWithoutRencontreInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutRencontreInput, SignatureUncheckedCreateWithoutRencontreInput>
  }

  export type SignatureCreateManyRencontreInputEnvelope = {
    data: SignatureCreateManyRencontreInput | SignatureCreateManyRencontreInput[]
    skipDuplicates?: boolean
  }

  export type FilesCreateWithoutRencontreInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    Upload?: UploadCreateNestedManyWithoutFileInput
    Users?: UsersCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateWithoutRencontreInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    Upload?: UploadUncheckedCreateNestedManyWithoutFileInput
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesCreateOrConnectWithoutRencontreInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutRencontreInput, FilesUncheckedCreateWithoutRencontreInput>
  }

  export type FilesCreateManyRencontreInputEnvelope = {
    data: FilesCreateManyRencontreInput | FilesCreateManyRencontreInput[]
    skipDuplicates?: boolean
  }

  export type AccompanimentCreateWithoutRencontreInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutAccompanimentsInput
    map?: MapsCreateNestedOneWithoutAccompanimentInput
    members?: MemberCreateNestedManyWithoutAccompanimentInput
    file: FilesCreateNestedOneWithoutAccompanimentsInput
    media?: FilesCreateNestedManyWithoutMediaInput
    purchases?: PurchaseCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitCreateNestedManyWithoutAccompanimentInput
    project: ProjectCreateNestedOneWithoutAccompanimentsInput
    planning?: PlanningCreateNestedOneWithoutAccompanimentsInput
  }

  export type AccompanimentUncheckedCreateWithoutRencontreInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
    map?: MapsUncheckedCreateNestedOneWithoutAccompanimentInput
    members?: MemberUncheckedCreateNestedManyWithoutAccompanimentInput
    media?: FilesUncheckedCreateNestedManyWithoutMediaInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutAccompanimentInput
    conflits?: ConflitUncheckedCreateNestedManyWithoutAccompanimentInput
  }

  export type AccompanimentCreateOrConnectWithoutRencontreInput = {
    where: AccompanimentWhereUniqueInput
    create: XOR<AccompanimentCreateWithoutRencontreInput, AccompanimentUncheckedCreateWithoutRencontreInput>
  }

  export type UsersCreateWithoutRencontresInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutRencontresInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutRencontresInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRencontresInput, UsersUncheckedCreateWithoutRencontresInput>
  }

  export type SignatureUpsertWithWhereUniqueWithoutRencontreInput = {
    where: SignatureWhereUniqueInput
    update: XOR<SignatureUpdateWithoutRencontreInput, SignatureUncheckedUpdateWithoutRencontreInput>
    create: XOR<SignatureCreateWithoutRencontreInput, SignatureUncheckedCreateWithoutRencontreInput>
  }

  export type SignatureUpdateWithWhereUniqueWithoutRencontreInput = {
    where: SignatureWhereUniqueInput
    data: XOR<SignatureUpdateWithoutRencontreInput, SignatureUncheckedUpdateWithoutRencontreInput>
  }

  export type SignatureUpdateManyWithWhereWithoutRencontreInput = {
    where: SignatureScalarWhereInput
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyWithoutRencontreInput>
  }

  export type FilesUpsertWithWhereUniqueWithoutRencontreInput = {
    where: FilesWhereUniqueInput
    update: XOR<FilesUpdateWithoutRencontreInput, FilesUncheckedUpdateWithoutRencontreInput>
    create: XOR<FilesCreateWithoutRencontreInput, FilesUncheckedCreateWithoutRencontreInput>
  }

  export type FilesUpdateWithWhereUniqueWithoutRencontreInput = {
    where: FilesWhereUniqueInput
    data: XOR<FilesUpdateWithoutRencontreInput, FilesUncheckedUpdateWithoutRencontreInput>
  }

  export type FilesUpdateManyWithWhereWithoutRencontreInput = {
    where: FilesScalarWhereInput
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyWithoutRencontreInput>
  }

  export type AccompanimentUpsertWithoutRencontreInput = {
    update: XOR<AccompanimentUpdateWithoutRencontreInput, AccompanimentUncheckedUpdateWithoutRencontreInput>
    create: XOR<AccompanimentCreateWithoutRencontreInput, AccompanimentUncheckedCreateWithoutRencontreInput>
    where?: AccompanimentWhereInput
  }

  export type AccompanimentUpdateToOneWithWhereWithoutRencontreInput = {
    where?: AccompanimentWhereInput
    data: XOR<AccompanimentUpdateWithoutRencontreInput, AccompanimentUncheckedUpdateWithoutRencontreInput>
  }

  export type AccompanimentUpdateWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type UsersUpsertWithoutRencontresInput = {
    update: XOR<UsersUpdateWithoutRencontresInput, UsersUncheckedUpdateWithoutRencontresInput>
    create: XOR<UsersCreateWithoutRencontresInput, UsersUncheckedCreateWithoutRencontresInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutRencontresInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutRencontresInput, UsersUncheckedUpdateWithoutRencontresInput>
  }

  export type UsersUpdateWithoutRencontresInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutRencontresInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FilesCreateWithoutUploadInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrain?: VisiteTerrainCreateNestedOneWithoutFilesInput
    conflit?: ConflitCreateNestedOneWithoutFilesInput
    rencontre?: RencontreCreateNestedOneWithoutFilesInput
    Users?: UsersCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentCreateNestedManyWithoutFileInput
    media?: AccompanimentCreateNestedManyWithoutMediaInput
  }

  export type FilesUncheckedCreateWithoutUploadInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
    rencontreId?: string | null
    Users?: UsersUncheckedCreateNestedManyWithoutCvInput
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutFileInput
    media?: AccompanimentUncheckedCreateNestedManyWithoutMediaInput
  }

  export type FilesCreateOrConnectWithoutUploadInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutUploadInput, FilesUncheckedCreateWithoutUploadInput>
  }

  export type UsersCreateWithoutUploadsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    cv?: FilesCreateNestedOneWithoutUsersInput
    accompaniments?: AccompanimentCreateNestedManyWithoutUsersInput
    plannings?: PlanningCreateNestedManyWithoutUsersInput
    emargements?: EmargementCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainCreateNestedManyWithoutUsersInput
    rencontres?: RencontreCreateNestedManyWithoutUsersInput
    conflit?: ConflitCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    messageView?: MessageViewCreateNestedManyWithoutUserInput
    Classe?: ClasseCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutUploadsInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    filesId?: string | null
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
    accompaniments?: AccompanimentUncheckedCreateNestedManyWithoutUsersInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutUsersInput
    emargements?: EmargementUncheckedCreateNestedManyWithoutUsersInput
    visiteTerrains?: VisiteTerrainUncheckedCreateNestedManyWithoutUsersInput
    rencontres?: RencontreUncheckedCreateNestedManyWithoutUsersInput
    conflit?: ConflitUncheckedCreateNestedManyWithoutUsersInput
    chatParticipant?: ChatParticipantUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageView?: MessageViewUncheckedCreateNestedManyWithoutUserInput
    Classe?: ClasseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutUploadsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUploadsInput, UsersUncheckedCreateWithoutUploadsInput>
  }

  export type FilesUpsertWithoutUploadInput = {
    update: XOR<FilesUpdateWithoutUploadInput, FilesUncheckedUpdateWithoutUploadInput>
    create: XOR<FilesCreateWithoutUploadInput, FilesUncheckedCreateWithoutUploadInput>
    where?: FilesWhereInput
  }

  export type FilesUpdateToOneWithWhereWithoutUploadInput = {
    where?: FilesWhereInput
    data: XOR<FilesUpdateWithoutUploadInput, FilesUncheckedUpdateWithoutUploadInput>
  }

  export type FilesUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateWithoutUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UsersUpsertWithoutUploadsInput = {
    update: XOR<UsersUpdateWithoutUploadsInput, UsersUncheckedUpdateWithoutUploadsInput>
    create: XOR<UsersCreateWithoutUploadsInput, UsersUncheckedCreateWithoutUploadsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUploadsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUploadsInput, UsersUncheckedUpdateWithoutUploadsInput>
  }

  export type UsersUpdateWithoutUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cv?: FilesUpdateOneWithoutUsersNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    filesId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UploadCreateManyFileInput = {
    id?: string
    titre: string
    date: Date | string
    userId: string
  }

  export type UsersCreateManyCvInput = {
    id?: string
    authId: string
    profile: string
    name: string
    email: string
    phone: string
    address: string
    gender: string
    dob: Date | string
    status?: $Enums.Status
    type?: $Enums.Type
    routes?: UsersCreateroutesInput | string[]
    access?: UsersCreateaccessInput | string[]
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type AccompanimentCreateManyFileInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type UploadUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutUploadsNestedInput
  }

  export type UploadUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UploadUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUpdateWithoutCvInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUpdateManyWithoutUserNestedInput
    Classe?: ClasseUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCvInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutUsersNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutUsersNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutUsersNestedInput
    visiteTerrains?: VisiteTerrainUncheckedUpdateManyWithoutUsersNestedInput
    rencontres?: RencontreUncheckedUpdateManyWithoutUsersNestedInput
    conflit?: ConflitUncheckedUpdateManyWithoutUsersNestedInput
    chatParticipant?: ChatParticipantUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    messageView?: MessageViewUncheckedUpdateManyWithoutUserNestedInput
    Classe?: ClasseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutCvInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    routes?: UsersUpdateroutesInput | string[]
    access?: UsersUpdateaccessInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type AccompanimentUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type AccompanimentUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentCreateManyUsersInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    fileId: string
    projectId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PlanningCreateManyUsersInput = {
    id?: string
  }

  export type EmargementCreateManyUsersInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    memberId: string
  }

  export type VisiteTerrainCreateManyUsersInput = {
    id?: string
    visitId: string
    observations: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type RencontreCreateManyUsersInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    accompanimentId: string
  }

  export type ConflitCreateManyUsersInput = {
    id?: string
    nature: string
    resolution: string
    status?: boolean
    accompanimentId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ChatParticipantCreateManyUserInput = {
    id?: string
    chatId: string
    joinedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    sentAt?: Date | string
    chatId: string
  }

  export type UploadCreateManyUserInput = {
    id?: string
    titre: string
    date: Date | string
    fileId: string
  }

  export type MessageViewCreateManyUserInput = {
    id?: string
    view?: boolean
    messageId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ClasseCreateManyUserInput = {
    id?: string
    name: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type AccompanimentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type AccompanimentUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    accompaniments?: AccompanimentUpdateManyWithoutPlanningNestedInput
    visit?: VisitsUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutPlanningNestedInput
    visit?: VisitsUncheckedUpdateManyWithoutPlanningNestedInput
  }

  export type PlanningUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmargementUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    member?: MemberUpdateOneRequiredWithoutEmargementsNestedInput
  }

  export type EmargementUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type EmargementUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type VisiteTerrainUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitsUpdateOneRequiredWithoutVisiteTerrainNestedInput
    personnes?: PersonnesUpdateManyWithoutVisiteTerrainNestedInput
    files?: FilesUpdateManyWithoutVisiteTerrainNestedInput
  }

  export type VisiteTerrainUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnes?: PersonnesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
    files?: FilesUncheckedUpdateManyWithoutVisiteTerrainNestedInput
  }

  export type VisiteTerrainUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    observations?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RencontreUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    signatures?: SignatureUpdateManyWithoutRencontreNestedInput
    files?: FilesUpdateManyWithoutRencontreNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutRencontreNestedInput
  }

  export type RencontreUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    accompanimentId?: StringFieldUpdateOperationsInput | string
    signatures?: SignatureUncheckedUpdateManyWithoutRencontreNestedInput
    files?: FilesUncheckedUpdateManyWithoutRencontreNestedInput
  }

  export type RencontreUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    accompanimentId?: StringFieldUpdateOperationsInput | string
  }

  export type ConflitUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUpdateManyWithoutConflitNestedInput
    files?: FilesUpdateManyWithoutConflitNestedInput
    accompaniment?: AccompanimentUpdateOneRequiredWithoutConflitsNestedInput
  }

  export type ConflitUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUncheckedUpdateManyWithoutConflitNestedInput
    files?: FilesUncheckedUpdateManyWithoutConflitNestedInput
  }

  export type ConflitUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    accompanimentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChatParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageView?: MessageViewUpdateManyWithoutMessageNestedInput
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
    messageView?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type UploadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FilesUpdateOneRequiredWithoutUploadNestedInput
  }

  export type UploadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type UploadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutMessageViewNestedInput
  }

  export type MessageViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClasseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutClasseNestedInput
    project?: ProjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClasseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentCreateManyProjectInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    planningId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateManyProjectInput = {
    id?: string
    date: Date | string
    reason: string
    memberId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateManyProjectInput = {
    id?: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ClasseCreateManyProjectInput = {
    id?: string
    name: string
    usersId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type AccompanimentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    planning?: PlanningUpdateOneWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type AccompanimentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    planningId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUpdateManyWithoutMemberNestedInput
    leave?: LeaveUpdateOneWithoutMemberNestedInput
    accompaniment?: AccompanimentUpdateOneWithoutMembersNestedInput
    classe?: ClasseUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutMemberNestedInput
    leave?: LeaveUncheckedUpdateOneWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClasseUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutClasseNestedInput
    members?: MemberUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyAccompanimentInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    classeId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyAccompanimentInput = {
    id?: string
    total: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type ConflitCreateManyAccompanimentInput = {
    id?: string
    nature: string
    resolution: string
    usersId: string
    status?: boolean
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type RencontreCreateManyAccompanimentInput = {
    id?: string
    date: Date | string
    lieu: string
    order?: RencontreCreateorderInput | string[]
    decisions?: RencontreCreatedecisionsInput | string[]
    actions?: RencontreCreateactionsInput | string[]
    usersId: string
  }

  export type MemberUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    signatures?: SignatureUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUpdateManyWithoutMemberNestedInput
    leave?: LeaveUpdateOneWithoutMemberNestedInput
    classe?: ClasseUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutMemberNestedInput
    leave?: LeaveUncheckedUpdateOneWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    classeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
  }

  export type FilesUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FilesUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflitUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUpdateManyWithoutConflitNestedInput
    files?: FilesUpdateManyWithoutConflitNestedInput
    users?: UsersUpdateOneRequiredWithoutConflitNestedInput
  }

  export type ConflitUncheckedUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partieImpliques?: PersonnesUncheckedUpdateManyWithoutConflitNestedInput
    files?: FilesUncheckedUpdateManyWithoutConflitNestedInput
  }

  export type ConflitUncheckedUpdateManyWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    nature?: StringFieldUpdateOperationsInput | string
    resolution?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RencontreUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    signatures?: SignatureUpdateManyWithoutRencontreNestedInput
    files?: FilesUpdateManyWithoutRencontreNestedInput
    users?: UsersUpdateOneRequiredWithoutRencontresNestedInput
  }

  export type RencontreUncheckedUpdateWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    usersId?: StringFieldUpdateOperationsInput | string
    signatures?: SignatureUncheckedUpdateManyWithoutRencontreNestedInput
    files?: FilesUncheckedUpdateManyWithoutRencontreNestedInput
  }

  export type RencontreUncheckedUpdateManyWithoutAccompanimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: StringFieldUpdateOperationsInput | string
    order?: RencontreUpdateorderInput | string[]
    decisions?: RencontreUpdatedecisionsInput | string[]
    actions?: RencontreUpdateactionsInput | string[]
    usersId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCreateManyClasseInput = {
    id?: string
    projectId: string
    profile: string
    name: string
    phone: string
    gender: string
    dob: Date | string
    commune: string
    residential: string
    disability: string
    language: string
    attestation: string
    accompanimentId?: string | null
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateWithoutClasseInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    signatures?: SignatureUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUpdateManyWithoutMemberNestedInput
    leave?: LeaveUpdateOneWithoutMemberNestedInput
    accompaniment?: AccompanimentUpdateOneWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutClasseInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutMemberNestedInput
    emargements?: EmargementUncheckedUpdateManyWithoutMemberNestedInput
    leave?: LeaveUncheckedUpdateOneWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutClasseInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    commune?: StringFieldUpdateOperationsInput | string
    residential?: StringFieldUpdateOperationsInput | string
    disability?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    attestation?: StringFieldUpdateOperationsInput | string
    accompanimentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureCreateManyMemberInput = {
    id?: string
    date: Date | string
    present?: boolean
    rencontreId?: string | null
  }

  export type EmargementCreateManyMemberInput = {
    id?: string
    date: Date | string
    signature: boolean
    cni: string
    PhotoCni: string
    montant: number
    observations: string
    usersId: string
  }

  export type SignatureUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    Rencontre?: RencontreUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmargementUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateOneRequiredWithoutEmargementsNestedInput
  }

  export type EmargementUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
  }

  export type EmargementUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    cni?: StringFieldUpdateOperationsInput | string
    PhotoCni?: StringFieldUpdateOperationsInput | string
    montant?: IntFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatParticipantCreateManyChatInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    content: string
    sentAt?: Date | string
    senderId: string
  }

  export type ChatParticipantUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutChatParticipantNestedInput
  }

  export type ChatParticipantUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatParticipantUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageView?: MessageViewUpdateManyWithoutMessageNestedInput
    sender?: UsersUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    messageView?: MessageViewUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageViewCreateManyMessageInput = {
    id?: string
    view?: boolean
    userId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type MessageViewUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutMessageViewNestedInput
  }

  export type MessageViewUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageViewUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    view?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccompanimentCreateManyPlanningInput = {
    id?: string
    name: string
    adresse: string
    phones?: AccompanimentCreatephonesInput | number[]
    budget: number
    status?: boolean
    usersid: string
    fileId: string
    projectId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type VisitsCreateManyPlanningInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    status?: boolean
    location: string
    objetif: string
  }

  export type AccompanimentUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutAccompanimentsNestedInput
    map?: MapsUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUpdateManyWithoutAccompanimentNestedInput
    file?: FilesUpdateOneRequiredWithoutAccompanimentsNestedInput
    media?: FilesUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUpdateManyWithoutAccompanimentNestedInput
    project?: ProjectUpdateOneRequiredWithoutAccompanimentsNestedInput
  }

  export type AccompanimentUncheckedUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapsUncheckedUpdateOneWithoutAccompanimentNestedInput
    members?: MemberUncheckedUpdateManyWithoutAccompanimentNestedInput
    media?: FilesUncheckedUpdateManyWithoutMediaNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutAccompanimentNestedInput
    conflits?: ConflitUncheckedUpdateManyWithoutAccompanimentNestedInput
    rencontre?: RencontreUncheckedUpdateManyWithoutAccompanimentNestedInput
  }

  export type AccompanimentUncheckedUpdateManyWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    phones?: AccompanimentUpdatephonesInput | number[]
    budget?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    usersid?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitsUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    VisiteTerrain?: VisiteTerrainUpdateOneWithoutVisitNestedInput
  }

  export type VisitsUncheckedUpdateWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
    VisiteTerrain?: VisiteTerrainUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type VisitsUncheckedUpdateManyWithoutPlanningInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    objetif?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseItemsCreateManyPurchaseInput = {
    id?: string
    name: string
    price: string
    image: string
    quantity: number
    date: Date | string
  }

  export type PurchaseItemsUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnesCreateManyVisiteTerrainInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    conflitId?: string | null
  }

  export type FilesCreateManyVisiteTerrainInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    conflitId?: string | null
    rencontreId?: string | null
  }

  export type PersonnesUpdateWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    Conflit?: ConflitUpdateOneWithoutPartieImpliquesNestedInput
  }

  export type PersonnesUncheckedUpdateWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnesUncheckedUpdateManyWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilesUpdateWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateManyWithoutVisiteTerrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnesCreateManyConflitInput = {
    id?: string
    name: string
    role: string
    signature?: boolean
    visiteTerrainId?: string | null
  }

  export type FilesCreateManyConflitInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    rencontreId?: string | null
  }

  export type PersonnesUpdateWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    VisiteTerrain?: VisiteTerrainUpdateOneWithoutPersonnesNestedInput
  }

  export type PersonnesUncheckedUpdateWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnesUncheckedUpdateManyWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    signature?: BoolFieldUpdateOperationsInput | boolean
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilesUpdateWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    rencontre?: RencontreUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateManyWithoutConflitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    rencontreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureCreateManyRencontreInput = {
    id?: string
    date: Date | string
    present?: boolean
    memberId: string
  }

  export type FilesCreateManyRencontreInput = {
    id?: string
    name: string
    type: string
    url: string
    size?: number
    visiteTerrainId?: string | null
    conflitId?: string | null
  }

  export type SignatureUpdateWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    member?: MemberUpdateOneRequiredWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type SignatureUncheckedUpdateManyWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type FilesUpdateWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrain?: VisiteTerrainUpdateOneWithoutFilesNestedInput
    conflit?: ConflitUpdateOneWithoutFilesNestedInput
    Upload?: UploadUpdateManyWithoutFileNestedInput
    Users?: UsersUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUpdateManyWithoutFileNestedInput
    media?: AccompanimentUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
    Upload?: UploadUncheckedUpdateManyWithoutFileNestedInput
    Users?: UsersUncheckedUpdateManyWithoutCvNestedInput
    accompaniments?: AccompanimentUncheckedUpdateManyWithoutFileNestedInput
    media?: AccompanimentUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FilesUncheckedUpdateManyWithoutRencontreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    visiteTerrainId?: NullableStringFieldUpdateOperationsInput | string | null
    conflitId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}